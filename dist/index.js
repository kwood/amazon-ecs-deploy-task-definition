/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 32932:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const path = __nccwpck_require__(71017);
const core = __nccwpck_require__(42186);
const { 
  ECSClient, 
  RegisterTaskDefinitionCommand, 
  DescribeServicesCommand, 
  RunTaskCommand, 
  DescribeTasksCommand,
  waitUntilTasksStopped, 
  waitUntilServicesStable, 
  UpdateServiceCommand
} = __nccwpck_require__(18209);
const { CloudWatchLogsClient, GetLogEventsCommand } = __nccwpck_require__(31573);
const { CodeDeployClient, AddTagsToOnPremisesInstancesCommand } = __nccwpck_require__(26692);
const yaml = __nccwpck_require__(44083);
const fs = __nccwpck_require__(57147);
const crypto = __nccwpck_require__(6113);

// Attributes that are returned by DescribeTaskDefinition, but are not valid RegisterTaskDefinition inputs
const IGNORED_TASK_DEFINITION_ATTRIBUTES = [
  'compatibilities',
  'taskDefinitionArn',
  'requiresAttributes',
  'revision',
  'status',
  'registeredAt',
  'deregisteredAt',
  'registeredBy'
];

// Deploy to a service that uses the 'ECS' deployment controller
async function updateEcsService(ecs, clusterName, service, taskDefArn, waitForService, waitForMinutes, forceNewDeployment) {
  core.debug('Updating the service');
  await ecs.send(new UpdateServiceCommand({
    cluster: clusterName,
    service: service,
    taskDefinition: taskDefArn,
    forceNewDeployment: forceNewDeployment
  }));

  const consoleHostname = 'console.aws.amazon.com';

  core.info(`Deployment started. Watch this deployment's progress in the Amazon ECS console: https://${consoleHostname}/ecs/home?region=${process.env.AWS_REGION}#/clusters/${clusterName}/services/${service}/events`);

  // Wait for service stability
  if (waitForService && waitForService.toLowerCase() === 'true') {
    core.info(`Waiting for the service ${service} to become stable. Will wait for ${waitForMinutes} minutes`);
    await waitUntilServicesStable({client: ecs, minDelay:10, maxDelay: 10, maxWaitTime: 1200}, {
      services: [service],
      cluster: clusterName,
    });
  } else {
    core.debug('Not waiting for the service to become stable');
  }
}

// Find value in a CodeDeploy AppSpec file with a case-insensitive key
function findAppSpecValue(obj, keyName) {
  return obj[findAppSpecKey(obj, keyName)];
}

function findAppSpecKey(obj, keyName) {
  if (!obj) {
    throw new Error(`AppSpec file must include property '${keyName}'`);
  }

  const keyToMatch = keyName.toLowerCase();

  for (var key in obj) {
    if (key.toLowerCase() == keyToMatch) {
      return key;
    }
  }

  throw new Error(`AppSpec file must include property '${keyName}'`);
}

function isEmptyValue(value) {
  if (value === null || value === undefined || value === '') {
    return true;
  }

  if (Array.isArray(value)) {
    for (var element of value) {
      if (!isEmptyValue(element)) {
        // the array has at least one non-empty element
        return false;
      }
    }
    // the array has no non-empty elements
    return true;
  }

  if (typeof value === 'object') {
    for (var childValue of Object.values(value)) {
      if (!isEmptyValue(childValue)) {
        // the object has at least one non-empty property
        return false;
      }
    }
    // the object has no non-empty property
    return true;
  }

  return false;
}

function emptyValueReplacer(_, value) {
  if (isEmptyValue(value)) {
    return undefined;
  }

  if (Array.isArray(value)) {
    return value.filter(e => !isEmptyValue(e));
  }

  return value;
}

function cleanNullKeys(obj) {
  return JSON.parse(JSON.stringify(obj, emptyValueReplacer));
}

function removeIgnoredAttributes(taskDef) {
  for (var attribute of IGNORED_TASK_DEFINITION_ATTRIBUTES) {
    if (taskDef[attribute]) {
      core.warning(`Ignoring property '${attribute}' in the task definition file. ` +
        'This property is returned by the Amazon ECS DescribeTaskDefinition API and may be shown in the ECS console, ' +
        'but it is not a valid field when registering a new task definition. ' +
        'This field can be safely removed from your task definition file.');
      delete taskDef[attribute];
    }
  }

  return taskDef;
}

function maintainValidObjects(taskDef) {
  if (validateProxyConfigurations(taskDef)) {
    taskDef.proxyConfiguration.properties.forEach((property, index, arr) => {
      if (!('value' in property)) {
        arr[index].value = '';
      }
      if (!('name' in property)) {
        arr[index].name = '';
      }
    });
  }

  if (taskDef && taskDef.containerDefinitions) {
    taskDef.containerDefinitions.forEach((container) => {
      if (container.environment) {
        container.environment.forEach((property, index, arr) => {
          if (!('value' in property)) {
            arr[index].value = '';
          }
        });
      }
    });
  }
  return taskDef;
}

function validateProxyConfigurations(taskDef) {
  return 'proxyConfiguration' in taskDef && taskDef.proxyConfiguration.type && taskDef.proxyConfiguration.type == 'APPMESH' && taskDef.proxyConfiguration.properties && taskDef.proxyConfiguration.properties.length > 0;
}

// Deploy to a service that uses the 'CODE_DEPLOY' deployment controller
async function createCodeDeployDeployment(codedeploy, clusterName, service, taskDefArn, waitForService, waitForMinutes) {
  // core.debug('Updating AppSpec file with new task definition ARN');

  // let codeDeployAppSpecFile = core.getInput('codedeploy-appspec', { required: false });
  // codeDeployAppSpecFile = codeDeployAppSpecFile ? codeDeployAppSpecFile : 'appspec.yaml';

  // let codeDeployApp = core.getInput('codedeploy-application', { required: false });
  // codeDeployApp = codeDeployApp ? codeDeployApp : `AppECS-${clusterName}-${service}`;

  // let codeDeployGroup = core.getInput('codedeploy-deployment-group', { required: false });
  // codeDeployGroup = codeDeployGroup ? codeDeployGroup : `DgpECS-${clusterName}-${service}`;

  // let codeDeployDescription = core.getInput('codedeploy-deployment-description', { required: false });

  // let deploymentGroupDetails = await codedeploy.getDeploymentGroup({
  //   applicationName: codeDeployApp,
  //   deploymentGroupName: codeDeployGroup
  // }).promise();
  // deploymentGroupDetails = deploymentGroupDetails.deploymentGroupInfo;

  // // Insert the task def ARN into the appspec file
  // const appSpecPath = path.isAbsolute(codeDeployAppSpecFile) ?
  //   codeDeployAppSpecFile :
  //   path.join(process.env.GITHUB_WORKSPACE, codeDeployAppSpecFile);
  // const fileContents = fs.readFileSync(appSpecPath, 'utf8');
  // const appSpecContents = yaml.parse(fileContents);

  // for (var resource of findAppSpecValue(appSpecContents, 'resources')) {
  //   for (var name in resource) {
  //     const resourceContents = resource[name];
  //     const properties = findAppSpecValue(resourceContents, 'properties');
  //     const taskDefKey = findAppSpecKey(properties, 'taskDefinition');
  //     properties[taskDefKey] = taskDefArn;
  //   }
  // }

  // const appSpecString = JSON.stringify(appSpecContents);
  // const appSpecHash = crypto.createHash('sha256').update(appSpecString).digest('hex');

  // // Start the deployment with the updated appspec contents
  // core.debug('Starting CodeDeploy deployment');
  // let deploymentParams = {
  //   applicationName: codeDeployApp,
  //   deploymentGroupName: codeDeployGroup,
  //   revision: {
  //     revisionType: 'AppSpecContent',
  //     appSpecContent: {
  //       content: appSpecString,
  //       sha256: appSpecHash
  //     }
  //   }
  // };
  // // If it hasn't been set then we don't even want to pass it to the api call to maintain previous behaviour.
  // if (codeDeployDescription) {
  //   deploymentParams.description = codeDeployDescription
  // }
  // const createDeployResponse = await codedeploy.createDeployment(deploymentParams).promise();
  // core.setOutput('codedeploy-deployment-id', createDeployResponse.deploymentId);
  // core.info(`Deployment started. Watch this deployment's progress in the AWS CodeDeploy console: https://console.aws.amazon.com/codesuite/codedeploy/deployments/${createDeployResponse.deploymentId}?region=${aws.config.region}`);

  // // Wait for deployment to complete
  // if (waitForService && waitForService.toLowerCase() === 'true') {
  //   // Determine wait time
  //   const deployReadyWaitMin = deploymentGroupDetails.blueGreenDeploymentConfiguration.deploymentReadyOption.waitTimeInMinutes;
  //   const terminationWaitMin = deploymentGroupDetails.blueGreenDeploymentConfiguration.terminateBlueInstancesOnDeploymentSuccess.terminationWaitTimeInMinutes;
  //   let totalWaitMin = deployReadyWaitMin + terminationWaitMin + waitForMinutes;
  //   if (totalWaitMin > MAX_WAIT_MINUTES) {
  //     totalWaitMin = MAX_WAIT_MINUTES;
  //   }
  //   const maxAttempts = (totalWaitMin * 60) / WAIT_DEFAULT_DELAY_SEC;

  //   core.debug(`Waiting for the deployment to complete. Will wait for ${totalWaitMin} minutes`);
  //   await codedeploy.waitFor('deploymentSuccessful', {
  //     deploymentId: createDeployResponse.deploymentId,
  //     $waiter: {
  //       delay: WAIT_DEFAULT_DELAY_SEC,
  //       maxAttempts: maxAttempts
  //     }
  //   }).promise();
  // } else {
  //   core.debug('Not waiting for the deployment to complete');
  // }
}

async function run() {
  try {
    const ecs = new ECSClient({
      customUserAgent: 'amazon-ecs-deploy-task-definition-for-github-actions'
    });
    const codedeploy = new CodeDeployClient({
      customUserAgent: 'amazon-ecs-deploy-task-definition-for-github-actions'
    });
    const cloudwatch = new CloudWatchLogsClient({
      customUserAgent: 'amazon-ecs-deploy-task-definition-for-github-actions'
    });

    // Get inputs
    const taskDefinitionFile = core.getInput('task-definition', { required: true });
    const service = core.getInput('service', { required: false });
    const cluster = core.getInput('cluster', { required: false });
    const waitForService = core.getInput('wait-for-service-stability', { required: false });
    const preDeployCommand = core.getInput('pre-deploy-command', { required: false });
    let waitForMinutes = parseInt(core.getInput('wait-for-minutes', { required: false })) || 30;

    const forceNewDeployInput = core.getInput('force-new-deployment', { required: false }) || 'false';
    const forceNewDeployment = forceNewDeployInput.toLowerCase() === 'true';

    // Register the task definition
    core.info('Registering the task definition');
    const taskDefPath = path.isAbsolute(taskDefinitionFile) ?
      taskDefinitionFile :
      path.join(process.env.GITHUB_WORKSPACE, taskDefinitionFile);
    const fileContents = fs.readFileSync(taskDefPath, 'utf8');
    const taskDefContents = maintainValidObjects(removeIgnoredAttributes(cleanNullKeys(yaml.parse(fileContents))));
    let registerResponse;
    try {
      registerResponse = await ecs.send(new RegisterTaskDefinitionCommand(taskDefContents))
    } catch (error) {
      core.setFailed("Failed to register task definition in ECS: " + error.message);
      core.debug("Task definition contents:");
      core.debug(JSON.stringify(taskDefContents, undefined, 4));
      throw (error);
    }
    const taskDefArn = registerResponse.taskDefinition.taskDefinitionArn;
    core.info(`Task definition registered`);
    core.setOutput('task-definition-arn', taskDefArn);


    // Update the service with the new task definition
    if (service) {
      const clusterName = cluster ? cluster : 'default';

      // Determine the deployment controller

      const describeResponse = await ecs.send(new DescribeServicesCommand({
        services: [service],
        cluster: clusterName
      }));

      if (describeResponse.failures && describeResponse.failures.length > 0) {
        const failure = describeResponse.failures[0];
        throw new Error(`${failure.arn} is ${failure.reason}`);
      }

      const serviceResponse = describeResponse.services[0];
      if (serviceResponse.status != 'ACTIVE') {
        throw new Error(`Service is ${serviceResponse.status}`);
      }


      if (preDeployCommand) {
        core.info(`Running pre-deploy command: ${preDeployCommand}`);
        const networkConfig = {
          awsvpcConfiguration: {
            subnets: registerResponse.taskDefinition.networkMode === 'awsvpc' ? describeResponse.services[0].networkConfiguration.awsvpcConfiguration.subnets : [],
            securityGroups: registerResponse.taskDefinition.networkMode === 'awsvpc' ? describeResponse.services[0].networkConfiguration.awsvpcConfiguration.securityGroups : [],
            assignPublicIp: registerResponse.taskDefinition.networkMode === 'awsvpc' ? describeResponse.services[0].networkConfiguration.awsvpcConfiguration.assignPublicIp : 'DISABLED'
          }
        };
        const runTaskResponse = await ecs.send(new RunTaskCommand({
          taskDefinition: taskDefArn,
          cluster: cluster,
          launchType: serviceResponse.launchType,
          overrides: {
            taskRoleArn: registerResponse.taskDefinition.taskRoleArn,
            containerOverrides: [
              {
                name: registerResponse.taskDefinition.containerDefinitions[0].name,
                command: ["/bin/bash", "-c", preDeployCommand]
              }
            ]
          },
          networkConfiguration: networkConfig,
        }));
        if (runTaskResponse.failures && runTaskResponse.failures.length > 0) {
          const failure = runTaskResponse.failures[0];
          throw new Error(`Failure: ${failure.arn} is ${failure.reason}`);
        }
        core.info(`Waiting for pre-deploy task ${runTaskResponse.tasks[0].taskArn}...`)
        await waitUntilTasksStopped({client: ecs, maxDelay: 10, maxWaitTime: 600},{
          tasks: [runTaskResponse.tasks[0].taskArn],
          cluster: cluster
        });
        // const describeResponse = await ecs.send(new DescribeTasksCommand({
        //   tasks: [runTaskResponse.tasks[0].taskArn],
        //   cluster: cluster
        // }));
        // if (describeResponse.failures && describeResponse.failures.length > 0) {
        //   const failure = describeResponse.failures[0];
        //   throw new Error(`Failure: ${failure.arn} is ${failure.reason}`);
        // }
        // // Get log output from the task
        // const task = describeResponse.tasks[0];
        // const container = task.containers[0];
        // if (container.exitCode && container.exitCode !== 0) {
        //   throw new Error(`Pre-deploy task exited with code ${container.exitCode}`);
        // }
        // // get log messages
        // const logParams = {
        //   logGroupName: registerResponse.taskDefinition.containerDefinitions[0].logConfiguration.options['awslogs-group'],
        //   logStreamName: registerResponse.taskDefinition.containerDefinitions[0].logConfiguration.options['awslogs-stream-prefix'] + '/' + container.name + '/' + task.taskArn.split('/').pop(),
        //   startFromHead: true
        // }
        // if (registerResponse.taskDefinition.containerDefinitions[0].logConfiguration.options['awslogs-stream-prefix']){
        //   core.info(`Getting log events from CloudWatch...`+JSON.stringify(logParams, undefined, 4))
        //   core.info(`task...`+JSON.stringify(task, undefined, 4))
        //   const logEvents = await cloudwatch.send(new GetLogEventsCommand(logParams));
        //   core.info(`Pre-deploy task output: `);
        //   logEvents.events.forEach(event => {
        //     core.info(event.message);
        //   });
        // } else {
        //   core.info(`Can't watch the logs because there's no CloudWatch log group defined`);
        // }
      } else {
        core.info(`No pre-deploy command specified`);
      }

      if (!serviceResponse.deploymentController || !serviceResponse.deploymentController.type || serviceResponse.deploymentController.type === 'ECS') {
        // Service uses the 'ECS' deployment controller, so we can call UpdateService
        await updateEcsService(ecs, clusterName, service, taskDefArn, waitForService, waitForMinutes, forceNewDeployment);
      } else if (serviceResponse.deploymentController.type === 'CODE_DEPLOY') {
        // Service uses CodeDeploy, so we should start a CodeDeploy deployment
        await createCodeDeployDeployment(codedeploy, clusterName, service, taskDefArn, waitForService, waitForMinutes);
      } else {
        throw new Error(`Unsupported deployment controller: ${serviceResponse.deploymentController.type}`);
      }
    } else {
      core.debug('Service was not specified, no service updated');
    }
  }
  catch (error) {
    core.setFailed(error.message);
    core.debug(error.stack);
  }
}

module.exports = run;

/* istanbul ignore next */
if (require.main === require.cache[eval('__filename')]) {
  run();
}


/***/ }),

/***/ 87351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(22037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 42186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(87351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(22037));
const path = __importStar(__nccwpck_require__(71017));
const oidc_utils_1 = __nccwpck_require__(98041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(81327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(81327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(57147));
const os = __importStar(__nccwpck_require__(22037));
const uuid_1 = __nccwpck_require__(78974);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 98041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(96255);
const auth_1 = __nccwpck_require__(35526);
const core_1 = __nccwpck_require__(42186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(71017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 81327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(22037);
const fs_1 = __nccwpck_require__(57147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 78974:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(81595));

var _v2 = _interopRequireDefault(__nccwpck_require__(26993));

var _v3 = _interopRequireDefault(__nccwpck_require__(51472));

var _v4 = _interopRequireDefault(__nccwpck_require__(16217));

var _nil = _interopRequireDefault(__nccwpck_require__(32381));

var _version = _interopRequireDefault(__nccwpck_require__(40427));

var _validate = _interopRequireDefault(__nccwpck_require__(92609));

var _stringify = _interopRequireDefault(__nccwpck_require__(61458));

var _parse = _interopRequireDefault(__nccwpck_require__(26385));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 5842:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 32381:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 26385:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(92609));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 86230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 9784:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 38844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 61458:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(92609));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 81595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(9784));

var _stringify = _interopRequireDefault(__nccwpck_require__(61458));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 26993:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65920));

var _md = _interopRequireDefault(__nccwpck_require__(5842));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 65920:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(61458));

var _parse = _interopRequireDefault(__nccwpck_require__(26385));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 51472:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(9784));

var _stringify = _interopRequireDefault(__nccwpck_require__(61458));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 16217:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65920));

var _sha = _interopRequireDefault(__nccwpck_require__(38844));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 92609:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(86230));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 40427:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(92609));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 35526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 96255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(13685));
const https = __importStar(__nccwpck_require__(95687));
const pm = __importStar(__nccwpck_require__(19835));
const tunnel = __importStar(__nccwpck_require__(74294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 19835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 718:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWatchLogs = void 0;
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const AssociateKmsKeyCommand_1 = __nccwpck_require__(98966);
const CancelExportTaskCommand_1 = __nccwpck_require__(94135);
const CreateExportTaskCommand_1 = __nccwpck_require__(64780);
const CreateLogGroupCommand_1 = __nccwpck_require__(36692);
const CreateLogStreamCommand_1 = __nccwpck_require__(39112);
const DeleteDataProtectionPolicyCommand_1 = __nccwpck_require__(78304);
const DeleteDestinationCommand_1 = __nccwpck_require__(1746);
const DeleteLogGroupCommand_1 = __nccwpck_require__(94076);
const DeleteLogStreamCommand_1 = __nccwpck_require__(56715);
const DeleteMetricFilterCommand_1 = __nccwpck_require__(13593);
const DeleteQueryDefinitionCommand_1 = __nccwpck_require__(82469);
const DeleteResourcePolicyCommand_1 = __nccwpck_require__(48669);
const DeleteRetentionPolicyCommand_1 = __nccwpck_require__(2106);
const DeleteSubscriptionFilterCommand_1 = __nccwpck_require__(57275);
const DescribeDestinationsCommand_1 = __nccwpck_require__(94646);
const DescribeExportTasksCommand_1 = __nccwpck_require__(37619);
const DescribeLogGroupsCommand_1 = __nccwpck_require__(68706);
const DescribeLogStreamsCommand_1 = __nccwpck_require__(15229);
const DescribeMetricFiltersCommand_1 = __nccwpck_require__(51059);
const DescribeQueriesCommand_1 = __nccwpck_require__(87403);
const DescribeQueryDefinitionsCommand_1 = __nccwpck_require__(44041);
const DescribeResourcePoliciesCommand_1 = __nccwpck_require__(68090);
const DescribeSubscriptionFiltersCommand_1 = __nccwpck_require__(69977);
const DisassociateKmsKeyCommand_1 = __nccwpck_require__(81790);
const FilterLogEventsCommand_1 = __nccwpck_require__(89045);
const GetDataProtectionPolicyCommand_1 = __nccwpck_require__(47496);
const GetLogEventsCommand_1 = __nccwpck_require__(43771);
const GetLogGroupFieldsCommand_1 = __nccwpck_require__(88807);
const GetLogRecordCommand_1 = __nccwpck_require__(35628);
const GetQueryResultsCommand_1 = __nccwpck_require__(15678);
const ListTagsForResourceCommand_1 = __nccwpck_require__(50556);
const ListTagsLogGroupCommand_1 = __nccwpck_require__(84068);
const PutDataProtectionPolicyCommand_1 = __nccwpck_require__(11051);
const PutDestinationCommand_1 = __nccwpck_require__(12193);
const PutDestinationPolicyCommand_1 = __nccwpck_require__(95531);
const PutLogEventsCommand_1 = __nccwpck_require__(31261);
const PutMetricFilterCommand_1 = __nccwpck_require__(57664);
const PutQueryDefinitionCommand_1 = __nccwpck_require__(33440);
const PutResourcePolicyCommand_1 = __nccwpck_require__(88152);
const PutRetentionPolicyCommand_1 = __nccwpck_require__(69827);
const PutSubscriptionFilterCommand_1 = __nccwpck_require__(10727);
const StartQueryCommand_1 = __nccwpck_require__(39727);
const StopQueryCommand_1 = __nccwpck_require__(4170);
const TagLogGroupCommand_1 = __nccwpck_require__(29106);
const TagResourceCommand_1 = __nccwpck_require__(16357);
const TestMetricFilterCommand_1 = __nccwpck_require__(46271);
const UntagLogGroupCommand_1 = __nccwpck_require__(11043);
const UntagResourceCommand_1 = __nccwpck_require__(58237);
class CloudWatchLogs extends CloudWatchLogsClient_1.CloudWatchLogsClient {
    associateKmsKey(args, optionsOrCb, cb) {
        const command = new AssociateKmsKeyCommand_1.AssociateKmsKeyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    cancelExportTask(args, optionsOrCb, cb) {
        const command = new CancelExportTaskCommand_1.CancelExportTaskCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createExportTask(args, optionsOrCb, cb) {
        const command = new CreateExportTaskCommand_1.CreateExportTaskCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createLogGroup(args, optionsOrCb, cb) {
        const command = new CreateLogGroupCommand_1.CreateLogGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createLogStream(args, optionsOrCb, cb) {
        const command = new CreateLogStreamCommand_1.CreateLogStreamCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteDataProtectionPolicy(args, optionsOrCb, cb) {
        const command = new DeleteDataProtectionPolicyCommand_1.DeleteDataProtectionPolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteDestination(args, optionsOrCb, cb) {
        const command = new DeleteDestinationCommand_1.DeleteDestinationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteLogGroup(args, optionsOrCb, cb) {
        const command = new DeleteLogGroupCommand_1.DeleteLogGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteLogStream(args, optionsOrCb, cb) {
        const command = new DeleteLogStreamCommand_1.DeleteLogStreamCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteMetricFilter(args, optionsOrCb, cb) {
        const command = new DeleteMetricFilterCommand_1.DeleteMetricFilterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteQueryDefinition(args, optionsOrCb, cb) {
        const command = new DeleteQueryDefinitionCommand_1.DeleteQueryDefinitionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteResourcePolicy(args, optionsOrCb, cb) {
        const command = new DeleteResourcePolicyCommand_1.DeleteResourcePolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteRetentionPolicy(args, optionsOrCb, cb) {
        const command = new DeleteRetentionPolicyCommand_1.DeleteRetentionPolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteSubscriptionFilter(args, optionsOrCb, cb) {
        const command = new DeleteSubscriptionFilterCommand_1.DeleteSubscriptionFilterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeDestinations(args, optionsOrCb, cb) {
        const command = new DescribeDestinationsCommand_1.DescribeDestinationsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeExportTasks(args, optionsOrCb, cb) {
        const command = new DescribeExportTasksCommand_1.DescribeExportTasksCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeLogGroups(args, optionsOrCb, cb) {
        const command = new DescribeLogGroupsCommand_1.DescribeLogGroupsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeLogStreams(args, optionsOrCb, cb) {
        const command = new DescribeLogStreamsCommand_1.DescribeLogStreamsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeMetricFilters(args, optionsOrCb, cb) {
        const command = new DescribeMetricFiltersCommand_1.DescribeMetricFiltersCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeQueries(args, optionsOrCb, cb) {
        const command = new DescribeQueriesCommand_1.DescribeQueriesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeQueryDefinitions(args, optionsOrCb, cb) {
        const command = new DescribeQueryDefinitionsCommand_1.DescribeQueryDefinitionsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeResourcePolicies(args, optionsOrCb, cb) {
        const command = new DescribeResourcePoliciesCommand_1.DescribeResourcePoliciesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeSubscriptionFilters(args, optionsOrCb, cb) {
        const command = new DescribeSubscriptionFiltersCommand_1.DescribeSubscriptionFiltersCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    disassociateKmsKey(args, optionsOrCb, cb) {
        const command = new DisassociateKmsKeyCommand_1.DisassociateKmsKeyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    filterLogEvents(args, optionsOrCb, cb) {
        const command = new FilterLogEventsCommand_1.FilterLogEventsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getDataProtectionPolicy(args, optionsOrCb, cb) {
        const command = new GetDataProtectionPolicyCommand_1.GetDataProtectionPolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getLogEvents(args, optionsOrCb, cb) {
        const command = new GetLogEventsCommand_1.GetLogEventsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getLogGroupFields(args, optionsOrCb, cb) {
        const command = new GetLogGroupFieldsCommand_1.GetLogGroupFieldsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getLogRecord(args, optionsOrCb, cb) {
        const command = new GetLogRecordCommand_1.GetLogRecordCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getQueryResults(args, optionsOrCb, cb) {
        const command = new GetQueryResultsCommand_1.GetQueryResultsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listTagsForResource(args, optionsOrCb, cb) {
        const command = new ListTagsForResourceCommand_1.ListTagsForResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listTagsLogGroup(args, optionsOrCb, cb) {
        const command = new ListTagsLogGroupCommand_1.ListTagsLogGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putDataProtectionPolicy(args, optionsOrCb, cb) {
        const command = new PutDataProtectionPolicyCommand_1.PutDataProtectionPolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putDestination(args, optionsOrCb, cb) {
        const command = new PutDestinationCommand_1.PutDestinationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putDestinationPolicy(args, optionsOrCb, cb) {
        const command = new PutDestinationPolicyCommand_1.PutDestinationPolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putLogEvents(args, optionsOrCb, cb) {
        const command = new PutLogEventsCommand_1.PutLogEventsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putMetricFilter(args, optionsOrCb, cb) {
        const command = new PutMetricFilterCommand_1.PutMetricFilterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putQueryDefinition(args, optionsOrCb, cb) {
        const command = new PutQueryDefinitionCommand_1.PutQueryDefinitionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putResourcePolicy(args, optionsOrCb, cb) {
        const command = new PutResourcePolicyCommand_1.PutResourcePolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putRetentionPolicy(args, optionsOrCb, cb) {
        const command = new PutRetentionPolicyCommand_1.PutRetentionPolicyCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putSubscriptionFilter(args, optionsOrCb, cb) {
        const command = new PutSubscriptionFilterCommand_1.PutSubscriptionFilterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    startQuery(args, optionsOrCb, cb) {
        const command = new StartQueryCommand_1.StartQueryCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    stopQuery(args, optionsOrCb, cb) {
        const command = new StopQueryCommand_1.StopQueryCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    tagLogGroup(args, optionsOrCb, cb) {
        const command = new TagLogGroupCommand_1.TagLogGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    tagResource(args, optionsOrCb, cb) {
        const command = new TagResourceCommand_1.TagResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    testMetricFilter(args, optionsOrCb, cb) {
        const command = new TestMetricFilterCommand_1.TestMetricFilterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    untagLogGroup(args, optionsOrCb, cb) {
        const command = new UntagLogGroupCommand_1.UntagLogGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    untagResource(args, optionsOrCb, cb) {
        const command = new UntagResourceCommand_1.UntagResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
}
exports.CloudWatchLogs = CloudWatchLogs;


/***/ }),

/***/ 17844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWatchLogsClient = void 0;
const config_resolver_1 = __nccwpck_require__(56153);
const middleware_content_length_1 = __nccwpck_require__(42245);
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_retry_1 = __nccwpck_require__(96064);
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const smithy_client_1 = __nccwpck_require__(4963);
const EndpointParameters_1 = __nccwpck_require__(76111);
const runtimeConfig_1 = __nccwpck_require__(29879);
class CloudWatchLogsClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.CloudWatchLogsClient = CloudWatchLogsClient;


/***/ }),

/***/ 98966:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssociateKmsKeyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class AssociateKmsKeyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssociateKmsKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "AssociateKmsKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssociateKmsKeyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1AssociateKmsKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1AssociateKmsKeyCommand)(output, context);
    }
}
exports.AssociateKmsKeyCommand = AssociateKmsKeyCommand;


/***/ }),

/***/ 94135:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancelExportTaskCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class CancelExportTaskCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CancelExportTaskCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "CancelExportTaskCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CancelExportTaskRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CancelExportTaskCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CancelExportTaskCommand)(output, context);
    }
}
exports.CancelExportTaskCommand = CancelExportTaskCommand;


/***/ }),

/***/ 64780:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateExportTaskCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class CreateExportTaskCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateExportTaskCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "CreateExportTaskCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateExportTaskRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateExportTaskResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateExportTaskCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateExportTaskCommand)(output, context);
    }
}
exports.CreateExportTaskCommand = CreateExportTaskCommand;


/***/ }),

/***/ 36692:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateLogGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class CreateLogGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateLogGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "CreateLogGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateLogGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateLogGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateLogGroupCommand)(output, context);
    }
}
exports.CreateLogGroupCommand = CreateLogGroupCommand;


/***/ }),

/***/ 39112:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateLogStreamCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class CreateLogStreamCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateLogStreamCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "CreateLogStreamCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateLogStreamRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateLogStreamCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateLogStreamCommand)(output, context);
    }
}
exports.CreateLogStreamCommand = CreateLogStreamCommand;


/***/ }),

/***/ 78304:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDataProtectionPolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteDataProtectionPolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteDataProtectionPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteDataProtectionPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteDataProtectionPolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteDataProtectionPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteDataProtectionPolicyCommand)(output, context);
    }
}
exports.DeleteDataProtectionPolicyCommand = DeleteDataProtectionPolicyCommand;


/***/ }),

/***/ 1746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDestinationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteDestinationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteDestinationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteDestinationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteDestinationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteDestinationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteDestinationCommand)(output, context);
    }
}
exports.DeleteDestinationCommand = DeleteDestinationCommand;


/***/ }),

/***/ 94076:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteLogGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteLogGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteLogGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteLogGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteLogGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteLogGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteLogGroupCommand)(output, context);
    }
}
exports.DeleteLogGroupCommand = DeleteLogGroupCommand;


/***/ }),

/***/ 56715:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteLogStreamCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteLogStreamCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteLogStreamCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteLogStreamCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteLogStreamRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteLogStreamCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteLogStreamCommand)(output, context);
    }
}
exports.DeleteLogStreamCommand = DeleteLogStreamCommand;


/***/ }),

/***/ 13593:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteMetricFilterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteMetricFilterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteMetricFilterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteMetricFilterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteMetricFilterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteMetricFilterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteMetricFilterCommand)(output, context);
    }
}
exports.DeleteMetricFilterCommand = DeleteMetricFilterCommand;


/***/ }),

/***/ 82469:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteQueryDefinitionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteQueryDefinitionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteQueryDefinitionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteQueryDefinitionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteQueryDefinitionRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteQueryDefinitionResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteQueryDefinitionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteQueryDefinitionCommand)(output, context);
    }
}
exports.DeleteQueryDefinitionCommand = DeleteQueryDefinitionCommand;


/***/ }),

/***/ 48669:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteResourcePolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteResourcePolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteResourcePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteResourcePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteResourcePolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteResourcePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteResourcePolicyCommand)(output, context);
    }
}
exports.DeleteResourcePolicyCommand = DeleteResourcePolicyCommand;


/***/ }),

/***/ 2106:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteRetentionPolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteRetentionPolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteRetentionPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteRetentionPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteRetentionPolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteRetentionPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteRetentionPolicyCommand)(output, context);
    }
}
exports.DeleteRetentionPolicyCommand = DeleteRetentionPolicyCommand;


/***/ }),

/***/ 57275:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteSubscriptionFilterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DeleteSubscriptionFilterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteSubscriptionFilterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DeleteSubscriptionFilterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteSubscriptionFilterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteSubscriptionFilterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteSubscriptionFilterCommand)(output, context);
    }
}
exports.DeleteSubscriptionFilterCommand = DeleteSubscriptionFilterCommand;


/***/ }),

/***/ 94646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeDestinationsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeDestinationsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeDestinationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeDestinationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeDestinationsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeDestinationsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeDestinationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeDestinationsCommand)(output, context);
    }
}
exports.DescribeDestinationsCommand = DescribeDestinationsCommand;


/***/ }),

/***/ 37619:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeExportTasksCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeExportTasksCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeExportTasksCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeExportTasksCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeExportTasksRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeExportTasksResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeExportTasksCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeExportTasksCommand)(output, context);
    }
}
exports.DescribeExportTasksCommand = DescribeExportTasksCommand;


/***/ }),

/***/ 68706:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeLogGroupsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeLogGroupsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeLogGroupsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeLogGroupsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeLogGroupsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeLogGroupsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeLogGroupsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeLogGroupsCommand)(output, context);
    }
}
exports.DescribeLogGroupsCommand = DescribeLogGroupsCommand;


/***/ }),

/***/ 15229:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeLogStreamsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeLogStreamsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeLogStreamsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeLogStreamsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeLogStreamsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeLogStreamsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeLogStreamsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeLogStreamsCommand)(output, context);
    }
}
exports.DescribeLogStreamsCommand = DescribeLogStreamsCommand;


/***/ }),

/***/ 51059:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeMetricFiltersCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeMetricFiltersCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeMetricFiltersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeMetricFiltersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeMetricFiltersRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeMetricFiltersResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeMetricFiltersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeMetricFiltersCommand)(output, context);
    }
}
exports.DescribeMetricFiltersCommand = DescribeMetricFiltersCommand;


/***/ }),

/***/ 87403:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeQueriesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeQueriesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeQueriesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeQueriesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeQueriesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeQueriesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeQueriesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeQueriesCommand)(output, context);
    }
}
exports.DescribeQueriesCommand = DescribeQueriesCommand;


/***/ }),

/***/ 44041:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeQueryDefinitionsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeQueryDefinitionsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeQueryDefinitionsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeQueryDefinitionsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeQueryDefinitionsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeQueryDefinitionsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeQueryDefinitionsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeQueryDefinitionsCommand)(output, context);
    }
}
exports.DescribeQueryDefinitionsCommand = DescribeQueryDefinitionsCommand;


/***/ }),

/***/ 68090:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeResourcePoliciesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeResourcePoliciesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeResourcePoliciesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeResourcePoliciesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeResourcePoliciesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeResourcePoliciesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeResourcePoliciesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeResourcePoliciesCommand)(output, context);
    }
}
exports.DescribeResourcePoliciesCommand = DescribeResourcePoliciesCommand;


/***/ }),

/***/ 69977:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeSubscriptionFiltersCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DescribeSubscriptionFiltersCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeSubscriptionFiltersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DescribeSubscriptionFiltersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeSubscriptionFiltersRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeSubscriptionFiltersResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeSubscriptionFiltersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeSubscriptionFiltersCommand)(output, context);
    }
}
exports.DescribeSubscriptionFiltersCommand = DescribeSubscriptionFiltersCommand;


/***/ }),

/***/ 81790:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisassociateKmsKeyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class DisassociateKmsKeyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DisassociateKmsKeyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "DisassociateKmsKeyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DisassociateKmsKeyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DisassociateKmsKeyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DisassociateKmsKeyCommand)(output, context);
    }
}
exports.DisassociateKmsKeyCommand = DisassociateKmsKeyCommand;


/***/ }),

/***/ 89045:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterLogEventsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class FilterLogEventsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, FilterLogEventsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "FilterLogEventsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.FilterLogEventsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.FilterLogEventsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1FilterLogEventsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1FilterLogEventsCommand)(output, context);
    }
}
exports.FilterLogEventsCommand = FilterLogEventsCommand;


/***/ }),

/***/ 47496:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDataProtectionPolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class GetDataProtectionPolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetDataProtectionPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "GetDataProtectionPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetDataProtectionPolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetDataProtectionPolicyResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetDataProtectionPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetDataProtectionPolicyCommand)(output, context);
    }
}
exports.GetDataProtectionPolicyCommand = GetDataProtectionPolicyCommand;


/***/ }),

/***/ 43771:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetLogEventsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class GetLogEventsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetLogEventsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "GetLogEventsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetLogEventsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetLogEventsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetLogEventsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetLogEventsCommand)(output, context);
    }
}
exports.GetLogEventsCommand = GetLogEventsCommand;


/***/ }),

/***/ 88807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetLogGroupFieldsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class GetLogGroupFieldsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetLogGroupFieldsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "GetLogGroupFieldsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetLogGroupFieldsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetLogGroupFieldsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetLogGroupFieldsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetLogGroupFieldsCommand)(output, context);
    }
}
exports.GetLogGroupFieldsCommand = GetLogGroupFieldsCommand;


/***/ }),

/***/ 35628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetLogRecordCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class GetLogRecordCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetLogRecordCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "GetLogRecordCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetLogRecordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetLogRecordResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetLogRecordCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetLogRecordCommand)(output, context);
    }
}
exports.GetLogRecordCommand = GetLogRecordCommand;


/***/ }),

/***/ 15678:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetQueryResultsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class GetQueryResultsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetQueryResultsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "GetQueryResultsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetQueryResultsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetQueryResultsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetQueryResultsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetQueryResultsCommand)(output, context);
    }
}
exports.GetQueryResultsCommand = GetQueryResultsCommand;


/***/ }),

/***/ 50556:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTagsForResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class ListTagsForResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTagsForResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "ListTagsForResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListTagsForResourceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListTagsForResourceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListTagsForResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListTagsForResourceCommand)(output, context);
    }
}
exports.ListTagsForResourceCommand = ListTagsForResourceCommand;


/***/ }),

/***/ 84068:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTagsLogGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class ListTagsLogGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTagsLogGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "ListTagsLogGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListTagsLogGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListTagsLogGroupResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListTagsLogGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListTagsLogGroupCommand)(output, context);
    }
}
exports.ListTagsLogGroupCommand = ListTagsLogGroupCommand;


/***/ }),

/***/ 11051:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutDataProtectionPolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutDataProtectionPolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutDataProtectionPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutDataProtectionPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutDataProtectionPolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutDataProtectionPolicyResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutDataProtectionPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutDataProtectionPolicyCommand)(output, context);
    }
}
exports.PutDataProtectionPolicyCommand = PutDataProtectionPolicyCommand;


/***/ }),

/***/ 12193:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutDestinationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutDestinationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutDestinationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutDestinationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutDestinationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutDestinationResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutDestinationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutDestinationCommand)(output, context);
    }
}
exports.PutDestinationCommand = PutDestinationCommand;


/***/ }),

/***/ 95531:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutDestinationPolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutDestinationPolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutDestinationPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutDestinationPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutDestinationPolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutDestinationPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutDestinationPolicyCommand)(output, context);
    }
}
exports.PutDestinationPolicyCommand = PutDestinationPolicyCommand;


/***/ }),

/***/ 31261:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutLogEventsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutLogEventsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutLogEventsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutLogEventsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutLogEventsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutLogEventsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutLogEventsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutLogEventsCommand)(output, context);
    }
}
exports.PutLogEventsCommand = PutLogEventsCommand;


/***/ }),

/***/ 57664:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutMetricFilterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutMetricFilterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutMetricFilterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutMetricFilterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutMetricFilterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutMetricFilterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutMetricFilterCommand)(output, context);
    }
}
exports.PutMetricFilterCommand = PutMetricFilterCommand;


/***/ }),

/***/ 33440:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutQueryDefinitionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutQueryDefinitionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutQueryDefinitionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutQueryDefinitionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutQueryDefinitionRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutQueryDefinitionResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutQueryDefinitionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutQueryDefinitionCommand)(output, context);
    }
}
exports.PutQueryDefinitionCommand = PutQueryDefinitionCommand;


/***/ }),

/***/ 88152:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutResourcePolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutResourcePolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutResourcePolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutResourcePolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutResourcePolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutResourcePolicyResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutResourcePolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutResourcePolicyCommand)(output, context);
    }
}
exports.PutResourcePolicyCommand = PutResourcePolicyCommand;


/***/ }),

/***/ 69827:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutRetentionPolicyCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutRetentionPolicyCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutRetentionPolicyCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutRetentionPolicyCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutRetentionPolicyRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutRetentionPolicyCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutRetentionPolicyCommand)(output, context);
    }
}
exports.PutRetentionPolicyCommand = PutRetentionPolicyCommand;


/***/ }),

/***/ 10727:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutSubscriptionFilterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class PutSubscriptionFilterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutSubscriptionFilterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "PutSubscriptionFilterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutSubscriptionFilterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutSubscriptionFilterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutSubscriptionFilterCommand)(output, context);
    }
}
exports.PutSubscriptionFilterCommand = PutSubscriptionFilterCommand;


/***/ }),

/***/ 39727:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StartQueryCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class StartQueryCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StartQueryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "StartQueryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.StartQueryRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.StartQueryResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1StartQueryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1StartQueryCommand)(output, context);
    }
}
exports.StartQueryCommand = StartQueryCommand;


/***/ }),

/***/ 4170:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StopQueryCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class StopQueryCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StopQueryCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "StopQueryCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.StopQueryRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.StopQueryResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1StopQueryCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1StopQueryCommand)(output, context);
    }
}
exports.StopQueryCommand = StopQueryCommand;


/***/ }),

/***/ 29106:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagLogGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class TagLogGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagLogGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "TagLogGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.TagLogGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1TagLogGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1TagLogGroupCommand)(output, context);
    }
}
exports.TagLogGroupCommand = TagLogGroupCommand;


/***/ }),

/***/ 16357:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class TagResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "TagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.TagResourceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1TagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1TagResourceCommand)(output, context);
    }
}
exports.TagResourceCommand = TagResourceCommand;


/***/ }),

/***/ 46271:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestMetricFilterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class TestMetricFilterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TestMetricFilterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "TestMetricFilterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.TestMetricFilterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.TestMetricFilterResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1TestMetricFilterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1TestMetricFilterCommand)(output, context);
    }
}
exports.TestMetricFilterCommand = TestMetricFilterCommand;


/***/ }),

/***/ 11043:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagLogGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class UntagLogGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagLogGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "UntagLogGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UntagLogGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UntagLogGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UntagLogGroupCommand)(output, context);
    }
}
exports.UntagLogGroupCommand = UntagLogGroupCommand;


/***/ }),

/***/ 58237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(99831);
const Aws_json1_1_1 = __nccwpck_require__(97108);
class UntagResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CloudWatchLogsClient";
        const commandName = "UntagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UntagResourceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UntagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UntagResourceCommand)(output, context);
    }
}
exports.UntagResourceCommand = UntagResourceCommand;


/***/ }),

/***/ 3732:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(98966), exports);
tslib_1.__exportStar(__nccwpck_require__(94135), exports);
tslib_1.__exportStar(__nccwpck_require__(64780), exports);
tslib_1.__exportStar(__nccwpck_require__(36692), exports);
tslib_1.__exportStar(__nccwpck_require__(39112), exports);
tslib_1.__exportStar(__nccwpck_require__(78304), exports);
tslib_1.__exportStar(__nccwpck_require__(1746), exports);
tslib_1.__exportStar(__nccwpck_require__(94076), exports);
tslib_1.__exportStar(__nccwpck_require__(56715), exports);
tslib_1.__exportStar(__nccwpck_require__(13593), exports);
tslib_1.__exportStar(__nccwpck_require__(82469), exports);
tslib_1.__exportStar(__nccwpck_require__(48669), exports);
tslib_1.__exportStar(__nccwpck_require__(2106), exports);
tslib_1.__exportStar(__nccwpck_require__(57275), exports);
tslib_1.__exportStar(__nccwpck_require__(94646), exports);
tslib_1.__exportStar(__nccwpck_require__(37619), exports);
tslib_1.__exportStar(__nccwpck_require__(68706), exports);
tslib_1.__exportStar(__nccwpck_require__(15229), exports);
tslib_1.__exportStar(__nccwpck_require__(51059), exports);
tslib_1.__exportStar(__nccwpck_require__(87403), exports);
tslib_1.__exportStar(__nccwpck_require__(44041), exports);
tslib_1.__exportStar(__nccwpck_require__(68090), exports);
tslib_1.__exportStar(__nccwpck_require__(69977), exports);
tslib_1.__exportStar(__nccwpck_require__(81790), exports);
tslib_1.__exportStar(__nccwpck_require__(89045), exports);
tslib_1.__exportStar(__nccwpck_require__(47496), exports);
tslib_1.__exportStar(__nccwpck_require__(43771), exports);
tslib_1.__exportStar(__nccwpck_require__(88807), exports);
tslib_1.__exportStar(__nccwpck_require__(35628), exports);
tslib_1.__exportStar(__nccwpck_require__(15678), exports);
tslib_1.__exportStar(__nccwpck_require__(50556), exports);
tslib_1.__exportStar(__nccwpck_require__(84068), exports);
tslib_1.__exportStar(__nccwpck_require__(11051), exports);
tslib_1.__exportStar(__nccwpck_require__(12193), exports);
tslib_1.__exportStar(__nccwpck_require__(95531), exports);
tslib_1.__exportStar(__nccwpck_require__(31261), exports);
tslib_1.__exportStar(__nccwpck_require__(57664), exports);
tslib_1.__exportStar(__nccwpck_require__(33440), exports);
tslib_1.__exportStar(__nccwpck_require__(88152), exports);
tslib_1.__exportStar(__nccwpck_require__(69827), exports);
tslib_1.__exportStar(__nccwpck_require__(10727), exports);
tslib_1.__exportStar(__nccwpck_require__(39727), exports);
tslib_1.__exportStar(__nccwpck_require__(4170), exports);
tslib_1.__exportStar(__nccwpck_require__(29106), exports);
tslib_1.__exportStar(__nccwpck_require__(16357), exports);
tslib_1.__exportStar(__nccwpck_require__(46271), exports);
tslib_1.__exportStar(__nccwpck_require__(11043), exports);
tslib_1.__exportStar(__nccwpck_require__(58237), exports);


/***/ }),

/***/ 76111:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "logs",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 49488:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(82237);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 82237:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const s = "fn", t = "argv", u = "ref";
const a = true, b = false, c = "String", d = "PartitionResult", e = "tree", f = "error", g = "endpoint", h = "stringEquals", i = { "required": true, "default": false, "type": "Boolean" }, j = { [u]: "Region" }, k = { [u]: "Endpoint" }, l = { [s]: "booleanEquals", [t]: [{ [u]: "UseFIPS" }, true] }, m = { [s]: "booleanEquals", [t]: [{ [u]: "UseDualStack" }, true] }, n = {}, o = { [s]: "booleanEquals", [t]: [true, { [s]: "getAttr", [t]: [{ [u]: d }, "supportsFIPS"] }] }, p = { [s]: "booleanEquals", [t]: [true, { [s]: "getAttr", [t]: [{ [u]: d }, "supportsDualStack"] }] }, q = [l], r = [m];
const _data = { version: "1.0", parameters: { Region: { required: a, type: c }, UseDualStack: i, UseFIPS: i, Endpoint: { required: b, type: c } }, rules: [{ conditions: [{ [s]: "aws.partition", [t]: [j], assign: d }], type: e, rules: [{ conditions: [{ [s]: "isSet", [t]: [k] }], type: e, rules: [{ conditions: q, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: f }, { type: e, rules: [{ conditions: r, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: f }, { endpoint: { url: k, properties: n, headers: n }, type: g }] }] }, { conditions: [l, m], type: e, rules: [{ conditions: [o, p], type: e, rules: [{ endpoint: { url: "https://logs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: g }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: f }] }, { conditions: q, type: e, rules: [{ conditions: [o], type: e, rules: [{ type: e, rules: [{ conditions: [{ [s]: h, [t]: [j, "us-gov-east-1"] }], endpoint: { url: "https://logs.us-gov-east-1.amazonaws.com", properties: n, headers: n }, type: g }, { conditions: [{ [s]: h, [t]: [j, "us-gov-west-1"] }], endpoint: { url: "https://logs.us-gov-west-1.amazonaws.com", properties: n, headers: n }, type: g }, { endpoint: { url: "https://logs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: g }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: f }] }, { conditions: r, type: e, rules: [{ conditions: [p], type: e, rules: [{ endpoint: { url: "https://logs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: g }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: f }] }, { endpoint: { url: "https://logs.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: g }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 31573:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWatchLogsServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(718), exports);
tslib_1.__exportStar(__nccwpck_require__(17844), exports);
tslib_1.__exportStar(__nccwpck_require__(3732), exports);
tslib_1.__exportStar(__nccwpck_require__(83058), exports);
tslib_1.__exportStar(__nccwpck_require__(984), exports);
var CloudWatchLogsServiceException_1 = __nccwpck_require__(86548);
Object.defineProperty(exports, "CloudWatchLogsServiceException", ({ enumerable: true, get: function () { return CloudWatchLogsServiceException_1.CloudWatchLogsServiceException; } }));


/***/ }),

/***/ 86548:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudWatchLogsServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
class CloudWatchLogsServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, CloudWatchLogsServiceException.prototype);
    }
}
exports.CloudWatchLogsServiceException = CloudWatchLogsServiceException;


/***/ }),

/***/ 83058:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(99831), exports);


/***/ }),

/***/ 99831:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricTransformationFilterSensitiveLog = exports.DescribeMetricFiltersRequestFilterSensitiveLog = exports.DescribeLogStreamsResponseFilterSensitiveLog = exports.LogStreamFilterSensitiveLog = exports.DescribeLogStreamsRequestFilterSensitiveLog = exports.DescribeLogGroupsResponseFilterSensitiveLog = exports.LogGroupFilterSensitiveLog = exports.DescribeLogGroupsRequestFilterSensitiveLog = exports.DescribeExportTasksResponseFilterSensitiveLog = exports.ExportTaskFilterSensitiveLog = exports.ExportTaskStatusFilterSensitiveLog = exports.ExportTaskExecutionInfoFilterSensitiveLog = exports.DescribeExportTasksRequestFilterSensitiveLog = exports.DescribeDestinationsResponseFilterSensitiveLog = exports.DestinationFilterSensitiveLog = exports.DescribeDestinationsRequestFilterSensitiveLog = exports.DeleteSubscriptionFilterRequestFilterSensitiveLog = exports.DeleteRetentionPolicyRequestFilterSensitiveLog = exports.DeleteResourcePolicyRequestFilterSensitiveLog = exports.DeleteQueryDefinitionResponseFilterSensitiveLog = exports.DeleteQueryDefinitionRequestFilterSensitiveLog = exports.DeleteMetricFilterRequestFilterSensitiveLog = exports.DeleteLogStreamRequestFilterSensitiveLog = exports.DeleteLogGroupRequestFilterSensitiveLog = exports.DeleteDestinationRequestFilterSensitiveLog = exports.DeleteDataProtectionPolicyRequestFilterSensitiveLog = exports.CreateLogStreamRequestFilterSensitiveLog = exports.CreateLogGroupRequestFilterSensitiveLog = exports.CreateExportTaskResponseFilterSensitiveLog = exports.CreateExportTaskRequestFilterSensitiveLog = exports.CancelExportTaskRequestFilterSensitiveLog = exports.AssociateKmsKeyRequestFilterSensitiveLog = exports.TooManyTagsException = exports.MalformedQueryException = exports.UnrecognizedClientException = exports.InvalidSequenceTokenException = exports.Distribution = exports.QueryStatus = exports.StandardUnit = exports.OrderBy = exports.ExportTaskStatusCode = exports.DataProtectionStatus = exports.DataAlreadyAcceptedException = exports.ResourceAlreadyExistsException = exports.LimitExceededException = exports.InvalidOperationException = exports.ServiceUnavailableException = exports.ResourceNotFoundException = exports.OperationAbortedException = exports.InvalidParameterException = void 0;
exports.PutResourcePolicyRequestFilterSensitiveLog = exports.PutQueryDefinitionResponseFilterSensitiveLog = exports.PutQueryDefinitionRequestFilterSensitiveLog = exports.PutMetricFilterRequestFilterSensitiveLog = exports.PutLogEventsResponseFilterSensitiveLog = exports.RejectedLogEventsInfoFilterSensitiveLog = exports.PutLogEventsRequestFilterSensitiveLog = exports.PutDestinationPolicyRequestFilterSensitiveLog = exports.PutDestinationResponseFilterSensitiveLog = exports.PutDestinationRequestFilterSensitiveLog = exports.PutDataProtectionPolicyResponseFilterSensitiveLog = exports.PutDataProtectionPolicyRequestFilterSensitiveLog = exports.ListTagsLogGroupResponseFilterSensitiveLog = exports.ListTagsLogGroupRequestFilterSensitiveLog = exports.ListTagsForResourceResponseFilterSensitiveLog = exports.ListTagsForResourceRequestFilterSensitiveLog = exports.InputLogEventFilterSensitiveLog = exports.GetQueryResultsResponseFilterSensitiveLog = exports.QueryStatisticsFilterSensitiveLog = exports.ResultFieldFilterSensitiveLog = exports.GetQueryResultsRequestFilterSensitiveLog = exports.GetLogRecordResponseFilterSensitiveLog = exports.GetLogRecordRequestFilterSensitiveLog = exports.GetLogGroupFieldsResponseFilterSensitiveLog = exports.LogGroupFieldFilterSensitiveLog = exports.GetLogGroupFieldsRequestFilterSensitiveLog = exports.GetLogEventsResponseFilterSensitiveLog = exports.OutputLogEventFilterSensitiveLog = exports.GetLogEventsRequestFilterSensitiveLog = exports.GetDataProtectionPolicyResponseFilterSensitiveLog = exports.GetDataProtectionPolicyRequestFilterSensitiveLog = exports.FilterLogEventsResponseFilterSensitiveLog = exports.SearchedLogStreamFilterSensitiveLog = exports.FilterLogEventsRequestFilterSensitiveLog = exports.FilteredLogEventFilterSensitiveLog = exports.DisassociateKmsKeyRequestFilterSensitiveLog = exports.DescribeSubscriptionFiltersResponseFilterSensitiveLog = exports.SubscriptionFilterFilterSensitiveLog = exports.DescribeSubscriptionFiltersRequestFilterSensitiveLog = exports.DescribeResourcePoliciesResponseFilterSensitiveLog = exports.ResourcePolicyFilterSensitiveLog = exports.DescribeResourcePoliciesRequestFilterSensitiveLog = exports.DescribeQueryDefinitionsResponseFilterSensitiveLog = exports.QueryDefinitionFilterSensitiveLog = exports.DescribeQueryDefinitionsRequestFilterSensitiveLog = exports.DescribeQueriesResponseFilterSensitiveLog = exports.QueryInfoFilterSensitiveLog = exports.DescribeQueriesRequestFilterSensitiveLog = exports.DescribeMetricFiltersResponseFilterSensitiveLog = exports.MetricFilterFilterSensitiveLog = void 0;
exports.UntagResourceRequestFilterSensitiveLog = exports.UntagLogGroupRequestFilterSensitiveLog = exports.TestMetricFilterResponseFilterSensitiveLog = exports.MetricFilterMatchRecordFilterSensitiveLog = exports.TestMetricFilterRequestFilterSensitiveLog = exports.TagResourceRequestFilterSensitiveLog = exports.TagLogGroupRequestFilterSensitiveLog = exports.StopQueryResponseFilterSensitiveLog = exports.StopQueryRequestFilterSensitiveLog = exports.StartQueryResponseFilterSensitiveLog = exports.StartQueryRequestFilterSensitiveLog = exports.QueryCompileErrorFilterSensitiveLog = exports.QueryCompileErrorLocationFilterSensitiveLog = exports.PutSubscriptionFilterRequestFilterSensitiveLog = exports.PutRetentionPolicyRequestFilterSensitiveLog = exports.PutResourcePolicyResponseFilterSensitiveLog = void 0;
const CloudWatchLogsServiceException_1 = __nccwpck_require__(86548);
class InvalidParameterException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "InvalidParameterException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidParameterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidParameterException.prototype);
    }
}
exports.InvalidParameterException = InvalidParameterException;
class OperationAbortedException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "OperationAbortedException",
            $fault: "client",
            ...opts,
        });
        this.name = "OperationAbortedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, OperationAbortedException.prototype);
    }
}
exports.OperationAbortedException = OperationAbortedException;
class ResourceNotFoundException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class ServiceUnavailableException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "ServiceUnavailableException",
            $fault: "server",
            ...opts,
        });
        this.name = "ServiceUnavailableException";
        this.$fault = "server";
        Object.setPrototypeOf(this, ServiceUnavailableException.prototype);
    }
}
exports.ServiceUnavailableException = ServiceUnavailableException;
class InvalidOperationException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "InvalidOperationException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOperationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOperationException.prototype);
    }
}
exports.InvalidOperationException = InvalidOperationException;
class LimitExceededException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
}
exports.LimitExceededException = LimitExceededException;
class ResourceAlreadyExistsException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "ResourceAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceAlreadyExistsException.prototype);
    }
}
exports.ResourceAlreadyExistsException = ResourceAlreadyExistsException;
class DataAlreadyAcceptedException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "DataAlreadyAcceptedException",
            $fault: "client",
            ...opts,
        });
        this.name = "DataAlreadyAcceptedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DataAlreadyAcceptedException.prototype);
        this.expectedSequenceToken = opts.expectedSequenceToken;
    }
}
exports.DataAlreadyAcceptedException = DataAlreadyAcceptedException;
var DataProtectionStatus;
(function (DataProtectionStatus) {
    DataProtectionStatus["ACTIVATED"] = "ACTIVATED";
    DataProtectionStatus["ARCHIVED"] = "ARCHIVED";
    DataProtectionStatus["DELETED"] = "DELETED";
    DataProtectionStatus["DISABLED"] = "DISABLED";
})(DataProtectionStatus = exports.DataProtectionStatus || (exports.DataProtectionStatus = {}));
var ExportTaskStatusCode;
(function (ExportTaskStatusCode) {
    ExportTaskStatusCode["CANCELLED"] = "CANCELLED";
    ExportTaskStatusCode["COMPLETED"] = "COMPLETED";
    ExportTaskStatusCode["FAILED"] = "FAILED";
    ExportTaskStatusCode["PENDING"] = "PENDING";
    ExportTaskStatusCode["PENDING_CANCEL"] = "PENDING_CANCEL";
    ExportTaskStatusCode["RUNNING"] = "RUNNING";
})(ExportTaskStatusCode = exports.ExportTaskStatusCode || (exports.ExportTaskStatusCode = {}));
var OrderBy;
(function (OrderBy) {
    OrderBy["LastEventTime"] = "LastEventTime";
    OrderBy["LogStreamName"] = "LogStreamName";
})(OrderBy = exports.OrderBy || (exports.OrderBy = {}));
var StandardUnit;
(function (StandardUnit) {
    StandardUnit["Bits"] = "Bits";
    StandardUnit["BitsSecond"] = "Bits/Second";
    StandardUnit["Bytes"] = "Bytes";
    StandardUnit["BytesSecond"] = "Bytes/Second";
    StandardUnit["Count"] = "Count";
    StandardUnit["CountSecond"] = "Count/Second";
    StandardUnit["Gigabits"] = "Gigabits";
    StandardUnit["GigabitsSecond"] = "Gigabits/Second";
    StandardUnit["Gigabytes"] = "Gigabytes";
    StandardUnit["GigabytesSecond"] = "Gigabytes/Second";
    StandardUnit["Kilobits"] = "Kilobits";
    StandardUnit["KilobitsSecond"] = "Kilobits/Second";
    StandardUnit["Kilobytes"] = "Kilobytes";
    StandardUnit["KilobytesSecond"] = "Kilobytes/Second";
    StandardUnit["Megabits"] = "Megabits";
    StandardUnit["MegabitsSecond"] = "Megabits/Second";
    StandardUnit["Megabytes"] = "Megabytes";
    StandardUnit["MegabytesSecond"] = "Megabytes/Second";
    StandardUnit["Microseconds"] = "Microseconds";
    StandardUnit["Milliseconds"] = "Milliseconds";
    StandardUnit["None"] = "None";
    StandardUnit["Percent"] = "Percent";
    StandardUnit["Seconds"] = "Seconds";
    StandardUnit["Terabits"] = "Terabits";
    StandardUnit["TerabitsSecond"] = "Terabits/Second";
    StandardUnit["Terabytes"] = "Terabytes";
    StandardUnit["TerabytesSecond"] = "Terabytes/Second";
})(StandardUnit = exports.StandardUnit || (exports.StandardUnit = {}));
var QueryStatus;
(function (QueryStatus) {
    QueryStatus["Cancelled"] = "Cancelled";
    QueryStatus["Complete"] = "Complete";
    QueryStatus["Failed"] = "Failed";
    QueryStatus["Running"] = "Running";
    QueryStatus["Scheduled"] = "Scheduled";
    QueryStatus["Timeout"] = "Timeout";
    QueryStatus["Unknown"] = "Unknown";
})(QueryStatus = exports.QueryStatus || (exports.QueryStatus = {}));
var Distribution;
(function (Distribution) {
    Distribution["ByLogStream"] = "ByLogStream";
    Distribution["Random"] = "Random";
})(Distribution = exports.Distribution || (exports.Distribution = {}));
class InvalidSequenceTokenException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "InvalidSequenceTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidSequenceTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidSequenceTokenException.prototype);
        this.expectedSequenceToken = opts.expectedSequenceToken;
    }
}
exports.InvalidSequenceTokenException = InvalidSequenceTokenException;
class UnrecognizedClientException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "UnrecognizedClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnrecognizedClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnrecognizedClientException.prototype);
    }
}
exports.UnrecognizedClientException = UnrecognizedClientException;
class MalformedQueryException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "MalformedQueryException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedQueryException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedQueryException.prototype);
        this.queryCompileError = opts.queryCompileError;
    }
}
exports.MalformedQueryException = MalformedQueryException;
class TooManyTagsException extends CloudWatchLogsServiceException_1.CloudWatchLogsServiceException {
    constructor(opts) {
        super({
            name: "TooManyTagsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyTagsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyTagsException.prototype);
        this.resourceName = opts.resourceName;
    }
}
exports.TooManyTagsException = TooManyTagsException;
const AssociateKmsKeyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssociateKmsKeyRequestFilterSensitiveLog = AssociateKmsKeyRequestFilterSensitiveLog;
const CancelExportTaskRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CancelExportTaskRequestFilterSensitiveLog = CancelExportTaskRequestFilterSensitiveLog;
const CreateExportTaskRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateExportTaskRequestFilterSensitiveLog = CreateExportTaskRequestFilterSensitiveLog;
const CreateExportTaskResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateExportTaskResponseFilterSensitiveLog = CreateExportTaskResponseFilterSensitiveLog;
const CreateLogGroupRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateLogGroupRequestFilterSensitiveLog = CreateLogGroupRequestFilterSensitiveLog;
const CreateLogStreamRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateLogStreamRequestFilterSensitiveLog = CreateLogStreamRequestFilterSensitiveLog;
const DeleteDataProtectionPolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteDataProtectionPolicyRequestFilterSensitiveLog = DeleteDataProtectionPolicyRequestFilterSensitiveLog;
const DeleteDestinationRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteDestinationRequestFilterSensitiveLog = DeleteDestinationRequestFilterSensitiveLog;
const DeleteLogGroupRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteLogGroupRequestFilterSensitiveLog = DeleteLogGroupRequestFilterSensitiveLog;
const DeleteLogStreamRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteLogStreamRequestFilterSensitiveLog = DeleteLogStreamRequestFilterSensitiveLog;
const DeleteMetricFilterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteMetricFilterRequestFilterSensitiveLog = DeleteMetricFilterRequestFilterSensitiveLog;
const DeleteQueryDefinitionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteQueryDefinitionRequestFilterSensitiveLog = DeleteQueryDefinitionRequestFilterSensitiveLog;
const DeleteQueryDefinitionResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteQueryDefinitionResponseFilterSensitiveLog = DeleteQueryDefinitionResponseFilterSensitiveLog;
const DeleteResourcePolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteResourcePolicyRequestFilterSensitiveLog = DeleteResourcePolicyRequestFilterSensitiveLog;
const DeleteRetentionPolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteRetentionPolicyRequestFilterSensitiveLog = DeleteRetentionPolicyRequestFilterSensitiveLog;
const DeleteSubscriptionFilterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteSubscriptionFilterRequestFilterSensitiveLog = DeleteSubscriptionFilterRequestFilterSensitiveLog;
const DescribeDestinationsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeDestinationsRequestFilterSensitiveLog = DescribeDestinationsRequestFilterSensitiveLog;
const DestinationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DestinationFilterSensitiveLog = DestinationFilterSensitiveLog;
const DescribeDestinationsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeDestinationsResponseFilterSensitiveLog = DescribeDestinationsResponseFilterSensitiveLog;
const DescribeExportTasksRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeExportTasksRequestFilterSensitiveLog = DescribeExportTasksRequestFilterSensitiveLog;
const ExportTaskExecutionInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ExportTaskExecutionInfoFilterSensitiveLog = ExportTaskExecutionInfoFilterSensitiveLog;
const ExportTaskStatusFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ExportTaskStatusFilterSensitiveLog = ExportTaskStatusFilterSensitiveLog;
const ExportTaskFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ExportTaskFilterSensitiveLog = ExportTaskFilterSensitiveLog;
const DescribeExportTasksResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeExportTasksResponseFilterSensitiveLog = DescribeExportTasksResponseFilterSensitiveLog;
const DescribeLogGroupsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeLogGroupsRequestFilterSensitiveLog = DescribeLogGroupsRequestFilterSensitiveLog;
const LogGroupFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LogGroupFilterSensitiveLog = LogGroupFilterSensitiveLog;
const DescribeLogGroupsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeLogGroupsResponseFilterSensitiveLog = DescribeLogGroupsResponseFilterSensitiveLog;
const DescribeLogStreamsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeLogStreamsRequestFilterSensitiveLog = DescribeLogStreamsRequestFilterSensitiveLog;
const LogStreamFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LogStreamFilterSensitiveLog = LogStreamFilterSensitiveLog;
const DescribeLogStreamsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeLogStreamsResponseFilterSensitiveLog = DescribeLogStreamsResponseFilterSensitiveLog;
const DescribeMetricFiltersRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeMetricFiltersRequestFilterSensitiveLog = DescribeMetricFiltersRequestFilterSensitiveLog;
const MetricTransformationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.MetricTransformationFilterSensitiveLog = MetricTransformationFilterSensitiveLog;
const MetricFilterFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.MetricFilterFilterSensitiveLog = MetricFilterFilterSensitiveLog;
const DescribeMetricFiltersResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeMetricFiltersResponseFilterSensitiveLog = DescribeMetricFiltersResponseFilterSensitiveLog;
const DescribeQueriesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeQueriesRequestFilterSensitiveLog = DescribeQueriesRequestFilterSensitiveLog;
const QueryInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.QueryInfoFilterSensitiveLog = QueryInfoFilterSensitiveLog;
const DescribeQueriesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeQueriesResponseFilterSensitiveLog = DescribeQueriesResponseFilterSensitiveLog;
const DescribeQueryDefinitionsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeQueryDefinitionsRequestFilterSensitiveLog = DescribeQueryDefinitionsRequestFilterSensitiveLog;
const QueryDefinitionFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.QueryDefinitionFilterSensitiveLog = QueryDefinitionFilterSensitiveLog;
const DescribeQueryDefinitionsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeQueryDefinitionsResponseFilterSensitiveLog = DescribeQueryDefinitionsResponseFilterSensitiveLog;
const DescribeResourcePoliciesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeResourcePoliciesRequestFilterSensitiveLog = DescribeResourcePoliciesRequestFilterSensitiveLog;
const ResourcePolicyFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ResourcePolicyFilterSensitiveLog = ResourcePolicyFilterSensitiveLog;
const DescribeResourcePoliciesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeResourcePoliciesResponseFilterSensitiveLog = DescribeResourcePoliciesResponseFilterSensitiveLog;
const DescribeSubscriptionFiltersRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeSubscriptionFiltersRequestFilterSensitiveLog = DescribeSubscriptionFiltersRequestFilterSensitiveLog;
const SubscriptionFilterFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SubscriptionFilterFilterSensitiveLog = SubscriptionFilterFilterSensitiveLog;
const DescribeSubscriptionFiltersResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeSubscriptionFiltersResponseFilterSensitiveLog = DescribeSubscriptionFiltersResponseFilterSensitiveLog;
const DisassociateKmsKeyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DisassociateKmsKeyRequestFilterSensitiveLog = DisassociateKmsKeyRequestFilterSensitiveLog;
const FilteredLogEventFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FilteredLogEventFilterSensitiveLog = FilteredLogEventFilterSensitiveLog;
const FilterLogEventsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FilterLogEventsRequestFilterSensitiveLog = FilterLogEventsRequestFilterSensitiveLog;
const SearchedLogStreamFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SearchedLogStreamFilterSensitiveLog = SearchedLogStreamFilterSensitiveLog;
const FilterLogEventsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FilterLogEventsResponseFilterSensitiveLog = FilterLogEventsResponseFilterSensitiveLog;
const GetDataProtectionPolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDataProtectionPolicyRequestFilterSensitiveLog = GetDataProtectionPolicyRequestFilterSensitiveLog;
const GetDataProtectionPolicyResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDataProtectionPolicyResponseFilterSensitiveLog = GetDataProtectionPolicyResponseFilterSensitiveLog;
const GetLogEventsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetLogEventsRequestFilterSensitiveLog = GetLogEventsRequestFilterSensitiveLog;
const OutputLogEventFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.OutputLogEventFilterSensitiveLog = OutputLogEventFilterSensitiveLog;
const GetLogEventsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetLogEventsResponseFilterSensitiveLog = GetLogEventsResponseFilterSensitiveLog;
const GetLogGroupFieldsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetLogGroupFieldsRequestFilterSensitiveLog = GetLogGroupFieldsRequestFilterSensitiveLog;
const LogGroupFieldFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LogGroupFieldFilterSensitiveLog = LogGroupFieldFilterSensitiveLog;
const GetLogGroupFieldsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetLogGroupFieldsResponseFilterSensitiveLog = GetLogGroupFieldsResponseFilterSensitiveLog;
const GetLogRecordRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetLogRecordRequestFilterSensitiveLog = GetLogRecordRequestFilterSensitiveLog;
const GetLogRecordResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetLogRecordResponseFilterSensitiveLog = GetLogRecordResponseFilterSensitiveLog;
const GetQueryResultsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetQueryResultsRequestFilterSensitiveLog = GetQueryResultsRequestFilterSensitiveLog;
const ResultFieldFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ResultFieldFilterSensitiveLog = ResultFieldFilterSensitiveLog;
const QueryStatisticsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.QueryStatisticsFilterSensitiveLog = QueryStatisticsFilterSensitiveLog;
const GetQueryResultsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetQueryResultsResponseFilterSensitiveLog = GetQueryResultsResponseFilterSensitiveLog;
const InputLogEventFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.InputLogEventFilterSensitiveLog = InputLogEventFilterSensitiveLog;
const ListTagsForResourceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsForResourceRequestFilterSensitiveLog = ListTagsForResourceRequestFilterSensitiveLog;
const ListTagsForResourceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsForResourceResponseFilterSensitiveLog = ListTagsForResourceResponseFilterSensitiveLog;
const ListTagsLogGroupRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsLogGroupRequestFilterSensitiveLog = ListTagsLogGroupRequestFilterSensitiveLog;
const ListTagsLogGroupResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsLogGroupResponseFilterSensitiveLog = ListTagsLogGroupResponseFilterSensitiveLog;
const PutDataProtectionPolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutDataProtectionPolicyRequestFilterSensitiveLog = PutDataProtectionPolicyRequestFilterSensitiveLog;
const PutDataProtectionPolicyResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutDataProtectionPolicyResponseFilterSensitiveLog = PutDataProtectionPolicyResponseFilterSensitiveLog;
const PutDestinationRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutDestinationRequestFilterSensitiveLog = PutDestinationRequestFilterSensitiveLog;
const PutDestinationResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutDestinationResponseFilterSensitiveLog = PutDestinationResponseFilterSensitiveLog;
const PutDestinationPolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutDestinationPolicyRequestFilterSensitiveLog = PutDestinationPolicyRequestFilterSensitiveLog;
const PutLogEventsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutLogEventsRequestFilterSensitiveLog = PutLogEventsRequestFilterSensitiveLog;
const RejectedLogEventsInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RejectedLogEventsInfoFilterSensitiveLog = RejectedLogEventsInfoFilterSensitiveLog;
const PutLogEventsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutLogEventsResponseFilterSensitiveLog = PutLogEventsResponseFilterSensitiveLog;
const PutMetricFilterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutMetricFilterRequestFilterSensitiveLog = PutMetricFilterRequestFilterSensitiveLog;
const PutQueryDefinitionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutQueryDefinitionRequestFilterSensitiveLog = PutQueryDefinitionRequestFilterSensitiveLog;
const PutQueryDefinitionResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutQueryDefinitionResponseFilterSensitiveLog = PutQueryDefinitionResponseFilterSensitiveLog;
const PutResourcePolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutResourcePolicyRequestFilterSensitiveLog = PutResourcePolicyRequestFilterSensitiveLog;
const PutResourcePolicyResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutResourcePolicyResponseFilterSensitiveLog = PutResourcePolicyResponseFilterSensitiveLog;
const PutRetentionPolicyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutRetentionPolicyRequestFilterSensitiveLog = PutRetentionPolicyRequestFilterSensitiveLog;
const PutSubscriptionFilterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutSubscriptionFilterRequestFilterSensitiveLog = PutSubscriptionFilterRequestFilterSensitiveLog;
const QueryCompileErrorLocationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.QueryCompileErrorLocationFilterSensitiveLog = QueryCompileErrorLocationFilterSensitiveLog;
const QueryCompileErrorFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.QueryCompileErrorFilterSensitiveLog = QueryCompileErrorFilterSensitiveLog;
const StartQueryRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StartQueryRequestFilterSensitiveLog = StartQueryRequestFilterSensitiveLog;
const StartQueryResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StartQueryResponseFilterSensitiveLog = StartQueryResponseFilterSensitiveLog;
const StopQueryRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StopQueryRequestFilterSensitiveLog = StopQueryRequestFilterSensitiveLog;
const StopQueryResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StopQueryResponseFilterSensitiveLog = StopQueryResponseFilterSensitiveLog;
const TagLogGroupRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagLogGroupRequestFilterSensitiveLog = TagLogGroupRequestFilterSensitiveLog;
const TagResourceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagResourceRequestFilterSensitiveLog = TagResourceRequestFilterSensitiveLog;
const TestMetricFilterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TestMetricFilterRequestFilterSensitiveLog = TestMetricFilterRequestFilterSensitiveLog;
const MetricFilterMatchRecordFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.MetricFilterMatchRecordFilterSensitiveLog = MetricFilterMatchRecordFilterSensitiveLog;
const TestMetricFilterResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TestMetricFilterResponseFilterSensitiveLog = TestMetricFilterResponseFilterSensitiveLog;
const UntagLogGroupRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UntagLogGroupRequestFilterSensitiveLog = UntagLogGroupRequestFilterSensitiveLog;
const UntagResourceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UntagResourceRequestFilterSensitiveLog = UntagResourceRequestFilterSensitiveLog;


/***/ }),

/***/ 32082:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeDestinations = void 0;
const CloudWatchLogs_1 = __nccwpck_require__(718);
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const DescribeDestinationsCommand_1 = __nccwpck_require__(94646);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeDestinationsCommand_1.DescribeDestinationsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.describeDestinations(input, ...args);
};
async function* paginateDescribeDestinations(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["limit"] = config.pageSize;
        if (config.client instanceof CloudWatchLogs_1.CloudWatchLogs) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CloudWatchLogsClient_1.CloudWatchLogsClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CloudWatchLogs | CloudWatchLogsClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeDestinations = paginateDescribeDestinations;


/***/ }),

/***/ 77980:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeLogGroups = void 0;
const CloudWatchLogs_1 = __nccwpck_require__(718);
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const DescribeLogGroupsCommand_1 = __nccwpck_require__(68706);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeLogGroupsCommand_1.DescribeLogGroupsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.describeLogGroups(input, ...args);
};
async function* paginateDescribeLogGroups(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["limit"] = config.pageSize;
        if (config.client instanceof CloudWatchLogs_1.CloudWatchLogs) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CloudWatchLogsClient_1.CloudWatchLogsClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CloudWatchLogs | CloudWatchLogsClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeLogGroups = paginateDescribeLogGroups;


/***/ }),

/***/ 87820:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeLogStreams = void 0;
const CloudWatchLogs_1 = __nccwpck_require__(718);
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const DescribeLogStreamsCommand_1 = __nccwpck_require__(15229);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeLogStreamsCommand_1.DescribeLogStreamsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.describeLogStreams(input, ...args);
};
async function* paginateDescribeLogStreams(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["limit"] = config.pageSize;
        if (config.client instanceof CloudWatchLogs_1.CloudWatchLogs) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CloudWatchLogsClient_1.CloudWatchLogsClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CloudWatchLogs | CloudWatchLogsClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeLogStreams = paginateDescribeLogStreams;


/***/ }),

/***/ 37298:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeMetricFilters = void 0;
const CloudWatchLogs_1 = __nccwpck_require__(718);
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const DescribeMetricFiltersCommand_1 = __nccwpck_require__(51059);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeMetricFiltersCommand_1.DescribeMetricFiltersCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.describeMetricFilters(input, ...args);
};
async function* paginateDescribeMetricFilters(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["limit"] = config.pageSize;
        if (config.client instanceof CloudWatchLogs_1.CloudWatchLogs) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CloudWatchLogsClient_1.CloudWatchLogsClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CloudWatchLogs | CloudWatchLogsClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeMetricFilters = paginateDescribeMetricFilters;


/***/ }),

/***/ 10809:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateDescribeSubscriptionFilters = void 0;
const CloudWatchLogs_1 = __nccwpck_require__(718);
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const DescribeSubscriptionFiltersCommand_1 = __nccwpck_require__(69977);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new DescribeSubscriptionFiltersCommand_1.DescribeSubscriptionFiltersCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.describeSubscriptionFilters(input, ...args);
};
async function* paginateDescribeSubscriptionFilters(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["limit"] = config.pageSize;
        if (config.client instanceof CloudWatchLogs_1.CloudWatchLogs) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CloudWatchLogsClient_1.CloudWatchLogsClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CloudWatchLogs | CloudWatchLogsClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateDescribeSubscriptionFilters = paginateDescribeSubscriptionFilters;


/***/ }),

/***/ 27544:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateFilterLogEvents = void 0;
const CloudWatchLogs_1 = __nccwpck_require__(718);
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const FilterLogEventsCommand_1 = __nccwpck_require__(89045);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new FilterLogEventsCommand_1.FilterLogEventsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.filterLogEvents(input, ...args);
};
async function* paginateFilterLogEvents(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["limit"] = config.pageSize;
        if (config.client instanceof CloudWatchLogs_1.CloudWatchLogs) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CloudWatchLogsClient_1.CloudWatchLogsClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CloudWatchLogs | CloudWatchLogsClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateFilterLogEvents = paginateFilterLogEvents;


/***/ }),

/***/ 87081:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateGetLogEvents = void 0;
const CloudWatchLogs_1 = __nccwpck_require__(718);
const CloudWatchLogsClient_1 = __nccwpck_require__(17844);
const GetLogEventsCommand_1 = __nccwpck_require__(43771);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new GetLogEventsCommand_1.GetLogEventsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.getLogEvents(input, ...args);
};
async function* paginateGetLogEvents(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["limit"] = config.pageSize;
        if (config.client instanceof CloudWatchLogs_1.CloudWatchLogs) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CloudWatchLogsClient_1.CloudWatchLogsClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CloudWatchLogs | CloudWatchLogsClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextForwardToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateGetLogEvents = paginateGetLogEvents;


/***/ }),

/***/ 58099:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 984:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(32082), exports);
tslib_1.__exportStar(__nccwpck_require__(77980), exports);
tslib_1.__exportStar(__nccwpck_require__(87820), exports);
tslib_1.__exportStar(__nccwpck_require__(37298), exports);
tslib_1.__exportStar(__nccwpck_require__(10809), exports);
tslib_1.__exportStar(__nccwpck_require__(27544), exports);
tslib_1.__exportStar(__nccwpck_require__(87081), exports);
tslib_1.__exportStar(__nccwpck_require__(58099), exports);


/***/ }),

/***/ 97108:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeAws_json1_1CancelExportTaskCommand = exports.deserializeAws_json1_1AssociateKmsKeyCommand = exports.serializeAws_json1_1UntagResourceCommand = exports.serializeAws_json1_1UntagLogGroupCommand = exports.serializeAws_json1_1TestMetricFilterCommand = exports.serializeAws_json1_1TagResourceCommand = exports.serializeAws_json1_1TagLogGroupCommand = exports.serializeAws_json1_1StopQueryCommand = exports.serializeAws_json1_1StartQueryCommand = exports.serializeAws_json1_1PutSubscriptionFilterCommand = exports.serializeAws_json1_1PutRetentionPolicyCommand = exports.serializeAws_json1_1PutResourcePolicyCommand = exports.serializeAws_json1_1PutQueryDefinitionCommand = exports.serializeAws_json1_1PutMetricFilterCommand = exports.serializeAws_json1_1PutLogEventsCommand = exports.serializeAws_json1_1PutDestinationPolicyCommand = exports.serializeAws_json1_1PutDestinationCommand = exports.serializeAws_json1_1PutDataProtectionPolicyCommand = exports.serializeAws_json1_1ListTagsLogGroupCommand = exports.serializeAws_json1_1ListTagsForResourceCommand = exports.serializeAws_json1_1GetQueryResultsCommand = exports.serializeAws_json1_1GetLogRecordCommand = exports.serializeAws_json1_1GetLogGroupFieldsCommand = exports.serializeAws_json1_1GetLogEventsCommand = exports.serializeAws_json1_1GetDataProtectionPolicyCommand = exports.serializeAws_json1_1FilterLogEventsCommand = exports.serializeAws_json1_1DisassociateKmsKeyCommand = exports.serializeAws_json1_1DescribeSubscriptionFiltersCommand = exports.serializeAws_json1_1DescribeResourcePoliciesCommand = exports.serializeAws_json1_1DescribeQueryDefinitionsCommand = exports.serializeAws_json1_1DescribeQueriesCommand = exports.serializeAws_json1_1DescribeMetricFiltersCommand = exports.serializeAws_json1_1DescribeLogStreamsCommand = exports.serializeAws_json1_1DescribeLogGroupsCommand = exports.serializeAws_json1_1DescribeExportTasksCommand = exports.serializeAws_json1_1DescribeDestinationsCommand = exports.serializeAws_json1_1DeleteSubscriptionFilterCommand = exports.serializeAws_json1_1DeleteRetentionPolicyCommand = exports.serializeAws_json1_1DeleteResourcePolicyCommand = exports.serializeAws_json1_1DeleteQueryDefinitionCommand = exports.serializeAws_json1_1DeleteMetricFilterCommand = exports.serializeAws_json1_1DeleteLogStreamCommand = exports.serializeAws_json1_1DeleteLogGroupCommand = exports.serializeAws_json1_1DeleteDestinationCommand = exports.serializeAws_json1_1DeleteDataProtectionPolicyCommand = exports.serializeAws_json1_1CreateLogStreamCommand = exports.serializeAws_json1_1CreateLogGroupCommand = exports.serializeAws_json1_1CreateExportTaskCommand = exports.serializeAws_json1_1CancelExportTaskCommand = exports.serializeAws_json1_1AssociateKmsKeyCommand = void 0;
exports.deserializeAws_json1_1UntagResourceCommand = exports.deserializeAws_json1_1UntagLogGroupCommand = exports.deserializeAws_json1_1TestMetricFilterCommand = exports.deserializeAws_json1_1TagResourceCommand = exports.deserializeAws_json1_1TagLogGroupCommand = exports.deserializeAws_json1_1StopQueryCommand = exports.deserializeAws_json1_1StartQueryCommand = exports.deserializeAws_json1_1PutSubscriptionFilterCommand = exports.deserializeAws_json1_1PutRetentionPolicyCommand = exports.deserializeAws_json1_1PutResourcePolicyCommand = exports.deserializeAws_json1_1PutQueryDefinitionCommand = exports.deserializeAws_json1_1PutMetricFilterCommand = exports.deserializeAws_json1_1PutLogEventsCommand = exports.deserializeAws_json1_1PutDestinationPolicyCommand = exports.deserializeAws_json1_1PutDestinationCommand = exports.deserializeAws_json1_1PutDataProtectionPolicyCommand = exports.deserializeAws_json1_1ListTagsLogGroupCommand = exports.deserializeAws_json1_1ListTagsForResourceCommand = exports.deserializeAws_json1_1GetQueryResultsCommand = exports.deserializeAws_json1_1GetLogRecordCommand = exports.deserializeAws_json1_1GetLogGroupFieldsCommand = exports.deserializeAws_json1_1GetLogEventsCommand = exports.deserializeAws_json1_1GetDataProtectionPolicyCommand = exports.deserializeAws_json1_1FilterLogEventsCommand = exports.deserializeAws_json1_1DisassociateKmsKeyCommand = exports.deserializeAws_json1_1DescribeSubscriptionFiltersCommand = exports.deserializeAws_json1_1DescribeResourcePoliciesCommand = exports.deserializeAws_json1_1DescribeQueryDefinitionsCommand = exports.deserializeAws_json1_1DescribeQueriesCommand = exports.deserializeAws_json1_1DescribeMetricFiltersCommand = exports.deserializeAws_json1_1DescribeLogStreamsCommand = exports.deserializeAws_json1_1DescribeLogGroupsCommand = exports.deserializeAws_json1_1DescribeExportTasksCommand = exports.deserializeAws_json1_1DescribeDestinationsCommand = exports.deserializeAws_json1_1DeleteSubscriptionFilterCommand = exports.deserializeAws_json1_1DeleteRetentionPolicyCommand = exports.deserializeAws_json1_1DeleteResourcePolicyCommand = exports.deserializeAws_json1_1DeleteQueryDefinitionCommand = exports.deserializeAws_json1_1DeleteMetricFilterCommand = exports.deserializeAws_json1_1DeleteLogStreamCommand = exports.deserializeAws_json1_1DeleteLogGroupCommand = exports.deserializeAws_json1_1DeleteDestinationCommand = exports.deserializeAws_json1_1DeleteDataProtectionPolicyCommand = exports.deserializeAws_json1_1CreateLogStreamCommand = exports.deserializeAws_json1_1CreateLogGroupCommand = exports.deserializeAws_json1_1CreateExportTaskCommand = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const smithy_client_1 = __nccwpck_require__(4963);
const CloudWatchLogsServiceException_1 = __nccwpck_require__(86548);
const models_0_1 = __nccwpck_require__(99831);
const serializeAws_json1_1AssociateKmsKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.AssociateKmsKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1AssociateKmsKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1AssociateKmsKeyCommand = serializeAws_json1_1AssociateKmsKeyCommand;
const serializeAws_json1_1CancelExportTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.CancelExportTask",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CancelExportTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CancelExportTaskCommand = serializeAws_json1_1CancelExportTaskCommand;
const serializeAws_json1_1CreateExportTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.CreateExportTask",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateExportTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateExportTaskCommand = serializeAws_json1_1CreateExportTaskCommand;
const serializeAws_json1_1CreateLogGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.CreateLogGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateLogGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateLogGroupCommand = serializeAws_json1_1CreateLogGroupCommand;
const serializeAws_json1_1CreateLogStreamCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.CreateLogStream",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateLogStreamRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateLogStreamCommand = serializeAws_json1_1CreateLogStreamCommand;
const serializeAws_json1_1DeleteDataProtectionPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteDataProtectionPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDataProtectionPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteDataProtectionPolicyCommand = serializeAws_json1_1DeleteDataProtectionPolicyCommand;
const serializeAws_json1_1DeleteDestinationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteDestination",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDestinationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteDestinationCommand = serializeAws_json1_1DeleteDestinationCommand;
const serializeAws_json1_1DeleteLogGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteLogGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteLogGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteLogGroupCommand = serializeAws_json1_1DeleteLogGroupCommand;
const serializeAws_json1_1DeleteLogStreamCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteLogStream",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteLogStreamRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteLogStreamCommand = serializeAws_json1_1DeleteLogStreamCommand;
const serializeAws_json1_1DeleteMetricFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteMetricFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteMetricFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteMetricFilterCommand = serializeAws_json1_1DeleteMetricFilterCommand;
const serializeAws_json1_1DeleteQueryDefinitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteQueryDefinition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteQueryDefinitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteQueryDefinitionCommand = serializeAws_json1_1DeleteQueryDefinitionCommand;
const serializeAws_json1_1DeleteResourcePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteResourcePolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteResourcePolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteResourcePolicyCommand = serializeAws_json1_1DeleteResourcePolicyCommand;
const serializeAws_json1_1DeleteRetentionPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteRetentionPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteRetentionPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteRetentionPolicyCommand = serializeAws_json1_1DeleteRetentionPolicyCommand;
const serializeAws_json1_1DeleteSubscriptionFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DeleteSubscriptionFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteSubscriptionFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteSubscriptionFilterCommand = serializeAws_json1_1DeleteSubscriptionFilterCommand;
const serializeAws_json1_1DescribeDestinationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeDestinations",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeDestinationsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeDestinationsCommand = serializeAws_json1_1DescribeDestinationsCommand;
const serializeAws_json1_1DescribeExportTasksCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeExportTasks",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeExportTasksRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeExportTasksCommand = serializeAws_json1_1DescribeExportTasksCommand;
const serializeAws_json1_1DescribeLogGroupsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeLogGroups",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeLogGroupsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeLogGroupsCommand = serializeAws_json1_1DescribeLogGroupsCommand;
const serializeAws_json1_1DescribeLogStreamsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeLogStreams",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeLogStreamsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeLogStreamsCommand = serializeAws_json1_1DescribeLogStreamsCommand;
const serializeAws_json1_1DescribeMetricFiltersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeMetricFilters",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeMetricFiltersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeMetricFiltersCommand = serializeAws_json1_1DescribeMetricFiltersCommand;
const serializeAws_json1_1DescribeQueriesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeQueries",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeQueriesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeQueriesCommand = serializeAws_json1_1DescribeQueriesCommand;
const serializeAws_json1_1DescribeQueryDefinitionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeQueryDefinitions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeQueryDefinitionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeQueryDefinitionsCommand = serializeAws_json1_1DescribeQueryDefinitionsCommand;
const serializeAws_json1_1DescribeResourcePoliciesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeResourcePolicies",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeResourcePoliciesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeResourcePoliciesCommand = serializeAws_json1_1DescribeResourcePoliciesCommand;
const serializeAws_json1_1DescribeSubscriptionFiltersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DescribeSubscriptionFilters",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeSubscriptionFiltersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeSubscriptionFiltersCommand = serializeAws_json1_1DescribeSubscriptionFiltersCommand;
const serializeAws_json1_1DisassociateKmsKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.DisassociateKmsKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DisassociateKmsKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DisassociateKmsKeyCommand = serializeAws_json1_1DisassociateKmsKeyCommand;
const serializeAws_json1_1FilterLogEventsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.FilterLogEvents",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1FilterLogEventsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1FilterLogEventsCommand = serializeAws_json1_1FilterLogEventsCommand;
const serializeAws_json1_1GetDataProtectionPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.GetDataProtectionPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDataProtectionPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDataProtectionPolicyCommand = serializeAws_json1_1GetDataProtectionPolicyCommand;
const serializeAws_json1_1GetLogEventsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.GetLogEvents",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetLogEventsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetLogEventsCommand = serializeAws_json1_1GetLogEventsCommand;
const serializeAws_json1_1GetLogGroupFieldsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.GetLogGroupFields",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetLogGroupFieldsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetLogGroupFieldsCommand = serializeAws_json1_1GetLogGroupFieldsCommand;
const serializeAws_json1_1GetLogRecordCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.GetLogRecord",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetLogRecordRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetLogRecordCommand = serializeAws_json1_1GetLogRecordCommand;
const serializeAws_json1_1GetQueryResultsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.GetQueryResults",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetQueryResultsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetQueryResultsCommand = serializeAws_json1_1GetQueryResultsCommand;
const serializeAws_json1_1ListTagsForResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.ListTagsForResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTagsForResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTagsForResourceCommand = serializeAws_json1_1ListTagsForResourceCommand;
const serializeAws_json1_1ListTagsLogGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.ListTagsLogGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTagsLogGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTagsLogGroupCommand = serializeAws_json1_1ListTagsLogGroupCommand;
const serializeAws_json1_1PutDataProtectionPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutDataProtectionPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutDataProtectionPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutDataProtectionPolicyCommand = serializeAws_json1_1PutDataProtectionPolicyCommand;
const serializeAws_json1_1PutDestinationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutDestination",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutDestinationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutDestinationCommand = serializeAws_json1_1PutDestinationCommand;
const serializeAws_json1_1PutDestinationPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutDestinationPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutDestinationPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutDestinationPolicyCommand = serializeAws_json1_1PutDestinationPolicyCommand;
const serializeAws_json1_1PutLogEventsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutLogEvents",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutLogEventsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutLogEventsCommand = serializeAws_json1_1PutLogEventsCommand;
const serializeAws_json1_1PutMetricFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutMetricFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutMetricFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutMetricFilterCommand = serializeAws_json1_1PutMetricFilterCommand;
const serializeAws_json1_1PutQueryDefinitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutQueryDefinition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutQueryDefinitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutQueryDefinitionCommand = serializeAws_json1_1PutQueryDefinitionCommand;
const serializeAws_json1_1PutResourcePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutResourcePolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutResourcePolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutResourcePolicyCommand = serializeAws_json1_1PutResourcePolicyCommand;
const serializeAws_json1_1PutRetentionPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutRetentionPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutRetentionPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutRetentionPolicyCommand = serializeAws_json1_1PutRetentionPolicyCommand;
const serializeAws_json1_1PutSubscriptionFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.PutSubscriptionFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutSubscriptionFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutSubscriptionFilterCommand = serializeAws_json1_1PutSubscriptionFilterCommand;
const serializeAws_json1_1StartQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.StartQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartQueryCommand = serializeAws_json1_1StartQueryCommand;
const serializeAws_json1_1StopQueryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.StopQuery",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopQueryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopQueryCommand = serializeAws_json1_1StopQueryCommand;
const serializeAws_json1_1TagLogGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.TagLogGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagLogGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TagLogGroupCommand = serializeAws_json1_1TagLogGroupCommand;
const serializeAws_json1_1TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TagResourceCommand = serializeAws_json1_1TagResourceCommand;
const serializeAws_json1_1TestMetricFilterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.TestMetricFilter",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TestMetricFilterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TestMetricFilterCommand = serializeAws_json1_1TestMetricFilterCommand;
const serializeAws_json1_1UntagLogGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.UntagLogGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagLogGroupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UntagLogGroupCommand = serializeAws_json1_1UntagLogGroupCommand;
const serializeAws_json1_1UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "Logs_20140328.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UntagResourceCommand = serializeAws_json1_1UntagResourceCommand;
const deserializeAws_json1_1AssociateKmsKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1AssociateKmsKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1AssociateKmsKeyCommand = deserializeAws_json1_1AssociateKmsKeyCommand;
const deserializeAws_json1_1AssociateKmsKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CancelExportTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CancelExportTaskCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CancelExportTaskCommand = deserializeAws_json1_1CancelExportTaskCommand;
const deserializeAws_json1_1CancelExportTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidOperationException":
        case "com.amazonaws.cloudwatchlogs#InvalidOperationException":
            throw await deserializeAws_json1_1InvalidOperationExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateExportTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateExportTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateExportTaskResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateExportTaskCommand = deserializeAws_json1_1CreateExportTaskCommand;
const deserializeAws_json1_1CreateExportTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.cloudwatchlogs#ResourceAlreadyExistsException":
            throw await deserializeAws_json1_1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateLogGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateLogGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateLogGroupCommand = deserializeAws_json1_1CreateLogGroupCommand;
const deserializeAws_json1_1CreateLogGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.cloudwatchlogs#ResourceAlreadyExistsException":
            throw await deserializeAws_json1_1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateLogStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateLogStreamCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateLogStreamCommand = deserializeAws_json1_1CreateLogStreamCommand;
const deserializeAws_json1_1CreateLogStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.cloudwatchlogs#ResourceAlreadyExistsException":
            throw await deserializeAws_json1_1ResourceAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteDataProtectionPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteDataProtectionPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteDataProtectionPolicyCommand = deserializeAws_json1_1DeleteDataProtectionPolicyCommand;
const deserializeAws_json1_1DeleteDataProtectionPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteDestinationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteDestinationCommand = deserializeAws_json1_1DeleteDestinationCommand;
const deserializeAws_json1_1DeleteDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteLogGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteLogGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteLogGroupCommand = deserializeAws_json1_1DeleteLogGroupCommand;
const deserializeAws_json1_1DeleteLogGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteLogStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteLogStreamCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteLogStreamCommand = deserializeAws_json1_1DeleteLogStreamCommand;
const deserializeAws_json1_1DeleteLogStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteMetricFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteMetricFilterCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteMetricFilterCommand = deserializeAws_json1_1DeleteMetricFilterCommand;
const deserializeAws_json1_1DeleteMetricFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteQueryDefinitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteQueryDefinitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteQueryDefinitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteQueryDefinitionCommand = deserializeAws_json1_1DeleteQueryDefinitionCommand;
const deserializeAws_json1_1DeleteQueryDefinitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteResourcePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteResourcePolicyCommand = deserializeAws_json1_1DeleteResourcePolicyCommand;
const deserializeAws_json1_1DeleteResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteRetentionPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteRetentionPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteRetentionPolicyCommand = deserializeAws_json1_1DeleteRetentionPolicyCommand;
const deserializeAws_json1_1DeleteRetentionPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteSubscriptionFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteSubscriptionFilterCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteSubscriptionFilterCommand = deserializeAws_json1_1DeleteSubscriptionFilterCommand;
const deserializeAws_json1_1DeleteSubscriptionFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeDestinationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeDestinationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeDestinationsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeDestinationsCommand = deserializeAws_json1_1DescribeDestinationsCommand;
const deserializeAws_json1_1DescribeDestinationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeExportTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeExportTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeExportTasksResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeExportTasksCommand = deserializeAws_json1_1DescribeExportTasksCommand;
const deserializeAws_json1_1DescribeExportTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeLogGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeLogGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeLogGroupsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeLogGroupsCommand = deserializeAws_json1_1DescribeLogGroupsCommand;
const deserializeAws_json1_1DescribeLogGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeLogStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeLogStreamsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeLogStreamsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeLogStreamsCommand = deserializeAws_json1_1DescribeLogStreamsCommand;
const deserializeAws_json1_1DescribeLogStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeMetricFiltersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeMetricFiltersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeMetricFiltersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeMetricFiltersCommand = deserializeAws_json1_1DescribeMetricFiltersCommand;
const deserializeAws_json1_1DescribeMetricFiltersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeQueriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeQueriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeQueriesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeQueriesCommand = deserializeAws_json1_1DescribeQueriesCommand;
const deserializeAws_json1_1DescribeQueriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeQueryDefinitionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeQueryDefinitionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeQueryDefinitionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeQueryDefinitionsCommand = deserializeAws_json1_1DescribeQueryDefinitionsCommand;
const deserializeAws_json1_1DescribeQueryDefinitionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeResourcePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeResourcePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeResourcePoliciesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeResourcePoliciesCommand = deserializeAws_json1_1DescribeResourcePoliciesCommand;
const deserializeAws_json1_1DescribeResourcePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeSubscriptionFiltersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeSubscriptionFiltersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeSubscriptionFiltersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeSubscriptionFiltersCommand = deserializeAws_json1_1DescribeSubscriptionFiltersCommand;
const deserializeAws_json1_1DescribeSubscriptionFiltersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DisassociateKmsKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DisassociateKmsKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DisassociateKmsKeyCommand = deserializeAws_json1_1DisassociateKmsKeyCommand;
const deserializeAws_json1_1DisassociateKmsKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1FilterLogEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1FilterLogEventsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1FilterLogEventsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1FilterLogEventsCommand = deserializeAws_json1_1FilterLogEventsCommand;
const deserializeAws_json1_1FilterLogEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetDataProtectionPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDataProtectionPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDataProtectionPolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetDataProtectionPolicyCommand = deserializeAws_json1_1GetDataProtectionPolicyCommand;
const deserializeAws_json1_1GetDataProtectionPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetLogEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetLogEventsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetLogEventsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetLogEventsCommand = deserializeAws_json1_1GetLogEventsCommand;
const deserializeAws_json1_1GetLogEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetLogGroupFieldsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetLogGroupFieldsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetLogGroupFieldsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetLogGroupFieldsCommand = deserializeAws_json1_1GetLogGroupFieldsCommand;
const deserializeAws_json1_1GetLogGroupFieldsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetLogRecordCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetLogRecordCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetLogRecordResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetLogRecordCommand = deserializeAws_json1_1GetLogRecordCommand;
const deserializeAws_json1_1GetLogRecordCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetQueryResultsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetQueryResultsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetQueryResultsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetQueryResultsCommand = deserializeAws_json1_1GetQueryResultsCommand;
const deserializeAws_json1_1GetQueryResultsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTagsForResourceCommand = deserializeAws_json1_1ListTagsForResourceCommand;
const deserializeAws_json1_1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListTagsLogGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTagsLogGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTagsLogGroupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTagsLogGroupCommand = deserializeAws_json1_1ListTagsLogGroupCommand;
const deserializeAws_json1_1ListTagsLogGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutDataProtectionPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutDataProtectionPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutDataProtectionPolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutDataProtectionPolicyCommand = deserializeAws_json1_1PutDataProtectionPolicyCommand;
const deserializeAws_json1_1PutDataProtectionPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutDestinationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutDestinationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutDestinationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutDestinationCommand = deserializeAws_json1_1PutDestinationCommand;
const deserializeAws_json1_1PutDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutDestinationPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutDestinationPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutDestinationPolicyCommand = deserializeAws_json1_1PutDestinationPolicyCommand;
const deserializeAws_json1_1PutDestinationPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutLogEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutLogEventsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutLogEventsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutLogEventsCommand = deserializeAws_json1_1PutLogEventsCommand;
const deserializeAws_json1_1PutLogEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DataAlreadyAcceptedException":
        case "com.amazonaws.cloudwatchlogs#DataAlreadyAcceptedException":
            throw await deserializeAws_json1_1DataAlreadyAcceptedExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "InvalidSequenceTokenException":
        case "com.amazonaws.cloudwatchlogs#InvalidSequenceTokenException":
            throw await deserializeAws_json1_1InvalidSequenceTokenExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "UnrecognizedClientException":
        case "com.amazonaws.cloudwatchlogs#UnrecognizedClientException":
            throw await deserializeAws_json1_1UnrecognizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutMetricFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutMetricFilterCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutMetricFilterCommand = deserializeAws_json1_1PutMetricFilterCommand;
const deserializeAws_json1_1PutMetricFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutQueryDefinitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutQueryDefinitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutQueryDefinitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutQueryDefinitionCommand = deserializeAws_json1_1PutQueryDefinitionCommand;
const deserializeAws_json1_1PutQueryDefinitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutResourcePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutResourcePolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutResourcePolicyCommand = deserializeAws_json1_1PutResourcePolicyCommand;
const deserializeAws_json1_1PutResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutRetentionPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutRetentionPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutRetentionPolicyCommand = deserializeAws_json1_1PutRetentionPolicyCommand;
const deserializeAws_json1_1PutRetentionPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutSubscriptionFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutSubscriptionFilterCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutSubscriptionFilterCommand = deserializeAws_json1_1PutSubscriptionFilterCommand;
const deserializeAws_json1_1PutSubscriptionFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "OperationAbortedException":
        case "com.amazonaws.cloudwatchlogs#OperationAbortedException":
            throw await deserializeAws_json1_1OperationAbortedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1StartQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartQueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartQueryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StartQueryCommand = deserializeAws_json1_1StartQueryCommand;
const deserializeAws_json1_1StartQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatchlogs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "MalformedQueryException":
        case "com.amazonaws.cloudwatchlogs#MalformedQueryException":
            throw await deserializeAws_json1_1MalformedQueryExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1StopQueryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopQueryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopQueryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StopQueryCommand = deserializeAws_json1_1StopQueryCommand;
const deserializeAws_json1_1StopQueryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1TagLogGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TagLogGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1TagLogGroupCommand = deserializeAws_json1_1TagLogGroupCommand;
const deserializeAws_json1_1TagLogGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TagResourceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1TagResourceCommand = deserializeAws_json1_1TagResourceCommand;
const deserializeAws_json1_1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.cloudwatchlogs#TooManyTagsException":
            throw await deserializeAws_json1_1TooManyTagsExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1TestMetricFilterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TestMetricFilterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1TestMetricFilterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1TestMetricFilterCommand = deserializeAws_json1_1TestMetricFilterCommand;
const deserializeAws_json1_1TestMetricFilterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UntagLogGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UntagLogGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UntagLogGroupCommand = deserializeAws_json1_1UntagLogGroupCommand;
const deserializeAws_json1_1UntagLogGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UntagResourceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UntagResourceCommand = deserializeAws_json1_1UntagResourceCommand;
const deserializeAws_json1_1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterException":
        case "com.amazonaws.cloudwatchlogs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatchlogs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.cloudwatchlogs#ServiceUnavailableException":
            throw await deserializeAws_json1_1ServiceUnavailableExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CloudWatchLogsServiceException_1.CloudWatchLogsServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DataAlreadyAcceptedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DataAlreadyAcceptedException(body, context);
    const exception = new models_0_1.DataAlreadyAcceptedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidOperationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidOperationException(body, context);
    const exception = new models_0_1.InvalidOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidParameterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidParameterException(body, context);
    const exception = new models_0_1.InvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidSequenceTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidSequenceTokenException(body, context);
    const exception = new models_0_1.InvalidSequenceTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1MalformedQueryExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1MalformedQueryException(body, context);
    const exception = new models_0_1.MalformedQueryException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1OperationAbortedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1OperationAbortedException(body, context);
    const exception = new models_0_1.OperationAbortedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ResourceAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceAlreadyExistsException(body, context);
    const exception = new models_0_1.ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceNotFoundException(body, context);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ServiceUnavailableExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ServiceUnavailableException(body, context);
    const exception = new models_0_1.ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TooManyTagsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TooManyTagsException(body, context);
    const exception = new models_0_1.TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1UnrecognizedClientExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UnrecognizedClientException(body, context);
    const exception = new models_0_1.UnrecognizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const serializeAws_json1_1AccountIds = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1AssociateKmsKeyRequest = (input, context) => {
    return {
        ...(input.kmsKeyId != null && { kmsKeyId: input.kmsKeyId }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
    };
};
const serializeAws_json1_1CancelExportTaskRequest = (input, context) => {
    return {
        ...(input.taskId != null && { taskId: input.taskId }),
    };
};
const serializeAws_json1_1CreateExportTaskRequest = (input, context) => {
    return {
        ...(input.destination != null && { destination: input.destination }),
        ...(input.destinationPrefix != null && { destinationPrefix: input.destinationPrefix }),
        ...(input.from != null && { from: input.from }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logStreamNamePrefix != null && { logStreamNamePrefix: input.logStreamNamePrefix }),
        ...(input.taskName != null && { taskName: input.taskName }),
        ...(input.to != null && { to: input.to }),
    };
};
const serializeAws_json1_1CreateLogGroupRequest = (input, context) => {
    return {
        ...(input.kmsKeyId != null && { kmsKeyId: input.kmsKeyId }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
    };
};
const serializeAws_json1_1CreateLogStreamRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logStreamName != null && { logStreamName: input.logStreamName }),
    };
};
const serializeAws_json1_1DeleteDataProtectionPolicyRequest = (input, context) => {
    return {
        ...(input.logGroupIdentifier != null && { logGroupIdentifier: input.logGroupIdentifier }),
    };
};
const serializeAws_json1_1DeleteDestinationRequest = (input, context) => {
    return {
        ...(input.destinationName != null && { destinationName: input.destinationName }),
    };
};
const serializeAws_json1_1DeleteLogGroupRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
    };
};
const serializeAws_json1_1DeleteLogStreamRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logStreamName != null && { logStreamName: input.logStreamName }),
    };
};
const serializeAws_json1_1DeleteMetricFilterRequest = (input, context) => {
    return {
        ...(input.filterName != null && { filterName: input.filterName }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
    };
};
const serializeAws_json1_1DeleteQueryDefinitionRequest = (input, context) => {
    return {
        ...(input.queryDefinitionId != null && { queryDefinitionId: input.queryDefinitionId }),
    };
};
const serializeAws_json1_1DeleteResourcePolicyRequest = (input, context) => {
    return {
        ...(input.policyName != null && { policyName: input.policyName }),
    };
};
const serializeAws_json1_1DeleteRetentionPolicyRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
    };
};
const serializeAws_json1_1DeleteSubscriptionFilterRequest = (input, context) => {
    return {
        ...(input.filterName != null && { filterName: input.filterName }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
    };
};
const serializeAws_json1_1DescribeDestinationsRequest = (input, context) => {
    return {
        ...(input.DestinationNamePrefix != null && { DestinationNamePrefix: input.DestinationNamePrefix }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1DescribeExportTasksRequest = (input, context) => {
    return {
        ...(input.limit != null && { limit: input.limit }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.statusCode != null && { statusCode: input.statusCode }),
        ...(input.taskId != null && { taskId: input.taskId }),
    };
};
const serializeAws_json1_1DescribeLogGroupsRequest = (input, context) => {
    return {
        ...(input.accountIdentifiers != null && {
            accountIdentifiers: serializeAws_json1_1AccountIds(input.accountIdentifiers, context),
        }),
        ...(input.includeLinkedAccounts != null && { includeLinkedAccounts: input.includeLinkedAccounts }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.logGroupNamePattern != null && { logGroupNamePattern: input.logGroupNamePattern }),
        ...(input.logGroupNamePrefix != null && { logGroupNamePrefix: input.logGroupNamePrefix }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1DescribeLogStreamsRequest = (input, context) => {
    return {
        ...(input.descending != null && { descending: input.descending }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.logGroupIdentifier != null && { logGroupIdentifier: input.logGroupIdentifier }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logStreamNamePrefix != null && { logStreamNamePrefix: input.logStreamNamePrefix }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.orderBy != null && { orderBy: input.orderBy }),
    };
};
const serializeAws_json1_1DescribeMetricFiltersRequest = (input, context) => {
    return {
        ...(input.filterNamePrefix != null && { filterNamePrefix: input.filterNamePrefix }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.metricName != null && { metricName: input.metricName }),
        ...(input.metricNamespace != null && { metricNamespace: input.metricNamespace }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1DescribeQueriesRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1DescribeQueryDefinitionsRequest = (input, context) => {
    return {
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.queryDefinitionNamePrefix != null && { queryDefinitionNamePrefix: input.queryDefinitionNamePrefix }),
    };
};
const serializeAws_json1_1DescribeResourcePoliciesRequest = (input, context) => {
    return {
        ...(input.limit != null && { limit: input.limit }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1DescribeSubscriptionFiltersRequest = (input, context) => {
    return {
        ...(input.filterNamePrefix != null && { filterNamePrefix: input.filterNamePrefix }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1Dimensions = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1DisassociateKmsKeyRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
    };
};
const serializeAws_json1_1FilterLogEventsRequest = (input, context) => {
    return {
        ...(input.endTime != null && { endTime: input.endTime }),
        ...(input.filterPattern != null && { filterPattern: input.filterPattern }),
        ...(input.interleaved != null && { interleaved: input.interleaved }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.logGroupIdentifier != null && { logGroupIdentifier: input.logGroupIdentifier }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logStreamNamePrefix != null && { logStreamNamePrefix: input.logStreamNamePrefix }),
        ...(input.logStreamNames != null && {
            logStreamNames: serializeAws_json1_1InputLogStreamNames(input.logStreamNames, context),
        }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.startTime != null && { startTime: input.startTime }),
        ...(input.unmask != null && { unmask: input.unmask }),
    };
};
const serializeAws_json1_1GetDataProtectionPolicyRequest = (input, context) => {
    return {
        ...(input.logGroupIdentifier != null && { logGroupIdentifier: input.logGroupIdentifier }),
    };
};
const serializeAws_json1_1GetLogEventsRequest = (input, context) => {
    return {
        ...(input.endTime != null && { endTime: input.endTime }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.logGroupIdentifier != null && { logGroupIdentifier: input.logGroupIdentifier }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logStreamName != null && { logStreamName: input.logStreamName }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.startFromHead != null && { startFromHead: input.startFromHead }),
        ...(input.startTime != null && { startTime: input.startTime }),
        ...(input.unmask != null && { unmask: input.unmask }),
    };
};
const serializeAws_json1_1GetLogGroupFieldsRequest = (input, context) => {
    return {
        ...(input.logGroupIdentifier != null && { logGroupIdentifier: input.logGroupIdentifier }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.time != null && { time: input.time }),
    };
};
const serializeAws_json1_1GetLogRecordRequest = (input, context) => {
    return {
        ...(input.logRecordPointer != null && { logRecordPointer: input.logRecordPointer }),
        ...(input.unmask != null && { unmask: input.unmask }),
    };
};
const serializeAws_json1_1GetQueryResultsRequest = (input, context) => {
    return {
        ...(input.queryId != null && { queryId: input.queryId }),
    };
};
const serializeAws_json1_1InputLogEvent = (input, context) => {
    return {
        ...(input.message != null && { message: input.message }),
        ...(input.timestamp != null && { timestamp: input.timestamp }),
    };
};
const serializeAws_json1_1InputLogEvents = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1InputLogEvent(entry, context);
    });
};
const serializeAws_json1_1InputLogStreamNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ListTagsForResourceRequest = (input, context) => {
    return {
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
    };
};
const serializeAws_json1_1ListTagsLogGroupRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
    };
};
const serializeAws_json1_1LogGroupIdentifiers = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1LogGroupNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1MetricTransformation = (input, context) => {
    return {
        ...(input.defaultValue != null && { defaultValue: (0, smithy_client_1.serializeFloat)(input.defaultValue) }),
        ...(input.dimensions != null && { dimensions: serializeAws_json1_1Dimensions(input.dimensions, context) }),
        ...(input.metricName != null && { metricName: input.metricName }),
        ...(input.metricNamespace != null && { metricNamespace: input.metricNamespace }),
        ...(input.metricValue != null && { metricValue: input.metricValue }),
        ...(input.unit != null && { unit: input.unit }),
    };
};
const serializeAws_json1_1MetricTransformations = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1MetricTransformation(entry, context);
    });
};
const serializeAws_json1_1PutDataProtectionPolicyRequest = (input, context) => {
    return {
        ...(input.logGroupIdentifier != null && { logGroupIdentifier: input.logGroupIdentifier }),
        ...(input.policyDocument != null && { policyDocument: input.policyDocument }),
    };
};
const serializeAws_json1_1PutDestinationPolicyRequest = (input, context) => {
    return {
        ...(input.accessPolicy != null && { accessPolicy: input.accessPolicy }),
        ...(input.destinationName != null && { destinationName: input.destinationName }),
        ...(input.forceUpdate != null && { forceUpdate: input.forceUpdate }),
    };
};
const serializeAws_json1_1PutDestinationRequest = (input, context) => {
    return {
        ...(input.destinationName != null && { destinationName: input.destinationName }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
        ...(input.targetArn != null && { targetArn: input.targetArn }),
    };
};
const serializeAws_json1_1PutLogEventsRequest = (input, context) => {
    return {
        ...(input.logEvents != null && { logEvents: serializeAws_json1_1InputLogEvents(input.logEvents, context) }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logStreamName != null && { logStreamName: input.logStreamName }),
        ...(input.sequenceToken != null && { sequenceToken: input.sequenceToken }),
    };
};
const serializeAws_json1_1PutMetricFilterRequest = (input, context) => {
    return {
        ...(input.filterName != null && { filterName: input.filterName }),
        ...(input.filterPattern != null && { filterPattern: input.filterPattern }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.metricTransformations != null && {
            metricTransformations: serializeAws_json1_1MetricTransformations(input.metricTransformations, context),
        }),
    };
};
const serializeAws_json1_1PutQueryDefinitionRequest = (input, context) => {
    return {
        ...(input.logGroupNames != null && {
            logGroupNames: serializeAws_json1_1LogGroupNames(input.logGroupNames, context),
        }),
        ...(input.name != null && { name: input.name }),
        ...(input.queryDefinitionId != null && { queryDefinitionId: input.queryDefinitionId }),
        ...(input.queryString != null && { queryString: input.queryString }),
    };
};
const serializeAws_json1_1PutResourcePolicyRequest = (input, context) => {
    return {
        ...(input.policyDocument != null && { policyDocument: input.policyDocument }),
        ...(input.policyName != null && { policyName: input.policyName }),
    };
};
const serializeAws_json1_1PutRetentionPolicyRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.retentionInDays != null && { retentionInDays: input.retentionInDays }),
    };
};
const serializeAws_json1_1PutSubscriptionFilterRequest = (input, context) => {
    return {
        ...(input.destinationArn != null && { destinationArn: input.destinationArn }),
        ...(input.distribution != null && { distribution: input.distribution }),
        ...(input.filterName != null && { filterName: input.filterName }),
        ...(input.filterPattern != null && { filterPattern: input.filterPattern }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.roleArn != null && { roleArn: input.roleArn }),
    };
};
const serializeAws_json1_1StartQueryRequest = (input, context) => {
    return {
        ...(input.endTime != null && { endTime: input.endTime }),
        ...(input.limit != null && { limit: input.limit }),
        ...(input.logGroupIdentifiers != null && {
            logGroupIdentifiers: serializeAws_json1_1LogGroupIdentifiers(input.logGroupIdentifiers, context),
        }),
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.logGroupNames != null && {
            logGroupNames: serializeAws_json1_1LogGroupNames(input.logGroupNames, context),
        }),
        ...(input.queryString != null && { queryString: input.queryString }),
        ...(input.startTime != null && { startTime: input.startTime }),
    };
};
const serializeAws_json1_1StopQueryRequest = (input, context) => {
    return {
        ...(input.queryId != null && { queryId: input.queryId }),
    };
};
const serializeAws_json1_1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TagLogGroupRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
    };
};
const serializeAws_json1_1TagResourceRequest = (input, context) => {
    return {
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
    };
};
const serializeAws_json1_1Tags = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1TestEventMessages = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TestMetricFilterRequest = (input, context) => {
    return {
        ...(input.filterPattern != null && { filterPattern: input.filterPattern }),
        ...(input.logEventMessages != null && {
            logEventMessages: serializeAws_json1_1TestEventMessages(input.logEventMessages, context),
        }),
    };
};
const serializeAws_json1_1UntagLogGroupRequest = (input, context) => {
    return {
        ...(input.logGroupName != null && { logGroupName: input.logGroupName }),
        ...(input.tags != null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    };
};
const serializeAws_json1_1UntagResourceRequest = (input, context) => {
    return {
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
        ...(input.tagKeys != null && { tagKeys: serializeAws_json1_1TagKeyList(input.tagKeys, context) }),
    };
};
const deserializeAws_json1_1CreateExportTaskResponse = (output, context) => {
    return {
        taskId: (0, smithy_client_1.expectString)(output.taskId),
    };
};
const deserializeAws_json1_1DataAlreadyAcceptedException = (output, context) => {
    return {
        expectedSequenceToken: (0, smithy_client_1.expectString)(output.expectedSequenceToken),
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeleteQueryDefinitionResponse = (output, context) => {
    return {
        success: (0, smithy_client_1.expectBoolean)(output.success),
    };
};
const deserializeAws_json1_1DescribeDestinationsResponse = (output, context) => {
    return {
        destinations: output.destinations != null ? deserializeAws_json1_1Destinations(output.destinations, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1DescribeExportTasksResponse = (output, context) => {
    return {
        exportTasks: output.exportTasks != null ? deserializeAws_json1_1ExportTasks(output.exportTasks, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1DescribeLogGroupsResponse = (output, context) => {
    return {
        logGroups: output.logGroups != null ? deserializeAws_json1_1LogGroups(output.logGroups, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1DescribeLogStreamsResponse = (output, context) => {
    return {
        logStreams: output.logStreams != null ? deserializeAws_json1_1LogStreams(output.logStreams, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1DescribeMetricFiltersResponse = (output, context) => {
    return {
        metricFilters: output.metricFilters != null ? deserializeAws_json1_1MetricFilters(output.metricFilters, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1DescribeQueriesResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        queries: output.queries != null ? deserializeAws_json1_1QueryInfoList(output.queries, context) : undefined,
    };
};
const deserializeAws_json1_1DescribeQueryDefinitionsResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        queryDefinitions: output.queryDefinitions != null
            ? deserializeAws_json1_1QueryDefinitionList(output.queryDefinitions, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeResourcePoliciesResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        resourcePolicies: output.resourcePolicies != null
            ? deserializeAws_json1_1ResourcePolicies(output.resourcePolicies, context)
            : undefined,
    };
};
const deserializeAws_json1_1DescribeSubscriptionFiltersResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        subscriptionFilters: output.subscriptionFilters != null
            ? deserializeAws_json1_1SubscriptionFilters(output.subscriptionFilters, context)
            : undefined,
    };
};
const deserializeAws_json1_1Destination = (output, context) => {
    return {
        accessPolicy: (0, smithy_client_1.expectString)(output.accessPolicy),
        arn: (0, smithy_client_1.expectString)(output.arn),
        creationTime: (0, smithy_client_1.expectLong)(output.creationTime),
        destinationName: (0, smithy_client_1.expectString)(output.destinationName),
        roleArn: (0, smithy_client_1.expectString)(output.roleArn),
        targetArn: (0, smithy_client_1.expectString)(output.targetArn),
    };
};
const deserializeAws_json1_1Destinations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Destination(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Dimensions = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1ExportTask = (output, context) => {
    return {
        destination: (0, smithy_client_1.expectString)(output.destination),
        destinationPrefix: (0, smithy_client_1.expectString)(output.destinationPrefix),
        executionInfo: output.executionInfo != null
            ? deserializeAws_json1_1ExportTaskExecutionInfo(output.executionInfo, context)
            : undefined,
        from: (0, smithy_client_1.expectLong)(output.from),
        logGroupName: (0, smithy_client_1.expectString)(output.logGroupName),
        status: output.status != null ? deserializeAws_json1_1ExportTaskStatus(output.status, context) : undefined,
        taskId: (0, smithy_client_1.expectString)(output.taskId),
        taskName: (0, smithy_client_1.expectString)(output.taskName),
        to: (0, smithy_client_1.expectLong)(output.to),
    };
};
const deserializeAws_json1_1ExportTaskExecutionInfo = (output, context) => {
    return {
        completionTime: (0, smithy_client_1.expectLong)(output.completionTime),
        creationTime: (0, smithy_client_1.expectLong)(output.creationTime),
    };
};
const deserializeAws_json1_1ExportTasks = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ExportTask(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ExportTaskStatus = (output, context) => {
    return {
        code: (0, smithy_client_1.expectString)(output.code),
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ExtractedValues = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1FilteredLogEvent = (output, context) => {
    return {
        eventId: (0, smithy_client_1.expectString)(output.eventId),
        ingestionTime: (0, smithy_client_1.expectLong)(output.ingestionTime),
        logStreamName: (0, smithy_client_1.expectString)(output.logStreamName),
        message: (0, smithy_client_1.expectString)(output.message),
        timestamp: (0, smithy_client_1.expectLong)(output.timestamp),
    };
};
const deserializeAws_json1_1FilteredLogEvents = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1FilteredLogEvent(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1FilterLogEventsResponse = (output, context) => {
    return {
        events: output.events != null ? deserializeAws_json1_1FilteredLogEvents(output.events, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        searchedLogStreams: output.searchedLogStreams != null
            ? deserializeAws_json1_1SearchedLogStreams(output.searchedLogStreams, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDataProtectionPolicyResponse = (output, context) => {
    return {
        lastUpdatedTime: (0, smithy_client_1.expectLong)(output.lastUpdatedTime),
        logGroupIdentifier: (0, smithy_client_1.expectString)(output.logGroupIdentifier),
        policyDocument: (0, smithy_client_1.expectString)(output.policyDocument),
    };
};
const deserializeAws_json1_1GetLogEventsResponse = (output, context) => {
    return {
        events: output.events != null ? deserializeAws_json1_1OutputLogEvents(output.events, context) : undefined,
        nextBackwardToken: (0, smithy_client_1.expectString)(output.nextBackwardToken),
        nextForwardToken: (0, smithy_client_1.expectString)(output.nextForwardToken),
    };
};
const deserializeAws_json1_1GetLogGroupFieldsResponse = (output, context) => {
    return {
        logGroupFields: output.logGroupFields != null
            ? deserializeAws_json1_1LogGroupFieldList(output.logGroupFields, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetLogRecordResponse = (output, context) => {
    return {
        logRecord: output.logRecord != null ? deserializeAws_json1_1LogRecord(output.logRecord, context) : undefined,
    };
};
const deserializeAws_json1_1GetQueryResultsResponse = (output, context) => {
    return {
        results: output.results != null ? deserializeAws_json1_1QueryResults(output.results, context) : undefined,
        statistics: output.statistics != null ? deserializeAws_json1_1QueryStatistics(output.statistics, context) : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_json1_1InvalidOperationException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidParameterException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidSequenceTokenException = (output, context) => {
    return {
        expectedSequenceToken: (0, smithy_client_1.expectString)(output.expectedSequenceToken),
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1LimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ListTagsForResourceResponse = (output, context) => {
    return {
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
    };
};
const deserializeAws_json1_1ListTagsLogGroupResponse = (output, context) => {
    return {
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
    };
};
const deserializeAws_json1_1LogGroup = (output, context) => {
    return {
        arn: (0, smithy_client_1.expectString)(output.arn),
        creationTime: (0, smithy_client_1.expectLong)(output.creationTime),
        dataProtectionStatus: (0, smithy_client_1.expectString)(output.dataProtectionStatus),
        kmsKeyId: (0, smithy_client_1.expectString)(output.kmsKeyId),
        logGroupName: (0, smithy_client_1.expectString)(output.logGroupName),
        metricFilterCount: (0, smithy_client_1.expectInt32)(output.metricFilterCount),
        retentionInDays: (0, smithy_client_1.expectInt32)(output.retentionInDays),
        storedBytes: (0, smithy_client_1.expectLong)(output.storedBytes),
    };
};
const deserializeAws_json1_1LogGroupField = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
        percent: (0, smithy_client_1.expectInt32)(output.percent),
    };
};
const deserializeAws_json1_1LogGroupFieldList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1LogGroupField(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1LogGroupNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1LogGroups = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1LogGroup(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1LogRecord = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1LogStream = (output, context) => {
    return {
        arn: (0, smithy_client_1.expectString)(output.arn),
        creationTime: (0, smithy_client_1.expectLong)(output.creationTime),
        firstEventTimestamp: (0, smithy_client_1.expectLong)(output.firstEventTimestamp),
        lastEventTimestamp: (0, smithy_client_1.expectLong)(output.lastEventTimestamp),
        lastIngestionTime: (0, smithy_client_1.expectLong)(output.lastIngestionTime),
        logStreamName: (0, smithy_client_1.expectString)(output.logStreamName),
        storedBytes: (0, smithy_client_1.expectLong)(output.storedBytes),
        uploadSequenceToken: (0, smithy_client_1.expectString)(output.uploadSequenceToken),
    };
};
const deserializeAws_json1_1LogStreams = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1LogStream(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1MalformedQueryException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
        queryCompileError: output.queryCompileError != null
            ? deserializeAws_json1_1QueryCompileError(output.queryCompileError, context)
            : undefined,
    };
};
const deserializeAws_json1_1MetricFilter = (output, context) => {
    return {
        creationTime: (0, smithy_client_1.expectLong)(output.creationTime),
        filterName: (0, smithy_client_1.expectString)(output.filterName),
        filterPattern: (0, smithy_client_1.expectString)(output.filterPattern),
        logGroupName: (0, smithy_client_1.expectString)(output.logGroupName),
        metricTransformations: output.metricTransformations != null
            ? deserializeAws_json1_1MetricTransformations(output.metricTransformations, context)
            : undefined,
    };
};
const deserializeAws_json1_1MetricFilterMatches = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MetricFilterMatchRecord(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1MetricFilterMatchRecord = (output, context) => {
    return {
        eventMessage: (0, smithy_client_1.expectString)(output.eventMessage),
        eventNumber: (0, smithy_client_1.expectLong)(output.eventNumber),
        extractedValues: output.extractedValues != null
            ? deserializeAws_json1_1ExtractedValues(output.extractedValues, context)
            : undefined,
    };
};
const deserializeAws_json1_1MetricFilters = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MetricFilter(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1MetricTransformation = (output, context) => {
    return {
        defaultValue: (0, smithy_client_1.limitedParseDouble)(output.defaultValue),
        dimensions: output.dimensions != null ? deserializeAws_json1_1Dimensions(output.dimensions, context) : undefined,
        metricName: (0, smithy_client_1.expectString)(output.metricName),
        metricNamespace: (0, smithy_client_1.expectString)(output.metricNamespace),
        metricValue: (0, smithy_client_1.expectString)(output.metricValue),
        unit: (0, smithy_client_1.expectString)(output.unit),
    };
};
const deserializeAws_json1_1MetricTransformations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MetricTransformation(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1OperationAbortedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1OutputLogEvent = (output, context) => {
    return {
        ingestionTime: (0, smithy_client_1.expectLong)(output.ingestionTime),
        message: (0, smithy_client_1.expectString)(output.message),
        timestamp: (0, smithy_client_1.expectLong)(output.timestamp),
    };
};
const deserializeAws_json1_1OutputLogEvents = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1OutputLogEvent(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PutDataProtectionPolicyResponse = (output, context) => {
    return {
        lastUpdatedTime: (0, smithy_client_1.expectLong)(output.lastUpdatedTime),
        logGroupIdentifier: (0, smithy_client_1.expectString)(output.logGroupIdentifier),
        policyDocument: (0, smithy_client_1.expectString)(output.policyDocument),
    };
};
const deserializeAws_json1_1PutDestinationResponse = (output, context) => {
    return {
        destination: output.destination != null ? deserializeAws_json1_1Destination(output.destination, context) : undefined,
    };
};
const deserializeAws_json1_1PutLogEventsResponse = (output, context) => {
    return {
        nextSequenceToken: (0, smithy_client_1.expectString)(output.nextSequenceToken),
        rejectedLogEventsInfo: output.rejectedLogEventsInfo != null
            ? deserializeAws_json1_1RejectedLogEventsInfo(output.rejectedLogEventsInfo, context)
            : undefined,
    };
};
const deserializeAws_json1_1PutQueryDefinitionResponse = (output, context) => {
    return {
        queryDefinitionId: (0, smithy_client_1.expectString)(output.queryDefinitionId),
    };
};
const deserializeAws_json1_1PutResourcePolicyResponse = (output, context) => {
    return {
        resourcePolicy: output.resourcePolicy != null ? deserializeAws_json1_1ResourcePolicy(output.resourcePolicy, context) : undefined,
    };
};
const deserializeAws_json1_1QueryCompileError = (output, context) => {
    return {
        location: output.location != null ? deserializeAws_json1_1QueryCompileErrorLocation(output.location, context) : undefined,
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1QueryCompileErrorLocation = (output, context) => {
    return {
        endCharOffset: (0, smithy_client_1.expectInt32)(output.endCharOffset),
        startCharOffset: (0, smithy_client_1.expectInt32)(output.startCharOffset),
    };
};
const deserializeAws_json1_1QueryDefinition = (output, context) => {
    return {
        lastModified: (0, smithy_client_1.expectLong)(output.lastModified),
        logGroupNames: output.logGroupNames != null ? deserializeAws_json1_1LogGroupNames(output.logGroupNames, context) : undefined,
        name: (0, smithy_client_1.expectString)(output.name),
        queryDefinitionId: (0, smithy_client_1.expectString)(output.queryDefinitionId),
        queryString: (0, smithy_client_1.expectString)(output.queryString),
    };
};
const deserializeAws_json1_1QueryDefinitionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1QueryDefinition(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1QueryInfo = (output, context) => {
    return {
        createTime: (0, smithy_client_1.expectLong)(output.createTime),
        logGroupName: (0, smithy_client_1.expectString)(output.logGroupName),
        queryId: (0, smithy_client_1.expectString)(output.queryId),
        queryString: (0, smithy_client_1.expectString)(output.queryString),
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_json1_1QueryInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1QueryInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1QueryResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ResultRows(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1QueryStatistics = (output, context) => {
    return {
        bytesScanned: (0, smithy_client_1.limitedParseDouble)(output.bytesScanned),
        recordsMatched: (0, smithy_client_1.limitedParseDouble)(output.recordsMatched),
        recordsScanned: (0, smithy_client_1.limitedParseDouble)(output.recordsScanned),
    };
};
const deserializeAws_json1_1RejectedLogEventsInfo = (output, context) => {
    return {
        expiredLogEventEndIndex: (0, smithy_client_1.expectInt32)(output.expiredLogEventEndIndex),
        tooNewLogEventStartIndex: (0, smithy_client_1.expectInt32)(output.tooNewLogEventStartIndex),
        tooOldLogEventEndIndex: (0, smithy_client_1.expectInt32)(output.tooOldLogEventEndIndex),
    };
};
const deserializeAws_json1_1ResourceAlreadyExistsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ResourceNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ResourcePolicies = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ResourcePolicy(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ResourcePolicy = (output, context) => {
    return {
        lastUpdatedTime: (0, smithy_client_1.expectLong)(output.lastUpdatedTime),
        policyDocument: (0, smithy_client_1.expectString)(output.policyDocument),
        policyName: (0, smithy_client_1.expectString)(output.policyName),
    };
};
const deserializeAws_json1_1ResultField = (output, context) => {
    return {
        field: (0, smithy_client_1.expectString)(output.field),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1ResultRows = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ResultField(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1SearchedLogStream = (output, context) => {
    return {
        logStreamName: (0, smithy_client_1.expectString)(output.logStreamName),
        searchedCompletely: (0, smithy_client_1.expectBoolean)(output.searchedCompletely),
    };
};
const deserializeAws_json1_1SearchedLogStreams = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SearchedLogStream(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ServiceUnavailableException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1StartQueryResponse = (output, context) => {
    return {
        queryId: (0, smithy_client_1.expectString)(output.queryId),
    };
};
const deserializeAws_json1_1StopQueryResponse = (output, context) => {
    return {
        success: (0, smithy_client_1.expectBoolean)(output.success),
    };
};
const deserializeAws_json1_1SubscriptionFilter = (output, context) => {
    return {
        creationTime: (0, smithy_client_1.expectLong)(output.creationTime),
        destinationArn: (0, smithy_client_1.expectString)(output.destinationArn),
        distribution: (0, smithy_client_1.expectString)(output.distribution),
        filterName: (0, smithy_client_1.expectString)(output.filterName),
        filterPattern: (0, smithy_client_1.expectString)(output.filterPattern),
        logGroupName: (0, smithy_client_1.expectString)(output.logGroupName),
        roleArn: (0, smithy_client_1.expectString)(output.roleArn),
    };
};
const deserializeAws_json1_1SubscriptionFilters = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SubscriptionFilter(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Tags = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1TestMetricFilterResponse = (output, context) => {
    return {
        matches: output.matches != null ? deserializeAws_json1_1MetricFilterMatches(output.matches, context) : undefined,
    };
};
const deserializeAws_json1_1TooManyTagsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
        resourceName: (0, smithy_client_1.expectString)(output.resourceName),
    };
};
const deserializeAws_json1_1UnrecognizedClientException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 29879:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(62001));
const client_sts_1 = __nccwpck_require__(52209);
const config_resolver_1 = __nccwpck_require__(56153);
const credential_provider_node_1 = __nccwpck_require__(75531);
const hash_node_1 = __nccwpck_require__(97442);
const middleware_retry_1 = __nccwpck_require__(96064);
const node_config_provider_1 = __nccwpck_require__(87684);
const node_http_handler_1 = __nccwpck_require__(68805);
const util_body_length_node_1 = __nccwpck_require__(74147);
const util_retry_1 = __nccwpck_require__(99395);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const util_utf8_node_1 = __nccwpck_require__(66278);
const runtimeConfig_shared_1 = __nccwpck_require__(89485);
const smithy_client_1 = __nccwpck_require__(4963);
const util_defaults_mode_node_1 = __nccwpck_require__(74243);
const smithy_client_2 = __nccwpck_require__(4963);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        utf8Decoder: config?.utf8Decoder ?? util_utf8_node_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_node_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 89485:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const url_parser_1 = __nccwpck_require__(2992);
const util_base64_1 = __nccwpck_require__(97727);
const endpointResolver_1 = __nccwpck_require__(49488);
const getRuntimeConfig = (config) => ({
    apiVersion: "2014-03-28",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "CloudWatch Logs",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 19923:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeDeploy = void 0;
const CodeDeployClient_1 = __nccwpck_require__(92794);
const AddTagsToOnPremisesInstancesCommand_1 = __nccwpck_require__(92207);
const BatchGetApplicationRevisionsCommand_1 = __nccwpck_require__(12045);
const BatchGetApplicationsCommand_1 = __nccwpck_require__(13211);
const BatchGetDeploymentGroupsCommand_1 = __nccwpck_require__(23865);
const BatchGetDeploymentInstancesCommand_1 = __nccwpck_require__(16959);
const BatchGetDeploymentsCommand_1 = __nccwpck_require__(20970);
const BatchGetDeploymentTargetsCommand_1 = __nccwpck_require__(33965);
const BatchGetOnPremisesInstancesCommand_1 = __nccwpck_require__(27587);
const ContinueDeploymentCommand_1 = __nccwpck_require__(28871);
const CreateApplicationCommand_1 = __nccwpck_require__(7688);
const CreateDeploymentCommand_1 = __nccwpck_require__(53205);
const CreateDeploymentConfigCommand_1 = __nccwpck_require__(28445);
const CreateDeploymentGroupCommand_1 = __nccwpck_require__(19190);
const DeleteApplicationCommand_1 = __nccwpck_require__(90119);
const DeleteDeploymentConfigCommand_1 = __nccwpck_require__(50767);
const DeleteDeploymentGroupCommand_1 = __nccwpck_require__(41705);
const DeleteGitHubAccountTokenCommand_1 = __nccwpck_require__(46507);
const DeleteResourcesByExternalIdCommand_1 = __nccwpck_require__(83859);
const DeregisterOnPremisesInstanceCommand_1 = __nccwpck_require__(69244);
const GetApplicationCommand_1 = __nccwpck_require__(34607);
const GetApplicationRevisionCommand_1 = __nccwpck_require__(39391);
const GetDeploymentCommand_1 = __nccwpck_require__(87255);
const GetDeploymentConfigCommand_1 = __nccwpck_require__(75700);
const GetDeploymentGroupCommand_1 = __nccwpck_require__(39256);
const GetDeploymentInstanceCommand_1 = __nccwpck_require__(95473);
const GetDeploymentTargetCommand_1 = __nccwpck_require__(14737);
const GetOnPremisesInstanceCommand_1 = __nccwpck_require__(80588);
const ListApplicationRevisionsCommand_1 = __nccwpck_require__(38276);
const ListApplicationsCommand_1 = __nccwpck_require__(58039);
const ListDeploymentConfigsCommand_1 = __nccwpck_require__(97097);
const ListDeploymentGroupsCommand_1 = __nccwpck_require__(29744);
const ListDeploymentInstancesCommand_1 = __nccwpck_require__(30549);
const ListDeploymentsCommand_1 = __nccwpck_require__(46851);
const ListDeploymentTargetsCommand_1 = __nccwpck_require__(65291);
const ListGitHubAccountTokenNamesCommand_1 = __nccwpck_require__(17884);
const ListOnPremisesInstancesCommand_1 = __nccwpck_require__(90794);
const ListTagsForResourceCommand_1 = __nccwpck_require__(61685);
const PutLifecycleEventHookExecutionStatusCommand_1 = __nccwpck_require__(27453);
const RegisterApplicationRevisionCommand_1 = __nccwpck_require__(32714);
const RegisterOnPremisesInstanceCommand_1 = __nccwpck_require__(44359);
const RemoveTagsFromOnPremisesInstancesCommand_1 = __nccwpck_require__(2645);
const SkipWaitTimeForInstanceTerminationCommand_1 = __nccwpck_require__(26879);
const StopDeploymentCommand_1 = __nccwpck_require__(71348);
const TagResourceCommand_1 = __nccwpck_require__(39162);
const UntagResourceCommand_1 = __nccwpck_require__(60875);
const UpdateApplicationCommand_1 = __nccwpck_require__(39989);
const UpdateDeploymentGroupCommand_1 = __nccwpck_require__(82746);
class CodeDeploy extends CodeDeployClient_1.CodeDeployClient {
    addTagsToOnPremisesInstances(args, optionsOrCb, cb) {
        const command = new AddTagsToOnPremisesInstancesCommand_1.AddTagsToOnPremisesInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGetApplicationRevisions(args, optionsOrCb, cb) {
        const command = new BatchGetApplicationRevisionsCommand_1.BatchGetApplicationRevisionsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGetApplications(args, optionsOrCb, cb) {
        const command = new BatchGetApplicationsCommand_1.BatchGetApplicationsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGetDeploymentGroups(args, optionsOrCb, cb) {
        const command = new BatchGetDeploymentGroupsCommand_1.BatchGetDeploymentGroupsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGetDeploymentInstances(args, optionsOrCb, cb) {
        const command = new BatchGetDeploymentInstancesCommand_1.BatchGetDeploymentInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGetDeployments(args, optionsOrCb, cb) {
        const command = new BatchGetDeploymentsCommand_1.BatchGetDeploymentsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGetDeploymentTargets(args, optionsOrCb, cb) {
        const command = new BatchGetDeploymentTargetsCommand_1.BatchGetDeploymentTargetsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    batchGetOnPremisesInstances(args, optionsOrCb, cb) {
        const command = new BatchGetOnPremisesInstancesCommand_1.BatchGetOnPremisesInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    continueDeployment(args, optionsOrCb, cb) {
        const command = new ContinueDeploymentCommand_1.ContinueDeploymentCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createApplication(args, optionsOrCb, cb) {
        const command = new CreateApplicationCommand_1.CreateApplicationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createDeployment(args, optionsOrCb, cb) {
        const command = new CreateDeploymentCommand_1.CreateDeploymentCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createDeploymentConfig(args, optionsOrCb, cb) {
        const command = new CreateDeploymentConfigCommand_1.CreateDeploymentConfigCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createDeploymentGroup(args, optionsOrCb, cb) {
        const command = new CreateDeploymentGroupCommand_1.CreateDeploymentGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteApplication(args, optionsOrCb, cb) {
        const command = new DeleteApplicationCommand_1.DeleteApplicationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteDeploymentConfig(args, optionsOrCb, cb) {
        const command = new DeleteDeploymentConfigCommand_1.DeleteDeploymentConfigCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteDeploymentGroup(args, optionsOrCb, cb) {
        const command = new DeleteDeploymentGroupCommand_1.DeleteDeploymentGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteGitHubAccountToken(args, optionsOrCb, cb) {
        const command = new DeleteGitHubAccountTokenCommand_1.DeleteGitHubAccountTokenCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteResourcesByExternalId(args, optionsOrCb, cb) {
        const command = new DeleteResourcesByExternalIdCommand_1.DeleteResourcesByExternalIdCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deregisterOnPremisesInstance(args, optionsOrCb, cb) {
        const command = new DeregisterOnPremisesInstanceCommand_1.DeregisterOnPremisesInstanceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getApplication(args, optionsOrCb, cb) {
        const command = new GetApplicationCommand_1.GetApplicationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getApplicationRevision(args, optionsOrCb, cb) {
        const command = new GetApplicationRevisionCommand_1.GetApplicationRevisionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getDeployment(args, optionsOrCb, cb) {
        const command = new GetDeploymentCommand_1.GetDeploymentCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getDeploymentConfig(args, optionsOrCb, cb) {
        const command = new GetDeploymentConfigCommand_1.GetDeploymentConfigCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getDeploymentGroup(args, optionsOrCb, cb) {
        const command = new GetDeploymentGroupCommand_1.GetDeploymentGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getDeploymentInstance(args, optionsOrCb, cb) {
        const command = new GetDeploymentInstanceCommand_1.GetDeploymentInstanceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getDeploymentTarget(args, optionsOrCb, cb) {
        const command = new GetDeploymentTargetCommand_1.GetDeploymentTargetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getOnPremisesInstance(args, optionsOrCb, cb) {
        const command = new GetOnPremisesInstanceCommand_1.GetOnPremisesInstanceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listApplicationRevisions(args, optionsOrCb, cb) {
        const command = new ListApplicationRevisionsCommand_1.ListApplicationRevisionsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listApplications(args, optionsOrCb, cb) {
        const command = new ListApplicationsCommand_1.ListApplicationsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listDeploymentConfigs(args, optionsOrCb, cb) {
        const command = new ListDeploymentConfigsCommand_1.ListDeploymentConfigsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listDeploymentGroups(args, optionsOrCb, cb) {
        const command = new ListDeploymentGroupsCommand_1.ListDeploymentGroupsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listDeploymentInstances(args, optionsOrCb, cb) {
        const command = new ListDeploymentInstancesCommand_1.ListDeploymentInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listDeployments(args, optionsOrCb, cb) {
        const command = new ListDeploymentsCommand_1.ListDeploymentsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listDeploymentTargets(args, optionsOrCb, cb) {
        const command = new ListDeploymentTargetsCommand_1.ListDeploymentTargetsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listGitHubAccountTokenNames(args, optionsOrCb, cb) {
        const command = new ListGitHubAccountTokenNamesCommand_1.ListGitHubAccountTokenNamesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listOnPremisesInstances(args, optionsOrCb, cb) {
        const command = new ListOnPremisesInstancesCommand_1.ListOnPremisesInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listTagsForResource(args, optionsOrCb, cb) {
        const command = new ListTagsForResourceCommand_1.ListTagsForResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putLifecycleEventHookExecutionStatus(args, optionsOrCb, cb) {
        const command = new PutLifecycleEventHookExecutionStatusCommand_1.PutLifecycleEventHookExecutionStatusCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    registerApplicationRevision(args, optionsOrCb, cb) {
        const command = new RegisterApplicationRevisionCommand_1.RegisterApplicationRevisionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    registerOnPremisesInstance(args, optionsOrCb, cb) {
        const command = new RegisterOnPremisesInstanceCommand_1.RegisterOnPremisesInstanceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    removeTagsFromOnPremisesInstances(args, optionsOrCb, cb) {
        const command = new RemoveTagsFromOnPremisesInstancesCommand_1.RemoveTagsFromOnPremisesInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    skipWaitTimeForInstanceTermination(args, optionsOrCb, cb) {
        const command = new SkipWaitTimeForInstanceTerminationCommand_1.SkipWaitTimeForInstanceTerminationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    stopDeployment(args, optionsOrCb, cb) {
        const command = new StopDeploymentCommand_1.StopDeploymentCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    tagResource(args, optionsOrCb, cb) {
        const command = new TagResourceCommand_1.TagResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    untagResource(args, optionsOrCb, cb) {
        const command = new UntagResourceCommand_1.UntagResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateApplication(args, optionsOrCb, cb) {
        const command = new UpdateApplicationCommand_1.UpdateApplicationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateDeploymentGroup(args, optionsOrCb, cb) {
        const command = new UpdateDeploymentGroupCommand_1.UpdateDeploymentGroupCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
}
exports.CodeDeploy = CodeDeploy;


/***/ }),

/***/ 92794:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeDeployClient = void 0;
const config_resolver_1 = __nccwpck_require__(56153);
const middleware_content_length_1 = __nccwpck_require__(42245);
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_retry_1 = __nccwpck_require__(96064);
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const smithy_client_1 = __nccwpck_require__(4963);
const EndpointParameters_1 = __nccwpck_require__(90342);
const runtimeConfig_1 = __nccwpck_require__(23271);
class CodeDeployClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.CodeDeployClient = CodeDeployClient;


/***/ }),

/***/ 92207:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddTagsToOnPremisesInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class AddTagsToOnPremisesInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AddTagsToOnPremisesInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "AddTagsToOnPremisesInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AddTagsToOnPremisesInstancesInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1AddTagsToOnPremisesInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1AddTagsToOnPremisesInstancesCommand)(output, context);
    }
}
exports.AddTagsToOnPremisesInstancesCommand = AddTagsToOnPremisesInstancesCommand;


/***/ }),

/***/ 12045:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetApplicationRevisionsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class BatchGetApplicationRevisionsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetApplicationRevisionsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "BatchGetApplicationRevisionsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.BatchGetApplicationRevisionsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.BatchGetApplicationRevisionsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1BatchGetApplicationRevisionsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1BatchGetApplicationRevisionsCommand)(output, context);
    }
}
exports.BatchGetApplicationRevisionsCommand = BatchGetApplicationRevisionsCommand;


/***/ }),

/***/ 13211:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetApplicationsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class BatchGetApplicationsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetApplicationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "BatchGetApplicationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.BatchGetApplicationsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.BatchGetApplicationsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1BatchGetApplicationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1BatchGetApplicationsCommand)(output, context);
    }
}
exports.BatchGetApplicationsCommand = BatchGetApplicationsCommand;


/***/ }),

/***/ 23865:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetDeploymentGroupsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class BatchGetDeploymentGroupsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetDeploymentGroupsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "BatchGetDeploymentGroupsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.BatchGetDeploymentGroupsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.BatchGetDeploymentGroupsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1BatchGetDeploymentGroupsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1BatchGetDeploymentGroupsCommand)(output, context);
    }
}
exports.BatchGetDeploymentGroupsCommand = BatchGetDeploymentGroupsCommand;


/***/ }),

/***/ 16959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetDeploymentInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class BatchGetDeploymentInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetDeploymentInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "BatchGetDeploymentInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.BatchGetDeploymentInstancesInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.BatchGetDeploymentInstancesOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1BatchGetDeploymentInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1BatchGetDeploymentInstancesCommand)(output, context);
    }
}
exports.BatchGetDeploymentInstancesCommand = BatchGetDeploymentInstancesCommand;


/***/ }),

/***/ 33965:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetDeploymentTargetsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class BatchGetDeploymentTargetsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetDeploymentTargetsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "BatchGetDeploymentTargetsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.BatchGetDeploymentTargetsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.BatchGetDeploymentTargetsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1BatchGetDeploymentTargetsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1BatchGetDeploymentTargetsCommand)(output, context);
    }
}
exports.BatchGetDeploymentTargetsCommand = BatchGetDeploymentTargetsCommand;


/***/ }),

/***/ 20970:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetDeploymentsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class BatchGetDeploymentsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetDeploymentsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "BatchGetDeploymentsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.BatchGetDeploymentsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.BatchGetDeploymentsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1BatchGetDeploymentsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1BatchGetDeploymentsCommand)(output, context);
    }
}
exports.BatchGetDeploymentsCommand = BatchGetDeploymentsCommand;


/***/ }),

/***/ 27587:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchGetOnPremisesInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class BatchGetOnPremisesInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, BatchGetOnPremisesInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "BatchGetOnPremisesInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.BatchGetOnPremisesInstancesInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.BatchGetOnPremisesInstancesOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1BatchGetOnPremisesInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1BatchGetOnPremisesInstancesCommand)(output, context);
    }
}
exports.BatchGetOnPremisesInstancesCommand = BatchGetOnPremisesInstancesCommand;


/***/ }),

/***/ 28871:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContinueDeploymentCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ContinueDeploymentCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ContinueDeploymentCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ContinueDeploymentCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ContinueDeploymentInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ContinueDeploymentCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ContinueDeploymentCommand)(output, context);
    }
}
exports.ContinueDeploymentCommand = ContinueDeploymentCommand;


/***/ }),

/***/ 7688:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateApplicationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class CreateApplicationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateApplicationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "CreateApplicationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateApplicationInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateApplicationOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateApplicationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateApplicationCommand)(output, context);
    }
}
exports.CreateApplicationCommand = CreateApplicationCommand;


/***/ }),

/***/ 53205:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDeploymentCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class CreateDeploymentCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateDeploymentCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "CreateDeploymentCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateDeploymentInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateDeploymentOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateDeploymentCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateDeploymentCommand)(output, context);
    }
}
exports.CreateDeploymentCommand = CreateDeploymentCommand;


/***/ }),

/***/ 28445:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDeploymentConfigCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class CreateDeploymentConfigCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateDeploymentConfigCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "CreateDeploymentConfigCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateDeploymentConfigInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateDeploymentConfigOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateDeploymentConfigCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateDeploymentConfigCommand)(output, context);
    }
}
exports.CreateDeploymentConfigCommand = CreateDeploymentConfigCommand;


/***/ }),

/***/ 19190:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDeploymentGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class CreateDeploymentGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateDeploymentGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "CreateDeploymentGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateDeploymentGroupInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateDeploymentGroupOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateDeploymentGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateDeploymentGroupCommand)(output, context);
    }
}
exports.CreateDeploymentGroupCommand = CreateDeploymentGroupCommand;


/***/ }),

/***/ 90119:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteApplicationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class DeleteApplicationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteApplicationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "DeleteApplicationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteApplicationInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteApplicationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteApplicationCommand)(output, context);
    }
}
exports.DeleteApplicationCommand = DeleteApplicationCommand;


/***/ }),

/***/ 50767:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDeploymentConfigCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class DeleteDeploymentConfigCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteDeploymentConfigCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "DeleteDeploymentConfigCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteDeploymentConfigInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteDeploymentConfigCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteDeploymentConfigCommand)(output, context);
    }
}
exports.DeleteDeploymentConfigCommand = DeleteDeploymentConfigCommand;


/***/ }),

/***/ 41705:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDeploymentGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class DeleteDeploymentGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteDeploymentGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "DeleteDeploymentGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteDeploymentGroupInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteDeploymentGroupOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteDeploymentGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteDeploymentGroupCommand)(output, context);
    }
}
exports.DeleteDeploymentGroupCommand = DeleteDeploymentGroupCommand;


/***/ }),

/***/ 46507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteGitHubAccountTokenCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class DeleteGitHubAccountTokenCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteGitHubAccountTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "DeleteGitHubAccountTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteGitHubAccountTokenInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteGitHubAccountTokenOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteGitHubAccountTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteGitHubAccountTokenCommand)(output, context);
    }
}
exports.DeleteGitHubAccountTokenCommand = DeleteGitHubAccountTokenCommand;


/***/ }),

/***/ 83859:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteResourcesByExternalIdCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class DeleteResourcesByExternalIdCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteResourcesByExternalIdCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "DeleteResourcesByExternalIdCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteResourcesByExternalIdInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteResourcesByExternalIdOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteResourcesByExternalIdCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteResourcesByExternalIdCommand)(output, context);
    }
}
exports.DeleteResourcesByExternalIdCommand = DeleteResourcesByExternalIdCommand;


/***/ }),

/***/ 69244:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeregisterOnPremisesInstanceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class DeregisterOnPremisesInstanceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeregisterOnPremisesInstanceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "DeregisterOnPremisesInstanceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeregisterOnPremisesInstanceInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeregisterOnPremisesInstanceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeregisterOnPremisesInstanceCommand)(output, context);
    }
}
exports.DeregisterOnPremisesInstanceCommand = DeregisterOnPremisesInstanceCommand;


/***/ }),

/***/ 34607:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetApplicationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetApplicationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetApplicationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetApplicationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetApplicationInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetApplicationOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetApplicationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetApplicationCommand)(output, context);
    }
}
exports.GetApplicationCommand = GetApplicationCommand;


/***/ }),

/***/ 39391:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetApplicationRevisionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetApplicationRevisionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetApplicationRevisionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetApplicationRevisionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetApplicationRevisionInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetApplicationRevisionOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetApplicationRevisionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetApplicationRevisionCommand)(output, context);
    }
}
exports.GetApplicationRevisionCommand = GetApplicationRevisionCommand;


/***/ }),

/***/ 87255:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDeploymentCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetDeploymentCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetDeploymentCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetDeploymentCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetDeploymentInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetDeploymentOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetDeploymentCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetDeploymentCommand)(output, context);
    }
}
exports.GetDeploymentCommand = GetDeploymentCommand;


/***/ }),

/***/ 75700:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDeploymentConfigCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetDeploymentConfigCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetDeploymentConfigCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetDeploymentConfigCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetDeploymentConfigInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetDeploymentConfigOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetDeploymentConfigCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetDeploymentConfigCommand)(output, context);
    }
}
exports.GetDeploymentConfigCommand = GetDeploymentConfigCommand;


/***/ }),

/***/ 39256:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDeploymentGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetDeploymentGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetDeploymentGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetDeploymentGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetDeploymentGroupInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetDeploymentGroupOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetDeploymentGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetDeploymentGroupCommand)(output, context);
    }
}
exports.GetDeploymentGroupCommand = GetDeploymentGroupCommand;


/***/ }),

/***/ 95473:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDeploymentInstanceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetDeploymentInstanceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetDeploymentInstanceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetDeploymentInstanceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetDeploymentInstanceInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetDeploymentInstanceOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetDeploymentInstanceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetDeploymentInstanceCommand)(output, context);
    }
}
exports.GetDeploymentInstanceCommand = GetDeploymentInstanceCommand;


/***/ }),

/***/ 14737:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDeploymentTargetCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetDeploymentTargetCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetDeploymentTargetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetDeploymentTargetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetDeploymentTargetInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetDeploymentTargetOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetDeploymentTargetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetDeploymentTargetCommand)(output, context);
    }
}
exports.GetDeploymentTargetCommand = GetDeploymentTargetCommand;


/***/ }),

/***/ 80588:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOnPremisesInstanceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class GetOnPremisesInstanceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetOnPremisesInstanceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "GetOnPremisesInstanceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetOnPremisesInstanceInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetOnPremisesInstanceOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetOnPremisesInstanceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetOnPremisesInstanceCommand)(output, context);
    }
}
exports.GetOnPremisesInstanceCommand = GetOnPremisesInstanceCommand;


/***/ }),

/***/ 38276:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListApplicationRevisionsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListApplicationRevisionsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListApplicationRevisionsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListApplicationRevisionsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListApplicationRevisionsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListApplicationRevisionsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListApplicationRevisionsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListApplicationRevisionsCommand)(output, context);
    }
}
exports.ListApplicationRevisionsCommand = ListApplicationRevisionsCommand;


/***/ }),

/***/ 58039:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListApplicationsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListApplicationsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListApplicationsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListApplicationsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListApplicationsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListApplicationsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListApplicationsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListApplicationsCommand)(output, context);
    }
}
exports.ListApplicationsCommand = ListApplicationsCommand;


/***/ }),

/***/ 97097:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDeploymentConfigsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListDeploymentConfigsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListDeploymentConfigsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListDeploymentConfigsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListDeploymentConfigsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListDeploymentConfigsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListDeploymentConfigsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListDeploymentConfigsCommand)(output, context);
    }
}
exports.ListDeploymentConfigsCommand = ListDeploymentConfigsCommand;


/***/ }),

/***/ 29744:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDeploymentGroupsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListDeploymentGroupsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListDeploymentGroupsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListDeploymentGroupsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListDeploymentGroupsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListDeploymentGroupsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListDeploymentGroupsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListDeploymentGroupsCommand)(output, context);
    }
}
exports.ListDeploymentGroupsCommand = ListDeploymentGroupsCommand;


/***/ }),

/***/ 30549:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDeploymentInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListDeploymentInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListDeploymentInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListDeploymentInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListDeploymentInstancesInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListDeploymentInstancesOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListDeploymentInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListDeploymentInstancesCommand)(output, context);
    }
}
exports.ListDeploymentInstancesCommand = ListDeploymentInstancesCommand;


/***/ }),

/***/ 65291:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDeploymentTargetsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListDeploymentTargetsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListDeploymentTargetsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListDeploymentTargetsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListDeploymentTargetsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListDeploymentTargetsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListDeploymentTargetsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListDeploymentTargetsCommand)(output, context);
    }
}
exports.ListDeploymentTargetsCommand = ListDeploymentTargetsCommand;


/***/ }),

/***/ 46851:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDeploymentsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListDeploymentsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListDeploymentsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListDeploymentsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListDeploymentsInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListDeploymentsOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListDeploymentsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListDeploymentsCommand)(output, context);
    }
}
exports.ListDeploymentsCommand = ListDeploymentsCommand;


/***/ }),

/***/ 17884:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListGitHubAccountTokenNamesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListGitHubAccountTokenNamesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListGitHubAccountTokenNamesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListGitHubAccountTokenNamesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListGitHubAccountTokenNamesInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListGitHubAccountTokenNamesOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListGitHubAccountTokenNamesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListGitHubAccountTokenNamesCommand)(output, context);
    }
}
exports.ListGitHubAccountTokenNamesCommand = ListGitHubAccountTokenNamesCommand;


/***/ }),

/***/ 90794:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListOnPremisesInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListOnPremisesInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListOnPremisesInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListOnPremisesInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListOnPremisesInstancesInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListOnPremisesInstancesOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListOnPremisesInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListOnPremisesInstancesCommand)(output, context);
    }
}
exports.ListOnPremisesInstancesCommand = ListOnPremisesInstancesCommand;


/***/ }),

/***/ 61685:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTagsForResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class ListTagsForResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTagsForResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "ListTagsForResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListTagsForResourceInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListTagsForResourceOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListTagsForResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListTagsForResourceCommand)(output, context);
    }
}
exports.ListTagsForResourceCommand = ListTagsForResourceCommand;


/***/ }),

/***/ 27453:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutLifecycleEventHookExecutionStatusCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class PutLifecycleEventHookExecutionStatusCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutLifecycleEventHookExecutionStatusCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "PutLifecycleEventHookExecutionStatusCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutLifecycleEventHookExecutionStatusInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutLifecycleEventHookExecutionStatusOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand)(output, context);
    }
}
exports.PutLifecycleEventHookExecutionStatusCommand = PutLifecycleEventHookExecutionStatusCommand;


/***/ }),

/***/ 32714:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterApplicationRevisionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class RegisterApplicationRevisionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RegisterApplicationRevisionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "RegisterApplicationRevisionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RegisterApplicationRevisionInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1RegisterApplicationRevisionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1RegisterApplicationRevisionCommand)(output, context);
    }
}
exports.RegisterApplicationRevisionCommand = RegisterApplicationRevisionCommand;


/***/ }),

/***/ 44359:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterOnPremisesInstanceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class RegisterOnPremisesInstanceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RegisterOnPremisesInstanceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "RegisterOnPremisesInstanceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RegisterOnPremisesInstanceInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1RegisterOnPremisesInstanceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1RegisterOnPremisesInstanceCommand)(output, context);
    }
}
exports.RegisterOnPremisesInstanceCommand = RegisterOnPremisesInstanceCommand;


/***/ }),

/***/ 2645:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveTagsFromOnPremisesInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class RemoveTagsFromOnPremisesInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RemoveTagsFromOnPremisesInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "RemoveTagsFromOnPremisesInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RemoveTagsFromOnPremisesInstancesInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand)(output, context);
    }
}
exports.RemoveTagsFromOnPremisesInstancesCommand = RemoveTagsFromOnPremisesInstancesCommand;


/***/ }),

/***/ 26879:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkipWaitTimeForInstanceTerminationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class SkipWaitTimeForInstanceTerminationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SkipWaitTimeForInstanceTerminationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "SkipWaitTimeForInstanceTerminationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.SkipWaitTimeForInstanceTerminationInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand)(output, context);
    }
}
exports.SkipWaitTimeForInstanceTerminationCommand = SkipWaitTimeForInstanceTerminationCommand;


/***/ }),

/***/ 71348:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StopDeploymentCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class StopDeploymentCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StopDeploymentCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "StopDeploymentCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.StopDeploymentInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.StopDeploymentOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1StopDeploymentCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1StopDeploymentCommand)(output, context);
    }
}
exports.StopDeploymentCommand = StopDeploymentCommand;


/***/ }),

/***/ 39162:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class TagResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "TagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.TagResourceInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.TagResourceOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1TagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1TagResourceCommand)(output, context);
    }
}
exports.TagResourceCommand = TagResourceCommand;


/***/ }),

/***/ 60875:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class UntagResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "UntagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UntagResourceInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UntagResourceOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UntagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UntagResourceCommand)(output, context);
    }
}
exports.UntagResourceCommand = UntagResourceCommand;


/***/ }),

/***/ 39989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateApplicationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class UpdateApplicationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateApplicationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "UpdateApplicationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateApplicationInputFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateApplicationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateApplicationCommand)(output, context);
    }
}
exports.UpdateApplicationCommand = UpdateApplicationCommand;


/***/ }),

/***/ 82746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateDeploymentGroupCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(70579);
const Aws_json1_1_1 = __nccwpck_require__(72093);
class UpdateDeploymentGroupCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateDeploymentGroupCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CodeDeployClient";
        const commandName = "UpdateDeploymentGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateDeploymentGroupInputFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateDeploymentGroupOutputFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateDeploymentGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateDeploymentGroupCommand)(output, context);
    }
}
exports.UpdateDeploymentGroupCommand = UpdateDeploymentGroupCommand;


/***/ }),

/***/ 52783:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(92207), exports);
tslib_1.__exportStar(__nccwpck_require__(12045), exports);
tslib_1.__exportStar(__nccwpck_require__(13211), exports);
tslib_1.__exportStar(__nccwpck_require__(23865), exports);
tslib_1.__exportStar(__nccwpck_require__(16959), exports);
tslib_1.__exportStar(__nccwpck_require__(33965), exports);
tslib_1.__exportStar(__nccwpck_require__(20970), exports);
tslib_1.__exportStar(__nccwpck_require__(27587), exports);
tslib_1.__exportStar(__nccwpck_require__(28871), exports);
tslib_1.__exportStar(__nccwpck_require__(7688), exports);
tslib_1.__exportStar(__nccwpck_require__(53205), exports);
tslib_1.__exportStar(__nccwpck_require__(28445), exports);
tslib_1.__exportStar(__nccwpck_require__(19190), exports);
tslib_1.__exportStar(__nccwpck_require__(90119), exports);
tslib_1.__exportStar(__nccwpck_require__(50767), exports);
tslib_1.__exportStar(__nccwpck_require__(41705), exports);
tslib_1.__exportStar(__nccwpck_require__(46507), exports);
tslib_1.__exportStar(__nccwpck_require__(83859), exports);
tslib_1.__exportStar(__nccwpck_require__(69244), exports);
tslib_1.__exportStar(__nccwpck_require__(34607), exports);
tslib_1.__exportStar(__nccwpck_require__(39391), exports);
tslib_1.__exportStar(__nccwpck_require__(87255), exports);
tslib_1.__exportStar(__nccwpck_require__(75700), exports);
tslib_1.__exportStar(__nccwpck_require__(39256), exports);
tslib_1.__exportStar(__nccwpck_require__(95473), exports);
tslib_1.__exportStar(__nccwpck_require__(14737), exports);
tslib_1.__exportStar(__nccwpck_require__(80588), exports);
tslib_1.__exportStar(__nccwpck_require__(38276), exports);
tslib_1.__exportStar(__nccwpck_require__(58039), exports);
tslib_1.__exportStar(__nccwpck_require__(97097), exports);
tslib_1.__exportStar(__nccwpck_require__(29744), exports);
tslib_1.__exportStar(__nccwpck_require__(30549), exports);
tslib_1.__exportStar(__nccwpck_require__(65291), exports);
tslib_1.__exportStar(__nccwpck_require__(46851), exports);
tslib_1.__exportStar(__nccwpck_require__(17884), exports);
tslib_1.__exportStar(__nccwpck_require__(90794), exports);
tslib_1.__exportStar(__nccwpck_require__(61685), exports);
tslib_1.__exportStar(__nccwpck_require__(27453), exports);
tslib_1.__exportStar(__nccwpck_require__(32714), exports);
tslib_1.__exportStar(__nccwpck_require__(44359), exports);
tslib_1.__exportStar(__nccwpck_require__(2645), exports);
tslib_1.__exportStar(__nccwpck_require__(26879), exports);
tslib_1.__exportStar(__nccwpck_require__(71348), exports);
tslib_1.__exportStar(__nccwpck_require__(39162), exports);
tslib_1.__exportStar(__nccwpck_require__(60875), exports);
tslib_1.__exportStar(__nccwpck_require__(39989), exports);
tslib_1.__exportStar(__nccwpck_require__(82746), exports);


/***/ }),

/***/ 90342:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "codedeploy",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 15124:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(77596);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 77596:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const p = "required", q = "fn", r = "argv", s = "ref";
const a = "PartitionResult", b = "tree", c = "error", d = "endpoint", e = { [p]: false, "type": "String" }, f = { [p]: true, "default": false, "type": "Boolean" }, g = { [s]: "Endpoint" }, h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] }, i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] }, j = {}, k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] }, l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] }, m = [g], n = [h], o = [i];
const _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://codedeploy-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://codedeploy-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://codedeploy.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://codedeploy.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 26692:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeDeployServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(19923), exports);
tslib_1.__exportStar(__nccwpck_require__(92794), exports);
tslib_1.__exportStar(__nccwpck_require__(52783), exports);
tslib_1.__exportStar(__nccwpck_require__(74835), exports);
tslib_1.__exportStar(__nccwpck_require__(20887), exports);
tslib_1.__exportStar(__nccwpck_require__(18924), exports);
var CodeDeployServiceException_1 = __nccwpck_require__(20635);
Object.defineProperty(exports, "CodeDeployServiceException", ({ enumerable: true, get: function () { return CodeDeployServiceException_1.CodeDeployServiceException; } }));


/***/ }),

/***/ 20635:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeDeployServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
class CodeDeployServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, CodeDeployServiceException.prototype);
    }
}
exports.CodeDeployServiceException = CodeDeployServiceException;


/***/ }),

/***/ 74835:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(70579), exports);


/***/ }),

/***/ 70579:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TargetLabel = exports.DeploymentTargetType = exports.TargetStatus = exports.FileExistsBehavior = exports.ErrorCode = exports.DeploymentCreator = exports.InvalidDeploymentIdException = exports.InvalidComputePlatformException = exports.InstanceIdRequiredException = exports.DeploymentIdRequiredException = exports.DeploymentDoesNotExistException = exports.InstanceStatus = exports.LifecycleEventStatus = exports.LifecycleErrorCode = exports._InstanceType = exports.InvalidDeploymentGroupNameException = exports.DeploymentGroupNameRequiredException = exports.DeploymentConfigDoesNotExistException = exports.TriggerEventType = exports.OutdatedInstancesStrategy = exports.TagFilterType = exports.DeploymentStatus = exports.EC2TagFilterType = exports.DeploymentType = exports.DeploymentOption = exports.InstanceAction = exports.GreenFleetProvisioningAction = exports.DeploymentReadyAction = exports.RevisionRequiredException = exports.InvalidRevisionException = exports.InvalidApplicationNameException = exports.BatchLimitExceededException = exports.BundleType = exports.RevisionLocationType = exports.AutoRollbackEvent = exports.ArnNotSupportedException = exports.ApplicationRevisionSortBy = exports.ApplicationNameRequiredException = exports.ApplicationLimitExceededException = exports.ComputePlatform = exports.ApplicationDoesNotExistException = exports.ApplicationAlreadyExistsException = exports.AlarmsLimitExceededException = exports.TagRequiredException = exports.TagLimitExceededException = exports.InvalidTagException = exports.InvalidInstanceNameException = exports.InstanceNotRegisteredException = exports.InstanceNameRequiredException = exports.InstanceLimitExceededException = void 0;
exports.LifecycleHookLimitExceededException = exports.InvalidTriggerConfigException = exports.InvalidTargetGroupPairException = exports.InvalidOnPremisesTagCombinationException = exports.InvalidInputException = exports.InvalidECSServiceException = exports.InvalidEC2TagException = exports.InvalidEC2TagCombinationException = exports.InvalidDeploymentStyleException = exports.InvalidBlueGreenDeploymentConfigurationException = exports.ECSServiceMappingLimitExceededException = exports.DeploymentGroupLimitExceededException = exports.DeploymentGroupAlreadyExistsException = exports.InvalidMinimumHealthyHostValueException = exports.DeploymentConfigNameRequiredException = exports.DeploymentConfigLimitExceededException = exports.DeploymentConfigAlreadyExistsException = exports.TrafficRoutingType = exports.MinimumHealthyHostsType = exports.ThrottlingException = exports.RevisionDoesNotExistException = exports.InvalidUpdateOutdatedInstancesOnlyValueException = exports.InvalidTrafficRoutingConfigurationException = exports.InvalidTargetInstancesException = exports.InvalidRoleException = exports.InvalidLoadBalancerInfoException = exports.InvalidIgnoreApplicationStopFailuresValueException = exports.InvalidGitHubAccountTokenException = exports.InvalidFileExistsBehaviorException = exports.InvalidDeploymentConfigNameException = exports.InvalidAutoScalingGroupException = exports.InvalidAutoRollbackConfigException = exports.InvalidAlarmConfigException = exports.DescriptionTooLongException = exports.DeploymentLimitExceededException = exports.DeploymentGroupDoesNotExistException = exports.InvalidTagsToAddException = exports.UnsupportedActionForDeploymentTypeException = exports.InvalidDeploymentWaitTypeException = exports.InvalidDeploymentStatusException = exports.DeploymentIsNotInReadyStateException = exports.DeploymentAlreadyCompletedException = exports.DeploymentWaitType = exports.BucketNameFilterRequiredException = exports.InvalidDeploymentTargetIdException = exports.InstanceDoesNotExistException = exports.DeploymentTargetListSizeExceededException = exports.DeploymentTargetIdRequiredException = exports.DeploymentTargetDoesNotExistException = exports.DeploymentNotStartedException = void 0;
exports.AutoScalingGroupFilterSensitiveLog = exports.AutoRollbackConfigurationFilterSensitiveLog = exports.AppSpecContentFilterSensitiveLog = exports.ApplicationInfoFilterSensitiveLog = exports.AlarmConfigurationFilterSensitiveLog = exports.AlarmFilterSensitiveLog = exports.AddTagsToOnPremisesInstancesInputFilterSensitiveLog = exports.TagFilterSensitiveLog = exports.StopStatus = exports.MultipleIamArnsProvidedException = exports.InvalidIamUserArnException = exports.InvalidIamSessionArnException = exports.InstanceNameAlreadyRegisteredException = exports.IamUserArnRequiredException = exports.IamUserArnAlreadyRegisteredException = exports.IamSessionArnAlreadyRegisteredException = exports.IamArnRequiredException = exports.LifecycleEventAlreadyCompletedException = exports.InvalidLifecycleEventHookExecutionStatusException = exports.InvalidLifecycleEventHookExecutionIdException = exports.ResourceArnRequiredException = exports.InvalidArnException = exports.RegistrationStatus = exports.InvalidTagFilterException = exports.InvalidRegistrationStatusException = exports.TargetFilterName = exports.InvalidTimeRangeException = exports.InvalidExternalIdException = exports.InvalidTargetFilterNameException = exports.InvalidInstanceTypeException = exports.InvalidInstanceStatusException = exports.InvalidDeploymentInstanceTypeException = exports.SortOrder = exports.ListStateFilterAction = exports.InvalidSortOrderException = exports.InvalidSortByException = exports.InvalidNextTokenException = exports.InvalidKeyPrefixFilterException = exports.InvalidDeployedStateFilterException = exports.InvalidBucketNameFilterException = exports.ResourceValidationException = exports.OperationNotSupportedException = exports.InvalidGitHubAccountTokenNameException = exports.GitHubAccountTokenNameRequiredException = exports.GitHubAccountTokenDoesNotExistException = exports.InvalidOperationException = exports.DeploymentConfigInUseException = exports.TriggerTargetsLimitExceededException = exports.TagSetListLimitExceededException = exports.RoleRequiredException = void 0;
exports.LambdaTargetFilterSensitiveLog = exports.LambdaFunctionInfoFilterSensitiveLog = exports.InstanceTargetFilterSensitiveLog = exports.ECSTargetFilterSensitiveLog = exports.ECSTaskSetFilterSensitiveLog = exports.CloudFormationTargetFilterSensitiveLog = exports.BatchGetDeploymentTargetsInputFilterSensitiveLog = exports.BatchGetDeploymentsOutputFilterSensitiveLog = exports.DeploymentInfoFilterSensitiveLog = exports.TargetInstancesFilterSensitiveLog = exports.RollbackInfoFilterSensitiveLog = exports.RelatedDeploymentsFilterSensitiveLog = exports.ErrorInformationFilterSensitiveLog = exports.DeploymentOverviewFilterSensitiveLog = exports.BatchGetDeploymentsInputFilterSensitiveLog = exports.BatchGetDeploymentInstancesOutputFilterSensitiveLog = exports.InstanceSummaryFilterSensitiveLog = exports.LifecycleEventFilterSensitiveLog = exports.DiagnosticsFilterSensitiveLog = exports.BatchGetDeploymentInstancesInputFilterSensitiveLog = exports.BatchGetDeploymentGroupsOutputFilterSensitiveLog = exports.DeploymentGroupInfoFilterSensitiveLog = exports.TriggerConfigFilterSensitiveLog = exports.OnPremisesTagSetFilterSensitiveLog = exports.TagFilterFilterSensitiveLog = exports.LoadBalancerInfoFilterSensitiveLog = exports.TargetGroupPairInfoFilterSensitiveLog = exports.TrafficRouteFilterSensitiveLog = exports.TargetGroupInfoFilterSensitiveLog = exports.ELBInfoFilterSensitiveLog = exports.LastDeploymentInfoFilterSensitiveLog = exports.ECSServiceFilterSensitiveLog = exports.EC2TagSetFilterSensitiveLog = exports.EC2TagFilterFilterSensitiveLog = exports.DeploymentStyleFilterSensitiveLog = exports.BlueGreenDeploymentConfigurationFilterSensitiveLog = exports.BlueInstanceTerminationOptionFilterSensitiveLog = exports.GreenFleetProvisioningOptionFilterSensitiveLog = exports.DeploymentReadyOptionFilterSensitiveLog = exports.BatchGetDeploymentGroupsInputFilterSensitiveLog = exports.BatchGetApplicationsOutputFilterSensitiveLog = exports.BatchGetApplicationsInputFilterSensitiveLog = exports.BatchGetApplicationRevisionsOutputFilterSensitiveLog = exports.RevisionInfoFilterSensitiveLog = exports.GenericRevisionInfoFilterSensitiveLog = exports.BatchGetApplicationRevisionsInputFilterSensitiveLog = exports.RevisionLocationFilterSensitiveLog = exports.RawStringFilterSensitiveLog = exports.S3LocationFilterSensitiveLog = exports.GitHubLocationFilterSensitiveLog = void 0;
exports.ListDeploymentConfigsOutputFilterSensitiveLog = exports.ListDeploymentConfigsInputFilterSensitiveLog = exports.ListApplicationsOutputFilterSensitiveLog = exports.ListApplicationsInputFilterSensitiveLog = exports.ListApplicationRevisionsOutputFilterSensitiveLog = exports.ListApplicationRevisionsInputFilterSensitiveLog = exports.GetOnPremisesInstanceOutputFilterSensitiveLog = exports.GetOnPremisesInstanceInputFilterSensitiveLog = exports.GetDeploymentTargetOutputFilterSensitiveLog = exports.GetDeploymentTargetInputFilterSensitiveLog = exports.GetDeploymentInstanceOutputFilterSensitiveLog = exports.GetDeploymentInstanceInputFilterSensitiveLog = exports.GetDeploymentGroupOutputFilterSensitiveLog = exports.GetDeploymentGroupInputFilterSensitiveLog = exports.GetDeploymentConfigOutputFilterSensitiveLog = exports.DeploymentConfigInfoFilterSensitiveLog = exports.GetDeploymentConfigInputFilterSensitiveLog = exports.GetDeploymentOutputFilterSensitiveLog = exports.GetDeploymentInputFilterSensitiveLog = exports.GetApplicationRevisionOutputFilterSensitiveLog = exports.GetApplicationRevisionInputFilterSensitiveLog = exports.GetApplicationOutputFilterSensitiveLog = exports.GetApplicationInputFilterSensitiveLog = exports.DeregisterOnPremisesInstanceInputFilterSensitiveLog = exports.DeleteResourcesByExternalIdOutputFilterSensitiveLog = exports.DeleteResourcesByExternalIdInputFilterSensitiveLog = exports.DeleteGitHubAccountTokenOutputFilterSensitiveLog = exports.DeleteGitHubAccountTokenInputFilterSensitiveLog = exports.DeleteDeploymentGroupOutputFilterSensitiveLog = exports.DeleteDeploymentGroupInputFilterSensitiveLog = exports.DeleteDeploymentConfigInputFilterSensitiveLog = exports.DeleteApplicationInputFilterSensitiveLog = exports.CreateDeploymentGroupOutputFilterSensitiveLog = exports.CreateDeploymentGroupInputFilterSensitiveLog = exports.CreateDeploymentConfigOutputFilterSensitiveLog = exports.CreateDeploymentConfigInputFilterSensitiveLog = exports.TrafficRoutingConfigFilterSensitiveLog = exports.TimeBasedLinearFilterSensitiveLog = exports.TimeBasedCanaryFilterSensitiveLog = exports.MinimumHealthyHostsFilterSensitiveLog = exports.CreateDeploymentOutputFilterSensitiveLog = exports.CreateDeploymentInputFilterSensitiveLog = exports.CreateApplicationOutputFilterSensitiveLog = exports.CreateApplicationInputFilterSensitiveLog = exports.ContinueDeploymentInputFilterSensitiveLog = exports.BatchGetOnPremisesInstancesOutputFilterSensitiveLog = exports.InstanceInfoFilterSensitiveLog = exports.BatchGetOnPremisesInstancesInputFilterSensitiveLog = exports.BatchGetDeploymentTargetsOutputFilterSensitiveLog = exports.DeploymentTargetFilterSensitiveLog = void 0;
exports.UpdateDeploymentGroupOutputFilterSensitiveLog = exports.UpdateDeploymentGroupInputFilterSensitiveLog = exports.UpdateApplicationInputFilterSensitiveLog = exports.UntagResourceOutputFilterSensitiveLog = exports.UntagResourceInputFilterSensitiveLog = exports.TagResourceOutputFilterSensitiveLog = exports.TagResourceInputFilterSensitiveLog = exports.StopDeploymentOutputFilterSensitiveLog = exports.StopDeploymentInputFilterSensitiveLog = exports.SkipWaitTimeForInstanceTerminationInputFilterSensitiveLog = exports.RemoveTagsFromOnPremisesInstancesInputFilterSensitiveLog = exports.RegisterOnPremisesInstanceInputFilterSensitiveLog = exports.RegisterApplicationRevisionInputFilterSensitiveLog = exports.PutLifecycleEventHookExecutionStatusOutputFilterSensitiveLog = exports.PutLifecycleEventHookExecutionStatusInputFilterSensitiveLog = exports.ListTagsForResourceOutputFilterSensitiveLog = exports.ListTagsForResourceInputFilterSensitiveLog = exports.ListOnPremisesInstancesOutputFilterSensitiveLog = exports.ListOnPremisesInstancesInputFilterSensitiveLog = exports.ListGitHubAccountTokenNamesOutputFilterSensitiveLog = exports.ListGitHubAccountTokenNamesInputFilterSensitiveLog = exports.ListDeploymentTargetsOutputFilterSensitiveLog = exports.ListDeploymentTargetsInputFilterSensitiveLog = exports.ListDeploymentsOutputFilterSensitiveLog = exports.ListDeploymentsInputFilterSensitiveLog = exports.TimeRangeFilterSensitiveLog = exports.ListDeploymentInstancesOutputFilterSensitiveLog = exports.ListDeploymentInstancesInputFilterSensitiveLog = exports.ListDeploymentGroupsOutputFilterSensitiveLog = exports.ListDeploymentGroupsInputFilterSensitiveLog = void 0;
const CodeDeployServiceException_1 = __nccwpck_require__(20635);
class InstanceLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InstanceLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "InstanceLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InstanceLimitExceededException.prototype);
    }
}
exports.InstanceLimitExceededException = InstanceLimitExceededException;
class InstanceNameRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InstanceNameRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "InstanceNameRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InstanceNameRequiredException.prototype);
    }
}
exports.InstanceNameRequiredException = InstanceNameRequiredException;
class InstanceNotRegisteredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InstanceNotRegisteredException",
            $fault: "client",
            ...opts,
        });
        this.name = "InstanceNotRegisteredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InstanceNotRegisteredException.prototype);
    }
}
exports.InstanceNotRegisteredException = InstanceNotRegisteredException;
class InvalidInstanceNameException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidInstanceNameException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidInstanceNameException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidInstanceNameException.prototype);
    }
}
exports.InvalidInstanceNameException = InvalidInstanceNameException;
class InvalidTagException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTagException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTagException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTagException.prototype);
    }
}
exports.InvalidTagException = InvalidTagException;
class TagLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "TagLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "TagLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TagLimitExceededException.prototype);
    }
}
exports.TagLimitExceededException = TagLimitExceededException;
class TagRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "TagRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "TagRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TagRequiredException.prototype);
    }
}
exports.TagRequiredException = TagRequiredException;
class AlarmsLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "AlarmsLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "AlarmsLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AlarmsLimitExceededException.prototype);
    }
}
exports.AlarmsLimitExceededException = AlarmsLimitExceededException;
class ApplicationAlreadyExistsException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ApplicationAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "ApplicationAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ApplicationAlreadyExistsException.prototype);
    }
}
exports.ApplicationAlreadyExistsException = ApplicationAlreadyExistsException;
class ApplicationDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ApplicationDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "ApplicationDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ApplicationDoesNotExistException.prototype);
    }
}
exports.ApplicationDoesNotExistException = ApplicationDoesNotExistException;
var ComputePlatform;
(function (ComputePlatform) {
    ComputePlatform["ECS"] = "ECS";
    ComputePlatform["LAMBDA"] = "Lambda";
    ComputePlatform["SERVER"] = "Server";
})(ComputePlatform = exports.ComputePlatform || (exports.ComputePlatform = {}));
class ApplicationLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ApplicationLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ApplicationLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ApplicationLimitExceededException.prototype);
    }
}
exports.ApplicationLimitExceededException = ApplicationLimitExceededException;
class ApplicationNameRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ApplicationNameRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "ApplicationNameRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ApplicationNameRequiredException.prototype);
    }
}
exports.ApplicationNameRequiredException = ApplicationNameRequiredException;
var ApplicationRevisionSortBy;
(function (ApplicationRevisionSortBy) {
    ApplicationRevisionSortBy["FirstUsedTime"] = "firstUsedTime";
    ApplicationRevisionSortBy["LastUsedTime"] = "lastUsedTime";
    ApplicationRevisionSortBy["RegisterTime"] = "registerTime";
})(ApplicationRevisionSortBy = exports.ApplicationRevisionSortBy || (exports.ApplicationRevisionSortBy = {}));
class ArnNotSupportedException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ArnNotSupportedException",
            $fault: "client",
            ...opts,
        });
        this.name = "ArnNotSupportedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ArnNotSupportedException.prototype);
    }
}
exports.ArnNotSupportedException = ArnNotSupportedException;
var AutoRollbackEvent;
(function (AutoRollbackEvent) {
    AutoRollbackEvent["DEPLOYMENT_FAILURE"] = "DEPLOYMENT_FAILURE";
    AutoRollbackEvent["DEPLOYMENT_STOP_ON_ALARM"] = "DEPLOYMENT_STOP_ON_ALARM";
    AutoRollbackEvent["DEPLOYMENT_STOP_ON_REQUEST"] = "DEPLOYMENT_STOP_ON_REQUEST";
})(AutoRollbackEvent = exports.AutoRollbackEvent || (exports.AutoRollbackEvent = {}));
var RevisionLocationType;
(function (RevisionLocationType) {
    RevisionLocationType["AppSpecContent"] = "AppSpecContent";
    RevisionLocationType["GitHub"] = "GitHub";
    RevisionLocationType["S3"] = "S3";
    RevisionLocationType["String"] = "String";
})(RevisionLocationType = exports.RevisionLocationType || (exports.RevisionLocationType = {}));
var BundleType;
(function (BundleType) {
    BundleType["JSON"] = "JSON";
    BundleType["Tar"] = "tar";
    BundleType["TarGZip"] = "tgz";
    BundleType["YAML"] = "YAML";
    BundleType["Zip"] = "zip";
})(BundleType = exports.BundleType || (exports.BundleType = {}));
class BatchLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "BatchLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "BatchLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, BatchLimitExceededException.prototype);
    }
}
exports.BatchLimitExceededException = BatchLimitExceededException;
class InvalidApplicationNameException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidApplicationNameException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidApplicationNameException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidApplicationNameException.prototype);
    }
}
exports.InvalidApplicationNameException = InvalidApplicationNameException;
class InvalidRevisionException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidRevisionException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRevisionException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRevisionException.prototype);
    }
}
exports.InvalidRevisionException = InvalidRevisionException;
class RevisionRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "RevisionRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "RevisionRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RevisionRequiredException.prototype);
    }
}
exports.RevisionRequiredException = RevisionRequiredException;
var DeploymentReadyAction;
(function (DeploymentReadyAction) {
    DeploymentReadyAction["CONTINUE_DEPLOYMENT"] = "CONTINUE_DEPLOYMENT";
    DeploymentReadyAction["STOP_DEPLOYMENT"] = "STOP_DEPLOYMENT";
})(DeploymentReadyAction = exports.DeploymentReadyAction || (exports.DeploymentReadyAction = {}));
var GreenFleetProvisioningAction;
(function (GreenFleetProvisioningAction) {
    GreenFleetProvisioningAction["COPY_AUTO_SCALING_GROUP"] = "COPY_AUTO_SCALING_GROUP";
    GreenFleetProvisioningAction["DISCOVER_EXISTING"] = "DISCOVER_EXISTING";
})(GreenFleetProvisioningAction = exports.GreenFleetProvisioningAction || (exports.GreenFleetProvisioningAction = {}));
var InstanceAction;
(function (InstanceAction) {
    InstanceAction["KEEP_ALIVE"] = "KEEP_ALIVE";
    InstanceAction["TERMINATE"] = "TERMINATE";
})(InstanceAction = exports.InstanceAction || (exports.InstanceAction = {}));
var DeploymentOption;
(function (DeploymentOption) {
    DeploymentOption["WITHOUT_TRAFFIC_CONTROL"] = "WITHOUT_TRAFFIC_CONTROL";
    DeploymentOption["WITH_TRAFFIC_CONTROL"] = "WITH_TRAFFIC_CONTROL";
})(DeploymentOption = exports.DeploymentOption || (exports.DeploymentOption = {}));
var DeploymentType;
(function (DeploymentType) {
    DeploymentType["BLUE_GREEN"] = "BLUE_GREEN";
    DeploymentType["IN_PLACE"] = "IN_PLACE";
})(DeploymentType = exports.DeploymentType || (exports.DeploymentType = {}));
var EC2TagFilterType;
(function (EC2TagFilterType) {
    EC2TagFilterType["KEY_AND_VALUE"] = "KEY_AND_VALUE";
    EC2TagFilterType["KEY_ONLY"] = "KEY_ONLY";
    EC2TagFilterType["VALUE_ONLY"] = "VALUE_ONLY";
})(EC2TagFilterType = exports.EC2TagFilterType || (exports.EC2TagFilterType = {}));
var DeploymentStatus;
(function (DeploymentStatus) {
    DeploymentStatus["BAKING"] = "Baking";
    DeploymentStatus["CREATED"] = "Created";
    DeploymentStatus["FAILED"] = "Failed";
    DeploymentStatus["IN_PROGRESS"] = "InProgress";
    DeploymentStatus["QUEUED"] = "Queued";
    DeploymentStatus["READY"] = "Ready";
    DeploymentStatus["STOPPED"] = "Stopped";
    DeploymentStatus["SUCCEEDED"] = "Succeeded";
})(DeploymentStatus = exports.DeploymentStatus || (exports.DeploymentStatus = {}));
var TagFilterType;
(function (TagFilterType) {
    TagFilterType["KEY_AND_VALUE"] = "KEY_AND_VALUE";
    TagFilterType["KEY_ONLY"] = "KEY_ONLY";
    TagFilterType["VALUE_ONLY"] = "VALUE_ONLY";
})(TagFilterType = exports.TagFilterType || (exports.TagFilterType = {}));
var OutdatedInstancesStrategy;
(function (OutdatedInstancesStrategy) {
    OutdatedInstancesStrategy["Ignore"] = "IGNORE";
    OutdatedInstancesStrategy["Update"] = "UPDATE";
})(OutdatedInstancesStrategy = exports.OutdatedInstancesStrategy || (exports.OutdatedInstancesStrategy = {}));
var TriggerEventType;
(function (TriggerEventType) {
    TriggerEventType["DEPLOYMENT_FAILURE"] = "DeploymentFailure";
    TriggerEventType["DEPLOYMENT_READY"] = "DeploymentReady";
    TriggerEventType["DEPLOYMENT_ROLLBACK"] = "DeploymentRollback";
    TriggerEventType["DEPLOYMENT_START"] = "DeploymentStart";
    TriggerEventType["DEPLOYMENT_STOP"] = "DeploymentStop";
    TriggerEventType["DEPLOYMENT_SUCCESS"] = "DeploymentSuccess";
    TriggerEventType["INSTANCE_FAILURE"] = "InstanceFailure";
    TriggerEventType["INSTANCE_READY"] = "InstanceReady";
    TriggerEventType["INSTANCE_START"] = "InstanceStart";
    TriggerEventType["INSTANCE_SUCCESS"] = "InstanceSuccess";
})(TriggerEventType = exports.TriggerEventType || (exports.TriggerEventType = {}));
class DeploymentConfigDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentConfigDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentConfigDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentConfigDoesNotExistException.prototype);
    }
}
exports.DeploymentConfigDoesNotExistException = DeploymentConfigDoesNotExistException;
class DeploymentGroupNameRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentGroupNameRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentGroupNameRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentGroupNameRequiredException.prototype);
    }
}
exports.DeploymentGroupNameRequiredException = DeploymentGroupNameRequiredException;
class InvalidDeploymentGroupNameException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentGroupNameException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentGroupNameException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentGroupNameException.prototype);
    }
}
exports.InvalidDeploymentGroupNameException = InvalidDeploymentGroupNameException;
var _InstanceType;
(function (_InstanceType) {
    _InstanceType["BLUE"] = "Blue";
    _InstanceType["GREEN"] = "Green";
})(_InstanceType = exports._InstanceType || (exports._InstanceType = {}));
var LifecycleErrorCode;
(function (LifecycleErrorCode) {
    LifecycleErrorCode["SCRIPT_FAILED"] = "ScriptFailed";
    LifecycleErrorCode["SCRIPT_MISSING"] = "ScriptMissing";
    LifecycleErrorCode["SCRIPT_NOT_EXECUTABLE"] = "ScriptNotExecutable";
    LifecycleErrorCode["SCRIPT_TIMED_OUT"] = "ScriptTimedOut";
    LifecycleErrorCode["SUCCESS"] = "Success";
    LifecycleErrorCode["UNKNOWN_ERROR"] = "UnknownError";
})(LifecycleErrorCode = exports.LifecycleErrorCode || (exports.LifecycleErrorCode = {}));
var LifecycleEventStatus;
(function (LifecycleEventStatus) {
    LifecycleEventStatus["FAILED"] = "Failed";
    LifecycleEventStatus["IN_PROGRESS"] = "InProgress";
    LifecycleEventStatus["PENDING"] = "Pending";
    LifecycleEventStatus["SKIPPED"] = "Skipped";
    LifecycleEventStatus["SUCCEEDED"] = "Succeeded";
    LifecycleEventStatus["UNKNOWN"] = "Unknown";
})(LifecycleEventStatus = exports.LifecycleEventStatus || (exports.LifecycleEventStatus = {}));
var InstanceStatus;
(function (InstanceStatus) {
    InstanceStatus["FAILED"] = "Failed";
    InstanceStatus["IN_PROGRESS"] = "InProgress";
    InstanceStatus["PENDING"] = "Pending";
    InstanceStatus["READY"] = "Ready";
    InstanceStatus["SKIPPED"] = "Skipped";
    InstanceStatus["SUCCEEDED"] = "Succeeded";
    InstanceStatus["UNKNOWN"] = "Unknown";
})(InstanceStatus = exports.InstanceStatus || (exports.InstanceStatus = {}));
class DeploymentDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentDoesNotExistException.prototype);
    }
}
exports.DeploymentDoesNotExistException = DeploymentDoesNotExistException;
class DeploymentIdRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentIdRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentIdRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentIdRequiredException.prototype);
    }
}
exports.DeploymentIdRequiredException = DeploymentIdRequiredException;
class InstanceIdRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InstanceIdRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "InstanceIdRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InstanceIdRequiredException.prototype);
    }
}
exports.InstanceIdRequiredException = InstanceIdRequiredException;
class InvalidComputePlatformException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidComputePlatformException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidComputePlatformException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidComputePlatformException.prototype);
    }
}
exports.InvalidComputePlatformException = InvalidComputePlatformException;
class InvalidDeploymentIdException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentIdException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentIdException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentIdException.prototype);
    }
}
exports.InvalidDeploymentIdException = InvalidDeploymentIdException;
var DeploymentCreator;
(function (DeploymentCreator) {
    DeploymentCreator["Autoscaling"] = "autoscaling";
    DeploymentCreator["CloudFormation"] = "CloudFormation";
    DeploymentCreator["CloudFormationRollback"] = "CloudFormationRollback";
    DeploymentCreator["CodeDeploy"] = "CodeDeploy";
    DeploymentCreator["CodeDeployAutoUpdate"] = "CodeDeployAutoUpdate";
    DeploymentCreator["CodeDeployRollback"] = "codeDeployRollback";
    DeploymentCreator["User"] = "user";
})(DeploymentCreator = exports.DeploymentCreator || (exports.DeploymentCreator = {}));
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["AGENT_ISSUE"] = "AGENT_ISSUE";
    ErrorCode["ALARM_ACTIVE"] = "ALARM_ACTIVE";
    ErrorCode["APPLICATION_MISSING"] = "APPLICATION_MISSING";
    ErrorCode["AUTOSCALING_VALIDATION_ERROR"] = "AUTOSCALING_VALIDATION_ERROR";
    ErrorCode["AUTO_SCALING_CONFIGURATION"] = "AUTO_SCALING_CONFIGURATION";
    ErrorCode["AUTO_SCALING_IAM_ROLE_PERMISSIONS"] = "AUTO_SCALING_IAM_ROLE_PERMISSIONS";
    ErrorCode["CLOUDFORMATION_STACK_FAILURE"] = "CLOUDFORMATION_STACK_FAILURE";
    ErrorCode["CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND"] = "CODEDEPLOY_RESOURCE_CANNOT_BE_FOUND";
    ErrorCode["CUSTOMER_APPLICATION_UNHEALTHY"] = "CUSTOMER_APPLICATION_UNHEALTHY";
    ErrorCode["DEPLOYMENT_GROUP_MISSING"] = "DEPLOYMENT_GROUP_MISSING";
    ErrorCode["ECS_UPDATE_ERROR"] = "ECS_UPDATE_ERROR";
    ErrorCode["ELASTIC_LOAD_BALANCING_INVALID"] = "ELASTIC_LOAD_BALANCING_INVALID";
    ErrorCode["ELB_INVALID_INSTANCE"] = "ELB_INVALID_INSTANCE";
    ErrorCode["HEALTH_CONSTRAINTS"] = "HEALTH_CONSTRAINTS";
    ErrorCode["HEALTH_CONSTRAINTS_INVALID"] = "HEALTH_CONSTRAINTS_INVALID";
    ErrorCode["HOOK_EXECUTION_FAILURE"] = "HOOK_EXECUTION_FAILURE";
    ErrorCode["IAM_ROLE_MISSING"] = "IAM_ROLE_MISSING";
    ErrorCode["IAM_ROLE_PERMISSIONS"] = "IAM_ROLE_PERMISSIONS";
    ErrorCode["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    ErrorCode["INVALID_ECS_SERVICE"] = "INVALID_ECS_SERVICE";
    ErrorCode["INVALID_LAMBDA_CONFIGURATION"] = "INVALID_LAMBDA_CONFIGURATION";
    ErrorCode["INVALID_LAMBDA_FUNCTION"] = "INVALID_LAMBDA_FUNCTION";
    ErrorCode["INVALID_REVISION"] = "INVALID_REVISION";
    ErrorCode["MANUAL_STOP"] = "MANUAL_STOP";
    ErrorCode["MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION"] = "MISSING_BLUE_GREEN_DEPLOYMENT_CONFIGURATION";
    ErrorCode["MISSING_ELB_INFORMATION"] = "MISSING_ELB_INFORMATION";
    ErrorCode["MISSING_GITHUB_TOKEN"] = "MISSING_GITHUB_TOKEN";
    ErrorCode["NO_EC2_SUBSCRIPTION"] = "NO_EC2_SUBSCRIPTION";
    ErrorCode["NO_INSTANCES"] = "NO_INSTANCES";
    ErrorCode["OVER_MAX_INSTANCES"] = "OVER_MAX_INSTANCES";
    ErrorCode["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
    ErrorCode["REVISION_MISSING"] = "REVISION_MISSING";
    ErrorCode["THROTTLED"] = "THROTTLED";
    ErrorCode["TIMEOUT"] = "TIMEOUT";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
var FileExistsBehavior;
(function (FileExistsBehavior) {
    FileExistsBehavior["DISALLOW"] = "DISALLOW";
    FileExistsBehavior["OVERWRITE"] = "OVERWRITE";
    FileExistsBehavior["RETAIN"] = "RETAIN";
})(FileExistsBehavior = exports.FileExistsBehavior || (exports.FileExistsBehavior = {}));
var TargetStatus;
(function (TargetStatus) {
    TargetStatus["FAILED"] = "Failed";
    TargetStatus["IN_PROGRESS"] = "InProgress";
    TargetStatus["PENDING"] = "Pending";
    TargetStatus["READY"] = "Ready";
    TargetStatus["SKIPPED"] = "Skipped";
    TargetStatus["SUCCEEDED"] = "Succeeded";
    TargetStatus["UNKNOWN"] = "Unknown";
})(TargetStatus = exports.TargetStatus || (exports.TargetStatus = {}));
var DeploymentTargetType;
(function (DeploymentTargetType) {
    DeploymentTargetType["CLOUDFORMATION_TARGET"] = "CloudFormationTarget";
    DeploymentTargetType["ECS_TARGET"] = "ECSTarget";
    DeploymentTargetType["INSTANCE_TARGET"] = "InstanceTarget";
    DeploymentTargetType["LAMBDA_TARGET"] = "LambdaTarget";
})(DeploymentTargetType = exports.DeploymentTargetType || (exports.DeploymentTargetType = {}));
var TargetLabel;
(function (TargetLabel) {
    TargetLabel["BLUE"] = "Blue";
    TargetLabel["GREEN"] = "Green";
})(TargetLabel = exports.TargetLabel || (exports.TargetLabel = {}));
class DeploymentNotStartedException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentNotStartedException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentNotStartedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentNotStartedException.prototype);
    }
}
exports.DeploymentNotStartedException = DeploymentNotStartedException;
class DeploymentTargetDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentTargetDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentTargetDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentTargetDoesNotExistException.prototype);
    }
}
exports.DeploymentTargetDoesNotExistException = DeploymentTargetDoesNotExistException;
class DeploymentTargetIdRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentTargetIdRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentTargetIdRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentTargetIdRequiredException.prototype);
    }
}
exports.DeploymentTargetIdRequiredException = DeploymentTargetIdRequiredException;
class DeploymentTargetListSizeExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentTargetListSizeExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentTargetListSizeExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentTargetListSizeExceededException.prototype);
    }
}
exports.DeploymentTargetListSizeExceededException = DeploymentTargetListSizeExceededException;
class InstanceDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InstanceDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "InstanceDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InstanceDoesNotExistException.prototype);
    }
}
exports.InstanceDoesNotExistException = InstanceDoesNotExistException;
class InvalidDeploymentTargetIdException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentTargetIdException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentTargetIdException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentTargetIdException.prototype);
    }
}
exports.InvalidDeploymentTargetIdException = InvalidDeploymentTargetIdException;
class BucketNameFilterRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "BucketNameFilterRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "BucketNameFilterRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, BucketNameFilterRequiredException.prototype);
    }
}
exports.BucketNameFilterRequiredException = BucketNameFilterRequiredException;
var DeploymentWaitType;
(function (DeploymentWaitType) {
    DeploymentWaitType["READY_WAIT"] = "READY_WAIT";
    DeploymentWaitType["TERMINATION_WAIT"] = "TERMINATION_WAIT";
})(DeploymentWaitType = exports.DeploymentWaitType || (exports.DeploymentWaitType = {}));
class DeploymentAlreadyCompletedException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentAlreadyCompletedException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentAlreadyCompletedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentAlreadyCompletedException.prototype);
    }
}
exports.DeploymentAlreadyCompletedException = DeploymentAlreadyCompletedException;
class DeploymentIsNotInReadyStateException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentIsNotInReadyStateException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentIsNotInReadyStateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentIsNotInReadyStateException.prototype);
    }
}
exports.DeploymentIsNotInReadyStateException = DeploymentIsNotInReadyStateException;
class InvalidDeploymentStatusException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentStatusException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentStatusException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentStatusException.prototype);
    }
}
exports.InvalidDeploymentStatusException = InvalidDeploymentStatusException;
class InvalidDeploymentWaitTypeException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentWaitTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentWaitTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentWaitTypeException.prototype);
    }
}
exports.InvalidDeploymentWaitTypeException = InvalidDeploymentWaitTypeException;
class UnsupportedActionForDeploymentTypeException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedActionForDeploymentTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedActionForDeploymentTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedActionForDeploymentTypeException.prototype);
    }
}
exports.UnsupportedActionForDeploymentTypeException = UnsupportedActionForDeploymentTypeException;
class InvalidTagsToAddException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTagsToAddException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTagsToAddException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTagsToAddException.prototype);
    }
}
exports.InvalidTagsToAddException = InvalidTagsToAddException;
class DeploymentGroupDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentGroupDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentGroupDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentGroupDoesNotExistException.prototype);
    }
}
exports.DeploymentGroupDoesNotExistException = DeploymentGroupDoesNotExistException;
class DeploymentLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentLimitExceededException.prototype);
    }
}
exports.DeploymentLimitExceededException = DeploymentLimitExceededException;
class DescriptionTooLongException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DescriptionTooLongException",
            $fault: "client",
            ...opts,
        });
        this.name = "DescriptionTooLongException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DescriptionTooLongException.prototype);
    }
}
exports.DescriptionTooLongException = DescriptionTooLongException;
class InvalidAlarmConfigException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidAlarmConfigException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAlarmConfigException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAlarmConfigException.prototype);
    }
}
exports.InvalidAlarmConfigException = InvalidAlarmConfigException;
class InvalidAutoRollbackConfigException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidAutoRollbackConfigException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAutoRollbackConfigException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAutoRollbackConfigException.prototype);
    }
}
exports.InvalidAutoRollbackConfigException = InvalidAutoRollbackConfigException;
class InvalidAutoScalingGroupException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidAutoScalingGroupException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAutoScalingGroupException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAutoScalingGroupException.prototype);
    }
}
exports.InvalidAutoScalingGroupException = InvalidAutoScalingGroupException;
class InvalidDeploymentConfigNameException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentConfigNameException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentConfigNameException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentConfigNameException.prototype);
    }
}
exports.InvalidDeploymentConfigNameException = InvalidDeploymentConfigNameException;
class InvalidFileExistsBehaviorException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidFileExistsBehaviorException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidFileExistsBehaviorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidFileExistsBehaviorException.prototype);
    }
}
exports.InvalidFileExistsBehaviorException = InvalidFileExistsBehaviorException;
class InvalidGitHubAccountTokenException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidGitHubAccountTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidGitHubAccountTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidGitHubAccountTokenException.prototype);
    }
}
exports.InvalidGitHubAccountTokenException = InvalidGitHubAccountTokenException;
class InvalidIgnoreApplicationStopFailuresValueException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidIgnoreApplicationStopFailuresValueException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIgnoreApplicationStopFailuresValueException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIgnoreApplicationStopFailuresValueException.prototype);
    }
}
exports.InvalidIgnoreApplicationStopFailuresValueException = InvalidIgnoreApplicationStopFailuresValueException;
class InvalidLoadBalancerInfoException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidLoadBalancerInfoException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidLoadBalancerInfoException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidLoadBalancerInfoException.prototype);
    }
}
exports.InvalidLoadBalancerInfoException = InvalidLoadBalancerInfoException;
class InvalidRoleException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidRoleException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRoleException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRoleException.prototype);
    }
}
exports.InvalidRoleException = InvalidRoleException;
class InvalidTargetInstancesException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTargetInstancesException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTargetInstancesException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTargetInstancesException.prototype);
    }
}
exports.InvalidTargetInstancesException = InvalidTargetInstancesException;
class InvalidTrafficRoutingConfigurationException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTrafficRoutingConfigurationException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTrafficRoutingConfigurationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTrafficRoutingConfigurationException.prototype);
    }
}
exports.InvalidTrafficRoutingConfigurationException = InvalidTrafficRoutingConfigurationException;
class InvalidUpdateOutdatedInstancesOnlyValueException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidUpdateOutdatedInstancesOnlyValueException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidUpdateOutdatedInstancesOnlyValueException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidUpdateOutdatedInstancesOnlyValueException.prototype);
    }
}
exports.InvalidUpdateOutdatedInstancesOnlyValueException = InvalidUpdateOutdatedInstancesOnlyValueException;
class RevisionDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "RevisionDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "RevisionDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RevisionDoesNotExistException.prototype);
    }
}
exports.RevisionDoesNotExistException = RevisionDoesNotExistException;
class ThrottlingException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ThrottlingException",
            $fault: "client",
            ...opts,
        });
        this.name = "ThrottlingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ThrottlingException.prototype);
    }
}
exports.ThrottlingException = ThrottlingException;
var MinimumHealthyHostsType;
(function (MinimumHealthyHostsType) {
    MinimumHealthyHostsType["FLEET_PERCENT"] = "FLEET_PERCENT";
    MinimumHealthyHostsType["HOST_COUNT"] = "HOST_COUNT";
})(MinimumHealthyHostsType = exports.MinimumHealthyHostsType || (exports.MinimumHealthyHostsType = {}));
var TrafficRoutingType;
(function (TrafficRoutingType) {
    TrafficRoutingType["AllAtOnce"] = "AllAtOnce";
    TrafficRoutingType["TimeBasedCanary"] = "TimeBasedCanary";
    TrafficRoutingType["TimeBasedLinear"] = "TimeBasedLinear";
})(TrafficRoutingType = exports.TrafficRoutingType || (exports.TrafficRoutingType = {}));
class DeploymentConfigAlreadyExistsException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentConfigAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentConfigAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentConfigAlreadyExistsException.prototype);
    }
}
exports.DeploymentConfigAlreadyExistsException = DeploymentConfigAlreadyExistsException;
class DeploymentConfigLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentConfigLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentConfigLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentConfigLimitExceededException.prototype);
    }
}
exports.DeploymentConfigLimitExceededException = DeploymentConfigLimitExceededException;
class DeploymentConfigNameRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentConfigNameRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentConfigNameRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentConfigNameRequiredException.prototype);
    }
}
exports.DeploymentConfigNameRequiredException = DeploymentConfigNameRequiredException;
class InvalidMinimumHealthyHostValueException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidMinimumHealthyHostValueException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidMinimumHealthyHostValueException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidMinimumHealthyHostValueException.prototype);
    }
}
exports.InvalidMinimumHealthyHostValueException = InvalidMinimumHealthyHostValueException;
class DeploymentGroupAlreadyExistsException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentGroupAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentGroupAlreadyExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentGroupAlreadyExistsException.prototype);
    }
}
exports.DeploymentGroupAlreadyExistsException = DeploymentGroupAlreadyExistsException;
class DeploymentGroupLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentGroupLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentGroupLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentGroupLimitExceededException.prototype);
    }
}
exports.DeploymentGroupLimitExceededException = DeploymentGroupLimitExceededException;
class ECSServiceMappingLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ECSServiceMappingLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "ECSServiceMappingLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ECSServiceMappingLimitExceededException.prototype);
    }
}
exports.ECSServiceMappingLimitExceededException = ECSServiceMappingLimitExceededException;
class InvalidBlueGreenDeploymentConfigurationException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidBlueGreenDeploymentConfigurationException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidBlueGreenDeploymentConfigurationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidBlueGreenDeploymentConfigurationException.prototype);
    }
}
exports.InvalidBlueGreenDeploymentConfigurationException = InvalidBlueGreenDeploymentConfigurationException;
class InvalidDeploymentStyleException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentStyleException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentStyleException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentStyleException.prototype);
    }
}
exports.InvalidDeploymentStyleException = InvalidDeploymentStyleException;
class InvalidEC2TagCombinationException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidEC2TagCombinationException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidEC2TagCombinationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidEC2TagCombinationException.prototype);
    }
}
exports.InvalidEC2TagCombinationException = InvalidEC2TagCombinationException;
class InvalidEC2TagException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidEC2TagException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidEC2TagException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidEC2TagException.prototype);
    }
}
exports.InvalidEC2TagException = InvalidEC2TagException;
class InvalidECSServiceException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidECSServiceException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidECSServiceException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidECSServiceException.prototype);
    }
}
exports.InvalidECSServiceException = InvalidECSServiceException;
class InvalidInputException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidInputException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidInputException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidInputException.prototype);
    }
}
exports.InvalidInputException = InvalidInputException;
class InvalidOnPremisesTagCombinationException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidOnPremisesTagCombinationException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOnPremisesTagCombinationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOnPremisesTagCombinationException.prototype);
    }
}
exports.InvalidOnPremisesTagCombinationException = InvalidOnPremisesTagCombinationException;
class InvalidTargetGroupPairException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTargetGroupPairException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTargetGroupPairException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTargetGroupPairException.prototype);
    }
}
exports.InvalidTargetGroupPairException = InvalidTargetGroupPairException;
class InvalidTriggerConfigException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTriggerConfigException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTriggerConfigException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTriggerConfigException.prototype);
    }
}
exports.InvalidTriggerConfigException = InvalidTriggerConfigException;
class LifecycleHookLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "LifecycleHookLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LifecycleHookLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LifecycleHookLimitExceededException.prototype);
    }
}
exports.LifecycleHookLimitExceededException = LifecycleHookLimitExceededException;
class RoleRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "RoleRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "RoleRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RoleRequiredException.prototype);
    }
}
exports.RoleRequiredException = RoleRequiredException;
class TagSetListLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "TagSetListLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "TagSetListLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TagSetListLimitExceededException.prototype);
    }
}
exports.TagSetListLimitExceededException = TagSetListLimitExceededException;
class TriggerTargetsLimitExceededException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "TriggerTargetsLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "TriggerTargetsLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TriggerTargetsLimitExceededException.prototype);
    }
}
exports.TriggerTargetsLimitExceededException = TriggerTargetsLimitExceededException;
class DeploymentConfigInUseException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "DeploymentConfigInUseException",
            $fault: "client",
            ...opts,
        });
        this.name = "DeploymentConfigInUseException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DeploymentConfigInUseException.prototype);
    }
}
exports.DeploymentConfigInUseException = DeploymentConfigInUseException;
class InvalidOperationException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidOperationException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOperationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOperationException.prototype);
    }
}
exports.InvalidOperationException = InvalidOperationException;
class GitHubAccountTokenDoesNotExistException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "GitHubAccountTokenDoesNotExistException",
            $fault: "client",
            ...opts,
        });
        this.name = "GitHubAccountTokenDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, GitHubAccountTokenDoesNotExistException.prototype);
    }
}
exports.GitHubAccountTokenDoesNotExistException = GitHubAccountTokenDoesNotExistException;
class GitHubAccountTokenNameRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "GitHubAccountTokenNameRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "GitHubAccountTokenNameRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, GitHubAccountTokenNameRequiredException.prototype);
    }
}
exports.GitHubAccountTokenNameRequiredException = GitHubAccountTokenNameRequiredException;
class InvalidGitHubAccountTokenNameException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidGitHubAccountTokenNameException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidGitHubAccountTokenNameException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidGitHubAccountTokenNameException.prototype);
    }
}
exports.InvalidGitHubAccountTokenNameException = InvalidGitHubAccountTokenNameException;
class OperationNotSupportedException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "OperationNotSupportedException",
            $fault: "client",
            ...opts,
        });
        this.name = "OperationNotSupportedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, OperationNotSupportedException.prototype);
    }
}
exports.OperationNotSupportedException = OperationNotSupportedException;
class ResourceValidationException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ResourceValidationException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceValidationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceValidationException.prototype);
    }
}
exports.ResourceValidationException = ResourceValidationException;
class InvalidBucketNameFilterException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidBucketNameFilterException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidBucketNameFilterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidBucketNameFilterException.prototype);
    }
}
exports.InvalidBucketNameFilterException = InvalidBucketNameFilterException;
class InvalidDeployedStateFilterException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeployedStateFilterException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeployedStateFilterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeployedStateFilterException.prototype);
    }
}
exports.InvalidDeployedStateFilterException = InvalidDeployedStateFilterException;
class InvalidKeyPrefixFilterException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidKeyPrefixFilterException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidKeyPrefixFilterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidKeyPrefixFilterException.prototype);
    }
}
exports.InvalidKeyPrefixFilterException = InvalidKeyPrefixFilterException;
class InvalidNextTokenException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidNextTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidNextTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidNextTokenException.prototype);
    }
}
exports.InvalidNextTokenException = InvalidNextTokenException;
class InvalidSortByException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidSortByException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidSortByException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidSortByException.prototype);
    }
}
exports.InvalidSortByException = InvalidSortByException;
class InvalidSortOrderException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidSortOrderException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidSortOrderException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidSortOrderException.prototype);
    }
}
exports.InvalidSortOrderException = InvalidSortOrderException;
var ListStateFilterAction;
(function (ListStateFilterAction) {
    ListStateFilterAction["Exclude"] = "exclude";
    ListStateFilterAction["Ignore"] = "ignore";
    ListStateFilterAction["Include"] = "include";
})(ListStateFilterAction = exports.ListStateFilterAction || (exports.ListStateFilterAction = {}));
var SortOrder;
(function (SortOrder) {
    SortOrder["Ascending"] = "ascending";
    SortOrder["Descending"] = "descending";
})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
class InvalidDeploymentInstanceTypeException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidDeploymentInstanceTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDeploymentInstanceTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDeploymentInstanceTypeException.prototype);
    }
}
exports.InvalidDeploymentInstanceTypeException = InvalidDeploymentInstanceTypeException;
class InvalidInstanceStatusException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidInstanceStatusException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidInstanceStatusException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidInstanceStatusException.prototype);
    }
}
exports.InvalidInstanceStatusException = InvalidInstanceStatusException;
class InvalidInstanceTypeException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidInstanceTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidInstanceTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidInstanceTypeException.prototype);
    }
}
exports.InvalidInstanceTypeException = InvalidInstanceTypeException;
class InvalidTargetFilterNameException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTargetFilterNameException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTargetFilterNameException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTargetFilterNameException.prototype);
    }
}
exports.InvalidTargetFilterNameException = InvalidTargetFilterNameException;
class InvalidExternalIdException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidExternalIdException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidExternalIdException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidExternalIdException.prototype);
    }
}
exports.InvalidExternalIdException = InvalidExternalIdException;
class InvalidTimeRangeException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTimeRangeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTimeRangeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTimeRangeException.prototype);
    }
}
exports.InvalidTimeRangeException = InvalidTimeRangeException;
var TargetFilterName;
(function (TargetFilterName) {
    TargetFilterName["SERVER_INSTANCE_LABEL"] = "ServerInstanceLabel";
    TargetFilterName["TARGET_STATUS"] = "TargetStatus";
})(TargetFilterName = exports.TargetFilterName || (exports.TargetFilterName = {}));
class InvalidRegistrationStatusException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidRegistrationStatusException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRegistrationStatusException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRegistrationStatusException.prototype);
    }
}
exports.InvalidRegistrationStatusException = InvalidRegistrationStatusException;
class InvalidTagFilterException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidTagFilterException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTagFilterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTagFilterException.prototype);
    }
}
exports.InvalidTagFilterException = InvalidTagFilterException;
var RegistrationStatus;
(function (RegistrationStatus) {
    RegistrationStatus["Deregistered"] = "Deregistered";
    RegistrationStatus["Registered"] = "Registered";
})(RegistrationStatus = exports.RegistrationStatus || (exports.RegistrationStatus = {}));
class InvalidArnException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidArnException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidArnException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidArnException.prototype);
    }
}
exports.InvalidArnException = InvalidArnException;
class ResourceArnRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "ResourceArnRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceArnRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceArnRequiredException.prototype);
    }
}
exports.ResourceArnRequiredException = ResourceArnRequiredException;
class InvalidLifecycleEventHookExecutionIdException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidLifecycleEventHookExecutionIdException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidLifecycleEventHookExecutionIdException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidLifecycleEventHookExecutionIdException.prototype);
    }
}
exports.InvalidLifecycleEventHookExecutionIdException = InvalidLifecycleEventHookExecutionIdException;
class InvalidLifecycleEventHookExecutionStatusException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidLifecycleEventHookExecutionStatusException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidLifecycleEventHookExecutionStatusException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidLifecycleEventHookExecutionStatusException.prototype);
    }
}
exports.InvalidLifecycleEventHookExecutionStatusException = InvalidLifecycleEventHookExecutionStatusException;
class LifecycleEventAlreadyCompletedException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "LifecycleEventAlreadyCompletedException",
            $fault: "client",
            ...opts,
        });
        this.name = "LifecycleEventAlreadyCompletedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LifecycleEventAlreadyCompletedException.prototype);
    }
}
exports.LifecycleEventAlreadyCompletedException = LifecycleEventAlreadyCompletedException;
class IamArnRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "IamArnRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "IamArnRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IamArnRequiredException.prototype);
    }
}
exports.IamArnRequiredException = IamArnRequiredException;
class IamSessionArnAlreadyRegisteredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "IamSessionArnAlreadyRegisteredException",
            $fault: "client",
            ...opts,
        });
        this.name = "IamSessionArnAlreadyRegisteredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IamSessionArnAlreadyRegisteredException.prototype);
    }
}
exports.IamSessionArnAlreadyRegisteredException = IamSessionArnAlreadyRegisteredException;
class IamUserArnAlreadyRegisteredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "IamUserArnAlreadyRegisteredException",
            $fault: "client",
            ...opts,
        });
        this.name = "IamUserArnAlreadyRegisteredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IamUserArnAlreadyRegisteredException.prototype);
    }
}
exports.IamUserArnAlreadyRegisteredException = IamUserArnAlreadyRegisteredException;
class IamUserArnRequiredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "IamUserArnRequiredException",
            $fault: "client",
            ...opts,
        });
        this.name = "IamUserArnRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IamUserArnRequiredException.prototype);
    }
}
exports.IamUserArnRequiredException = IamUserArnRequiredException;
class InstanceNameAlreadyRegisteredException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InstanceNameAlreadyRegisteredException",
            $fault: "client",
            ...opts,
        });
        this.name = "InstanceNameAlreadyRegisteredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InstanceNameAlreadyRegisteredException.prototype);
    }
}
exports.InstanceNameAlreadyRegisteredException = InstanceNameAlreadyRegisteredException;
class InvalidIamSessionArnException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidIamSessionArnException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIamSessionArnException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIamSessionArnException.prototype);
    }
}
exports.InvalidIamSessionArnException = InvalidIamSessionArnException;
class InvalidIamUserArnException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "InvalidIamUserArnException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIamUserArnException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIamUserArnException.prototype);
    }
}
exports.InvalidIamUserArnException = InvalidIamUserArnException;
class MultipleIamArnsProvidedException extends CodeDeployServiceException_1.CodeDeployServiceException {
    constructor(opts) {
        super({
            name: "MultipleIamArnsProvidedException",
            $fault: "client",
            ...opts,
        });
        this.name = "MultipleIamArnsProvidedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MultipleIamArnsProvidedException.prototype);
    }
}
exports.MultipleIamArnsProvidedException = MultipleIamArnsProvidedException;
var StopStatus;
(function (StopStatus) {
    StopStatus["PENDING"] = "Pending";
    StopStatus["SUCCEEDED"] = "Succeeded";
})(StopStatus = exports.StopStatus || (exports.StopStatus = {}));
const TagFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagFilterSensitiveLog = TagFilterSensitiveLog;
const AddTagsToOnPremisesInstancesInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AddTagsToOnPremisesInstancesInputFilterSensitiveLog = AddTagsToOnPremisesInstancesInputFilterSensitiveLog;
const AlarmFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AlarmFilterSensitiveLog = AlarmFilterSensitiveLog;
const AlarmConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AlarmConfigurationFilterSensitiveLog = AlarmConfigurationFilterSensitiveLog;
const ApplicationInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ApplicationInfoFilterSensitiveLog = ApplicationInfoFilterSensitiveLog;
const AppSpecContentFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AppSpecContentFilterSensitiveLog = AppSpecContentFilterSensitiveLog;
const AutoRollbackConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AutoRollbackConfigurationFilterSensitiveLog = AutoRollbackConfigurationFilterSensitiveLog;
const AutoScalingGroupFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AutoScalingGroupFilterSensitiveLog = AutoScalingGroupFilterSensitiveLog;
const GitHubLocationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GitHubLocationFilterSensitiveLog = GitHubLocationFilterSensitiveLog;
const S3LocationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.S3LocationFilterSensitiveLog = S3LocationFilterSensitiveLog;
const RawStringFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RawStringFilterSensitiveLog = RawStringFilterSensitiveLog;
const RevisionLocationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RevisionLocationFilterSensitiveLog = RevisionLocationFilterSensitiveLog;
const BatchGetApplicationRevisionsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetApplicationRevisionsInputFilterSensitiveLog = BatchGetApplicationRevisionsInputFilterSensitiveLog;
const GenericRevisionInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GenericRevisionInfoFilterSensitiveLog = GenericRevisionInfoFilterSensitiveLog;
const RevisionInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RevisionInfoFilterSensitiveLog = RevisionInfoFilterSensitiveLog;
const BatchGetApplicationRevisionsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetApplicationRevisionsOutputFilterSensitiveLog = BatchGetApplicationRevisionsOutputFilterSensitiveLog;
const BatchGetApplicationsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetApplicationsInputFilterSensitiveLog = BatchGetApplicationsInputFilterSensitiveLog;
const BatchGetApplicationsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetApplicationsOutputFilterSensitiveLog = BatchGetApplicationsOutputFilterSensitiveLog;
const BatchGetDeploymentGroupsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentGroupsInputFilterSensitiveLog = BatchGetDeploymentGroupsInputFilterSensitiveLog;
const DeploymentReadyOptionFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentReadyOptionFilterSensitiveLog = DeploymentReadyOptionFilterSensitiveLog;
const GreenFleetProvisioningOptionFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GreenFleetProvisioningOptionFilterSensitiveLog = GreenFleetProvisioningOptionFilterSensitiveLog;
const BlueInstanceTerminationOptionFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BlueInstanceTerminationOptionFilterSensitiveLog = BlueInstanceTerminationOptionFilterSensitiveLog;
const BlueGreenDeploymentConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BlueGreenDeploymentConfigurationFilterSensitiveLog = BlueGreenDeploymentConfigurationFilterSensitiveLog;
const DeploymentStyleFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentStyleFilterSensitiveLog = DeploymentStyleFilterSensitiveLog;
const EC2TagFilterFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.EC2TagFilterFilterSensitiveLog = EC2TagFilterFilterSensitiveLog;
const EC2TagSetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.EC2TagSetFilterSensitiveLog = EC2TagSetFilterSensitiveLog;
const ECSServiceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ECSServiceFilterSensitiveLog = ECSServiceFilterSensitiveLog;
const LastDeploymentInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LastDeploymentInfoFilterSensitiveLog = LastDeploymentInfoFilterSensitiveLog;
const ELBInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ELBInfoFilterSensitiveLog = ELBInfoFilterSensitiveLog;
const TargetGroupInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TargetGroupInfoFilterSensitiveLog = TargetGroupInfoFilterSensitiveLog;
const TrafficRouteFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TrafficRouteFilterSensitiveLog = TrafficRouteFilterSensitiveLog;
const TargetGroupPairInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TargetGroupPairInfoFilterSensitiveLog = TargetGroupPairInfoFilterSensitiveLog;
const LoadBalancerInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LoadBalancerInfoFilterSensitiveLog = LoadBalancerInfoFilterSensitiveLog;
const TagFilterFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagFilterFilterSensitiveLog = TagFilterFilterSensitiveLog;
const OnPremisesTagSetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.OnPremisesTagSetFilterSensitiveLog = OnPremisesTagSetFilterSensitiveLog;
const TriggerConfigFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TriggerConfigFilterSensitiveLog = TriggerConfigFilterSensitiveLog;
const DeploymentGroupInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentGroupInfoFilterSensitiveLog = DeploymentGroupInfoFilterSensitiveLog;
const BatchGetDeploymentGroupsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentGroupsOutputFilterSensitiveLog = BatchGetDeploymentGroupsOutputFilterSensitiveLog;
const BatchGetDeploymentInstancesInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentInstancesInputFilterSensitiveLog = BatchGetDeploymentInstancesInputFilterSensitiveLog;
const DiagnosticsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DiagnosticsFilterSensitiveLog = DiagnosticsFilterSensitiveLog;
const LifecycleEventFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LifecycleEventFilterSensitiveLog = LifecycleEventFilterSensitiveLog;
const InstanceSummaryFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.InstanceSummaryFilterSensitiveLog = InstanceSummaryFilterSensitiveLog;
const BatchGetDeploymentInstancesOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentInstancesOutputFilterSensitiveLog = BatchGetDeploymentInstancesOutputFilterSensitiveLog;
const BatchGetDeploymentsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentsInputFilterSensitiveLog = BatchGetDeploymentsInputFilterSensitiveLog;
const DeploymentOverviewFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentOverviewFilterSensitiveLog = DeploymentOverviewFilterSensitiveLog;
const ErrorInformationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ErrorInformationFilterSensitiveLog = ErrorInformationFilterSensitiveLog;
const RelatedDeploymentsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RelatedDeploymentsFilterSensitiveLog = RelatedDeploymentsFilterSensitiveLog;
const RollbackInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RollbackInfoFilterSensitiveLog = RollbackInfoFilterSensitiveLog;
const TargetInstancesFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TargetInstancesFilterSensitiveLog = TargetInstancesFilterSensitiveLog;
const DeploymentInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentInfoFilterSensitiveLog = DeploymentInfoFilterSensitiveLog;
const BatchGetDeploymentsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentsOutputFilterSensitiveLog = BatchGetDeploymentsOutputFilterSensitiveLog;
const BatchGetDeploymentTargetsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentTargetsInputFilterSensitiveLog = BatchGetDeploymentTargetsInputFilterSensitiveLog;
const CloudFormationTargetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CloudFormationTargetFilterSensitiveLog = CloudFormationTargetFilterSensitiveLog;
const ECSTaskSetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ECSTaskSetFilterSensitiveLog = ECSTaskSetFilterSensitiveLog;
const ECSTargetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ECSTargetFilterSensitiveLog = ECSTargetFilterSensitiveLog;
const InstanceTargetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.InstanceTargetFilterSensitiveLog = InstanceTargetFilterSensitiveLog;
const LambdaFunctionInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LambdaFunctionInfoFilterSensitiveLog = LambdaFunctionInfoFilterSensitiveLog;
const LambdaTargetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LambdaTargetFilterSensitiveLog = LambdaTargetFilterSensitiveLog;
const DeploymentTargetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentTargetFilterSensitiveLog = DeploymentTargetFilterSensitiveLog;
const BatchGetDeploymentTargetsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetDeploymentTargetsOutputFilterSensitiveLog = BatchGetDeploymentTargetsOutputFilterSensitiveLog;
const BatchGetOnPremisesInstancesInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetOnPremisesInstancesInputFilterSensitiveLog = BatchGetOnPremisesInstancesInputFilterSensitiveLog;
const InstanceInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.InstanceInfoFilterSensitiveLog = InstanceInfoFilterSensitiveLog;
const BatchGetOnPremisesInstancesOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.BatchGetOnPremisesInstancesOutputFilterSensitiveLog = BatchGetOnPremisesInstancesOutputFilterSensitiveLog;
const ContinueDeploymentInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContinueDeploymentInputFilterSensitiveLog = ContinueDeploymentInputFilterSensitiveLog;
const CreateApplicationInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateApplicationInputFilterSensitiveLog = CreateApplicationInputFilterSensitiveLog;
const CreateApplicationOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateApplicationOutputFilterSensitiveLog = CreateApplicationOutputFilterSensitiveLog;
const CreateDeploymentInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateDeploymentInputFilterSensitiveLog = CreateDeploymentInputFilterSensitiveLog;
const CreateDeploymentOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateDeploymentOutputFilterSensitiveLog = CreateDeploymentOutputFilterSensitiveLog;
const MinimumHealthyHostsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.MinimumHealthyHostsFilterSensitiveLog = MinimumHealthyHostsFilterSensitiveLog;
const TimeBasedCanaryFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TimeBasedCanaryFilterSensitiveLog = TimeBasedCanaryFilterSensitiveLog;
const TimeBasedLinearFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TimeBasedLinearFilterSensitiveLog = TimeBasedLinearFilterSensitiveLog;
const TrafficRoutingConfigFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TrafficRoutingConfigFilterSensitiveLog = TrafficRoutingConfigFilterSensitiveLog;
const CreateDeploymentConfigInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateDeploymentConfigInputFilterSensitiveLog = CreateDeploymentConfigInputFilterSensitiveLog;
const CreateDeploymentConfigOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateDeploymentConfigOutputFilterSensitiveLog = CreateDeploymentConfigOutputFilterSensitiveLog;
const CreateDeploymentGroupInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateDeploymentGroupInputFilterSensitiveLog = CreateDeploymentGroupInputFilterSensitiveLog;
const CreateDeploymentGroupOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateDeploymentGroupOutputFilterSensitiveLog = CreateDeploymentGroupOutputFilterSensitiveLog;
const DeleteApplicationInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteApplicationInputFilterSensitiveLog = DeleteApplicationInputFilterSensitiveLog;
const DeleteDeploymentConfigInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteDeploymentConfigInputFilterSensitiveLog = DeleteDeploymentConfigInputFilterSensitiveLog;
const DeleteDeploymentGroupInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteDeploymentGroupInputFilterSensitiveLog = DeleteDeploymentGroupInputFilterSensitiveLog;
const DeleteDeploymentGroupOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteDeploymentGroupOutputFilterSensitiveLog = DeleteDeploymentGroupOutputFilterSensitiveLog;
const DeleteGitHubAccountTokenInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteGitHubAccountTokenInputFilterSensitiveLog = DeleteGitHubAccountTokenInputFilterSensitiveLog;
const DeleteGitHubAccountTokenOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteGitHubAccountTokenOutputFilterSensitiveLog = DeleteGitHubAccountTokenOutputFilterSensitiveLog;
const DeleteResourcesByExternalIdInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteResourcesByExternalIdInputFilterSensitiveLog = DeleteResourcesByExternalIdInputFilterSensitiveLog;
const DeleteResourcesByExternalIdOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteResourcesByExternalIdOutputFilterSensitiveLog = DeleteResourcesByExternalIdOutputFilterSensitiveLog;
const DeregisterOnPremisesInstanceInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeregisterOnPremisesInstanceInputFilterSensitiveLog = DeregisterOnPremisesInstanceInputFilterSensitiveLog;
const GetApplicationInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetApplicationInputFilterSensitiveLog = GetApplicationInputFilterSensitiveLog;
const GetApplicationOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetApplicationOutputFilterSensitiveLog = GetApplicationOutputFilterSensitiveLog;
const GetApplicationRevisionInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetApplicationRevisionInputFilterSensitiveLog = GetApplicationRevisionInputFilterSensitiveLog;
const GetApplicationRevisionOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetApplicationRevisionOutputFilterSensitiveLog = GetApplicationRevisionOutputFilterSensitiveLog;
const GetDeploymentInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentInputFilterSensitiveLog = GetDeploymentInputFilterSensitiveLog;
const GetDeploymentOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentOutputFilterSensitiveLog = GetDeploymentOutputFilterSensitiveLog;
const GetDeploymentConfigInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentConfigInputFilterSensitiveLog = GetDeploymentConfigInputFilterSensitiveLog;
const DeploymentConfigInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentConfigInfoFilterSensitiveLog = DeploymentConfigInfoFilterSensitiveLog;
const GetDeploymentConfigOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentConfigOutputFilterSensitiveLog = GetDeploymentConfigOutputFilterSensitiveLog;
const GetDeploymentGroupInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentGroupInputFilterSensitiveLog = GetDeploymentGroupInputFilterSensitiveLog;
const GetDeploymentGroupOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentGroupOutputFilterSensitiveLog = GetDeploymentGroupOutputFilterSensitiveLog;
const GetDeploymentInstanceInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentInstanceInputFilterSensitiveLog = GetDeploymentInstanceInputFilterSensitiveLog;
const GetDeploymentInstanceOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentInstanceOutputFilterSensitiveLog = GetDeploymentInstanceOutputFilterSensitiveLog;
const GetDeploymentTargetInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentTargetInputFilterSensitiveLog = GetDeploymentTargetInputFilterSensitiveLog;
const GetDeploymentTargetOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetDeploymentTargetOutputFilterSensitiveLog = GetDeploymentTargetOutputFilterSensitiveLog;
const GetOnPremisesInstanceInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetOnPremisesInstanceInputFilterSensitiveLog = GetOnPremisesInstanceInputFilterSensitiveLog;
const GetOnPremisesInstanceOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetOnPremisesInstanceOutputFilterSensitiveLog = GetOnPremisesInstanceOutputFilterSensitiveLog;
const ListApplicationRevisionsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListApplicationRevisionsInputFilterSensitiveLog = ListApplicationRevisionsInputFilterSensitiveLog;
const ListApplicationRevisionsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListApplicationRevisionsOutputFilterSensitiveLog = ListApplicationRevisionsOutputFilterSensitiveLog;
const ListApplicationsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListApplicationsInputFilterSensitiveLog = ListApplicationsInputFilterSensitiveLog;
const ListApplicationsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListApplicationsOutputFilterSensitiveLog = ListApplicationsOutputFilterSensitiveLog;
const ListDeploymentConfigsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentConfigsInputFilterSensitiveLog = ListDeploymentConfigsInputFilterSensitiveLog;
const ListDeploymentConfigsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentConfigsOutputFilterSensitiveLog = ListDeploymentConfigsOutputFilterSensitiveLog;
const ListDeploymentGroupsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentGroupsInputFilterSensitiveLog = ListDeploymentGroupsInputFilterSensitiveLog;
const ListDeploymentGroupsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentGroupsOutputFilterSensitiveLog = ListDeploymentGroupsOutputFilterSensitiveLog;
const ListDeploymentInstancesInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentInstancesInputFilterSensitiveLog = ListDeploymentInstancesInputFilterSensitiveLog;
const ListDeploymentInstancesOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentInstancesOutputFilterSensitiveLog = ListDeploymentInstancesOutputFilterSensitiveLog;
const TimeRangeFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TimeRangeFilterSensitiveLog = TimeRangeFilterSensitiveLog;
const ListDeploymentsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentsInputFilterSensitiveLog = ListDeploymentsInputFilterSensitiveLog;
const ListDeploymentsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentsOutputFilterSensitiveLog = ListDeploymentsOutputFilterSensitiveLog;
const ListDeploymentTargetsInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentTargetsInputFilterSensitiveLog = ListDeploymentTargetsInputFilterSensitiveLog;
const ListDeploymentTargetsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDeploymentTargetsOutputFilterSensitiveLog = ListDeploymentTargetsOutputFilterSensitiveLog;
const ListGitHubAccountTokenNamesInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListGitHubAccountTokenNamesInputFilterSensitiveLog = ListGitHubAccountTokenNamesInputFilterSensitiveLog;
const ListGitHubAccountTokenNamesOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListGitHubAccountTokenNamesOutputFilterSensitiveLog = ListGitHubAccountTokenNamesOutputFilterSensitiveLog;
const ListOnPremisesInstancesInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListOnPremisesInstancesInputFilterSensitiveLog = ListOnPremisesInstancesInputFilterSensitiveLog;
const ListOnPremisesInstancesOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListOnPremisesInstancesOutputFilterSensitiveLog = ListOnPremisesInstancesOutputFilterSensitiveLog;
const ListTagsForResourceInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsForResourceInputFilterSensitiveLog = ListTagsForResourceInputFilterSensitiveLog;
const ListTagsForResourceOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsForResourceOutputFilterSensitiveLog = ListTagsForResourceOutputFilterSensitiveLog;
const PutLifecycleEventHookExecutionStatusInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutLifecycleEventHookExecutionStatusInputFilterSensitiveLog = PutLifecycleEventHookExecutionStatusInputFilterSensitiveLog;
const PutLifecycleEventHookExecutionStatusOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutLifecycleEventHookExecutionStatusOutputFilterSensitiveLog = PutLifecycleEventHookExecutionStatusOutputFilterSensitiveLog;
const RegisterApplicationRevisionInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterApplicationRevisionInputFilterSensitiveLog = RegisterApplicationRevisionInputFilterSensitiveLog;
const RegisterOnPremisesInstanceInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterOnPremisesInstanceInputFilterSensitiveLog = RegisterOnPremisesInstanceInputFilterSensitiveLog;
const RemoveTagsFromOnPremisesInstancesInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RemoveTagsFromOnPremisesInstancesInputFilterSensitiveLog = RemoveTagsFromOnPremisesInstancesInputFilterSensitiveLog;
const SkipWaitTimeForInstanceTerminationInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SkipWaitTimeForInstanceTerminationInputFilterSensitiveLog = SkipWaitTimeForInstanceTerminationInputFilterSensitiveLog;
const StopDeploymentInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StopDeploymentInputFilterSensitiveLog = StopDeploymentInputFilterSensitiveLog;
const StopDeploymentOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StopDeploymentOutputFilterSensitiveLog = StopDeploymentOutputFilterSensitiveLog;
const TagResourceInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagResourceInputFilterSensitiveLog = TagResourceInputFilterSensitiveLog;
const TagResourceOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagResourceOutputFilterSensitiveLog = TagResourceOutputFilterSensitiveLog;
const UntagResourceInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UntagResourceInputFilterSensitiveLog = UntagResourceInputFilterSensitiveLog;
const UntagResourceOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UntagResourceOutputFilterSensitiveLog = UntagResourceOutputFilterSensitiveLog;
const UpdateApplicationInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateApplicationInputFilterSensitiveLog = UpdateApplicationInputFilterSensitiveLog;
const UpdateDeploymentGroupInputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateDeploymentGroupInputFilterSensitiveLog = UpdateDeploymentGroupInputFilterSensitiveLog;
const UpdateDeploymentGroupOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateDeploymentGroupOutputFilterSensitiveLog = UpdateDeploymentGroupOutputFilterSensitiveLog;


/***/ }),

/***/ 55732:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89886:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListApplicationRevisions = void 0;
const CodeDeploy_1 = __nccwpck_require__(19923);
const CodeDeployClient_1 = __nccwpck_require__(92794);
const ListApplicationRevisionsCommand_1 = __nccwpck_require__(38276);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListApplicationRevisionsCommand_1.ListApplicationRevisionsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listApplicationRevisions(input, ...args);
};
async function* paginateListApplicationRevisions(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        if (config.client instanceof CodeDeploy_1.CodeDeploy) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CodeDeployClient_1.CodeDeployClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CodeDeploy | CodeDeployClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListApplicationRevisions = paginateListApplicationRevisions;


/***/ }),

/***/ 18832:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListApplications = void 0;
const CodeDeploy_1 = __nccwpck_require__(19923);
const CodeDeployClient_1 = __nccwpck_require__(92794);
const ListApplicationsCommand_1 = __nccwpck_require__(58039);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListApplicationsCommand_1.ListApplicationsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listApplications(input, ...args);
};
async function* paginateListApplications(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        if (config.client instanceof CodeDeploy_1.CodeDeploy) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CodeDeployClient_1.CodeDeployClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CodeDeploy | CodeDeployClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListApplications = paginateListApplications;


/***/ }),

/***/ 13088:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListDeploymentConfigs = void 0;
const CodeDeploy_1 = __nccwpck_require__(19923);
const CodeDeployClient_1 = __nccwpck_require__(92794);
const ListDeploymentConfigsCommand_1 = __nccwpck_require__(97097);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListDeploymentConfigsCommand_1.ListDeploymentConfigsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listDeploymentConfigs(input, ...args);
};
async function* paginateListDeploymentConfigs(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        if (config.client instanceof CodeDeploy_1.CodeDeploy) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CodeDeployClient_1.CodeDeployClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CodeDeploy | CodeDeployClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListDeploymentConfigs = paginateListDeploymentConfigs;


/***/ }),

/***/ 33322:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListDeploymentGroups = void 0;
const CodeDeploy_1 = __nccwpck_require__(19923);
const CodeDeployClient_1 = __nccwpck_require__(92794);
const ListDeploymentGroupsCommand_1 = __nccwpck_require__(29744);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListDeploymentGroupsCommand_1.ListDeploymentGroupsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listDeploymentGroups(input, ...args);
};
async function* paginateListDeploymentGroups(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        if (config.client instanceof CodeDeploy_1.CodeDeploy) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CodeDeployClient_1.CodeDeployClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CodeDeploy | CodeDeployClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListDeploymentGroups = paginateListDeploymentGroups;


/***/ }),

/***/ 36756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListDeploymentInstances = void 0;
const CodeDeploy_1 = __nccwpck_require__(19923);
const CodeDeployClient_1 = __nccwpck_require__(92794);
const ListDeploymentInstancesCommand_1 = __nccwpck_require__(30549);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListDeploymentInstancesCommand_1.ListDeploymentInstancesCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listDeploymentInstances(input, ...args);
};
async function* paginateListDeploymentInstances(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        if (config.client instanceof CodeDeploy_1.CodeDeploy) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CodeDeployClient_1.CodeDeployClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CodeDeploy | CodeDeployClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListDeploymentInstances = paginateListDeploymentInstances;


/***/ }),

/***/ 27613:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListDeployments = void 0;
const CodeDeploy_1 = __nccwpck_require__(19923);
const CodeDeployClient_1 = __nccwpck_require__(92794);
const ListDeploymentsCommand_1 = __nccwpck_require__(46851);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListDeploymentsCommand_1.ListDeploymentsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listDeployments(input, ...args);
};
async function* paginateListDeployments(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        if (config.client instanceof CodeDeploy_1.CodeDeploy) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof CodeDeployClient_1.CodeDeployClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected CodeDeploy | CodeDeployClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListDeployments = paginateListDeployments;


/***/ }),

/***/ 20887:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(55732), exports);
tslib_1.__exportStar(__nccwpck_require__(89886), exports);
tslib_1.__exportStar(__nccwpck_require__(18832), exports);
tslib_1.__exportStar(__nccwpck_require__(13088), exports);
tslib_1.__exportStar(__nccwpck_require__(33322), exports);
tslib_1.__exportStar(__nccwpck_require__(36756), exports);
tslib_1.__exportStar(__nccwpck_require__(27613), exports);


/***/ }),

/***/ 72093:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeAws_json1_1BatchGetApplicationsCommand = exports.deserializeAws_json1_1BatchGetApplicationRevisionsCommand = exports.deserializeAws_json1_1AddTagsToOnPremisesInstancesCommand = exports.serializeAws_json1_1UpdateDeploymentGroupCommand = exports.serializeAws_json1_1UpdateApplicationCommand = exports.serializeAws_json1_1UntagResourceCommand = exports.serializeAws_json1_1TagResourceCommand = exports.serializeAws_json1_1StopDeploymentCommand = exports.serializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand = exports.serializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand = exports.serializeAws_json1_1RegisterOnPremisesInstanceCommand = exports.serializeAws_json1_1RegisterApplicationRevisionCommand = exports.serializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand = exports.serializeAws_json1_1ListTagsForResourceCommand = exports.serializeAws_json1_1ListOnPremisesInstancesCommand = exports.serializeAws_json1_1ListGitHubAccountTokenNamesCommand = exports.serializeAws_json1_1ListDeploymentTargetsCommand = exports.serializeAws_json1_1ListDeploymentsCommand = exports.serializeAws_json1_1ListDeploymentInstancesCommand = exports.serializeAws_json1_1ListDeploymentGroupsCommand = exports.serializeAws_json1_1ListDeploymentConfigsCommand = exports.serializeAws_json1_1ListApplicationsCommand = exports.serializeAws_json1_1ListApplicationRevisionsCommand = exports.serializeAws_json1_1GetOnPremisesInstanceCommand = exports.serializeAws_json1_1GetDeploymentTargetCommand = exports.serializeAws_json1_1GetDeploymentInstanceCommand = exports.serializeAws_json1_1GetDeploymentGroupCommand = exports.serializeAws_json1_1GetDeploymentConfigCommand = exports.serializeAws_json1_1GetDeploymentCommand = exports.serializeAws_json1_1GetApplicationRevisionCommand = exports.serializeAws_json1_1GetApplicationCommand = exports.serializeAws_json1_1DeregisterOnPremisesInstanceCommand = exports.serializeAws_json1_1DeleteResourcesByExternalIdCommand = exports.serializeAws_json1_1DeleteGitHubAccountTokenCommand = exports.serializeAws_json1_1DeleteDeploymentGroupCommand = exports.serializeAws_json1_1DeleteDeploymentConfigCommand = exports.serializeAws_json1_1DeleteApplicationCommand = exports.serializeAws_json1_1CreateDeploymentGroupCommand = exports.serializeAws_json1_1CreateDeploymentConfigCommand = exports.serializeAws_json1_1CreateDeploymentCommand = exports.serializeAws_json1_1CreateApplicationCommand = exports.serializeAws_json1_1ContinueDeploymentCommand = exports.serializeAws_json1_1BatchGetOnPremisesInstancesCommand = exports.serializeAws_json1_1BatchGetDeploymentTargetsCommand = exports.serializeAws_json1_1BatchGetDeploymentsCommand = exports.serializeAws_json1_1BatchGetDeploymentInstancesCommand = exports.serializeAws_json1_1BatchGetDeploymentGroupsCommand = exports.serializeAws_json1_1BatchGetApplicationsCommand = exports.serializeAws_json1_1BatchGetApplicationRevisionsCommand = exports.serializeAws_json1_1AddTagsToOnPremisesInstancesCommand = void 0;
exports.deserializeAws_json1_1UpdateDeploymentGroupCommand = exports.deserializeAws_json1_1UpdateApplicationCommand = exports.deserializeAws_json1_1UntagResourceCommand = exports.deserializeAws_json1_1TagResourceCommand = exports.deserializeAws_json1_1StopDeploymentCommand = exports.deserializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand = exports.deserializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand = exports.deserializeAws_json1_1RegisterOnPremisesInstanceCommand = exports.deserializeAws_json1_1RegisterApplicationRevisionCommand = exports.deserializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand = exports.deserializeAws_json1_1ListTagsForResourceCommand = exports.deserializeAws_json1_1ListOnPremisesInstancesCommand = exports.deserializeAws_json1_1ListGitHubAccountTokenNamesCommand = exports.deserializeAws_json1_1ListDeploymentTargetsCommand = exports.deserializeAws_json1_1ListDeploymentsCommand = exports.deserializeAws_json1_1ListDeploymentInstancesCommand = exports.deserializeAws_json1_1ListDeploymentGroupsCommand = exports.deserializeAws_json1_1ListDeploymentConfigsCommand = exports.deserializeAws_json1_1ListApplicationsCommand = exports.deserializeAws_json1_1ListApplicationRevisionsCommand = exports.deserializeAws_json1_1GetOnPremisesInstanceCommand = exports.deserializeAws_json1_1GetDeploymentTargetCommand = exports.deserializeAws_json1_1GetDeploymentInstanceCommand = exports.deserializeAws_json1_1GetDeploymentGroupCommand = exports.deserializeAws_json1_1GetDeploymentConfigCommand = exports.deserializeAws_json1_1GetDeploymentCommand = exports.deserializeAws_json1_1GetApplicationRevisionCommand = exports.deserializeAws_json1_1GetApplicationCommand = exports.deserializeAws_json1_1DeregisterOnPremisesInstanceCommand = exports.deserializeAws_json1_1DeleteResourcesByExternalIdCommand = exports.deserializeAws_json1_1DeleteGitHubAccountTokenCommand = exports.deserializeAws_json1_1DeleteDeploymentGroupCommand = exports.deserializeAws_json1_1DeleteDeploymentConfigCommand = exports.deserializeAws_json1_1DeleteApplicationCommand = exports.deserializeAws_json1_1CreateDeploymentGroupCommand = exports.deserializeAws_json1_1CreateDeploymentConfigCommand = exports.deserializeAws_json1_1CreateDeploymentCommand = exports.deserializeAws_json1_1CreateApplicationCommand = exports.deserializeAws_json1_1ContinueDeploymentCommand = exports.deserializeAws_json1_1BatchGetOnPremisesInstancesCommand = exports.deserializeAws_json1_1BatchGetDeploymentTargetsCommand = exports.deserializeAws_json1_1BatchGetDeploymentsCommand = exports.deserializeAws_json1_1BatchGetDeploymentInstancesCommand = exports.deserializeAws_json1_1BatchGetDeploymentGroupsCommand = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const smithy_client_1 = __nccwpck_require__(4963);
const CodeDeployServiceException_1 = __nccwpck_require__(20635);
const models_0_1 = __nccwpck_require__(70579);
const serializeAws_json1_1AddTagsToOnPremisesInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.AddTagsToOnPremisesInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1AddTagsToOnPremisesInstancesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1AddTagsToOnPremisesInstancesCommand = serializeAws_json1_1AddTagsToOnPremisesInstancesCommand;
const serializeAws_json1_1BatchGetApplicationRevisionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.BatchGetApplicationRevisions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetApplicationRevisionsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchGetApplicationRevisionsCommand = serializeAws_json1_1BatchGetApplicationRevisionsCommand;
const serializeAws_json1_1BatchGetApplicationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.BatchGetApplications",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetApplicationsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchGetApplicationsCommand = serializeAws_json1_1BatchGetApplicationsCommand;
const serializeAws_json1_1BatchGetDeploymentGroupsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.BatchGetDeploymentGroups",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetDeploymentGroupsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchGetDeploymentGroupsCommand = serializeAws_json1_1BatchGetDeploymentGroupsCommand;
const serializeAws_json1_1BatchGetDeploymentInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.BatchGetDeploymentInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetDeploymentInstancesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchGetDeploymentInstancesCommand = serializeAws_json1_1BatchGetDeploymentInstancesCommand;
const serializeAws_json1_1BatchGetDeploymentsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.BatchGetDeployments",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetDeploymentsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchGetDeploymentsCommand = serializeAws_json1_1BatchGetDeploymentsCommand;
const serializeAws_json1_1BatchGetDeploymentTargetsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.BatchGetDeploymentTargets",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetDeploymentTargetsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchGetDeploymentTargetsCommand = serializeAws_json1_1BatchGetDeploymentTargetsCommand;
const serializeAws_json1_1BatchGetOnPremisesInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.BatchGetOnPremisesInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetOnPremisesInstancesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1BatchGetOnPremisesInstancesCommand = serializeAws_json1_1BatchGetOnPremisesInstancesCommand;
const serializeAws_json1_1ContinueDeploymentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ContinueDeployment",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ContinueDeploymentInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ContinueDeploymentCommand = serializeAws_json1_1ContinueDeploymentCommand;
const serializeAws_json1_1CreateApplicationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.CreateApplication",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateApplicationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateApplicationCommand = serializeAws_json1_1CreateApplicationCommand;
const serializeAws_json1_1CreateDeploymentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.CreateDeployment",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateDeploymentInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateDeploymentCommand = serializeAws_json1_1CreateDeploymentCommand;
const serializeAws_json1_1CreateDeploymentConfigCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.CreateDeploymentConfig",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateDeploymentConfigInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateDeploymentConfigCommand = serializeAws_json1_1CreateDeploymentConfigCommand;
const serializeAws_json1_1CreateDeploymentGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.CreateDeploymentGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateDeploymentGroupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateDeploymentGroupCommand = serializeAws_json1_1CreateDeploymentGroupCommand;
const serializeAws_json1_1DeleteApplicationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.DeleteApplication",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteApplicationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteApplicationCommand = serializeAws_json1_1DeleteApplicationCommand;
const serializeAws_json1_1DeleteDeploymentConfigCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.DeleteDeploymentConfig",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDeploymentConfigInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteDeploymentConfigCommand = serializeAws_json1_1DeleteDeploymentConfigCommand;
const serializeAws_json1_1DeleteDeploymentGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.DeleteDeploymentGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDeploymentGroupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteDeploymentGroupCommand = serializeAws_json1_1DeleteDeploymentGroupCommand;
const serializeAws_json1_1DeleteGitHubAccountTokenCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.DeleteGitHubAccountToken",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteGitHubAccountTokenInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteGitHubAccountTokenCommand = serializeAws_json1_1DeleteGitHubAccountTokenCommand;
const serializeAws_json1_1DeleteResourcesByExternalIdCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.DeleteResourcesByExternalId",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteResourcesByExternalIdInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteResourcesByExternalIdCommand = serializeAws_json1_1DeleteResourcesByExternalIdCommand;
const serializeAws_json1_1DeregisterOnPremisesInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.DeregisterOnPremisesInstance",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeregisterOnPremisesInstanceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeregisterOnPremisesInstanceCommand = serializeAws_json1_1DeregisterOnPremisesInstanceCommand;
const serializeAws_json1_1GetApplicationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetApplication",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetApplicationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetApplicationCommand = serializeAws_json1_1GetApplicationCommand;
const serializeAws_json1_1GetApplicationRevisionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetApplicationRevision",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetApplicationRevisionInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetApplicationRevisionCommand = serializeAws_json1_1GetApplicationRevisionCommand;
const serializeAws_json1_1GetDeploymentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetDeployment",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDeploymentInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDeploymentCommand = serializeAws_json1_1GetDeploymentCommand;
const serializeAws_json1_1GetDeploymentConfigCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetDeploymentConfig",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDeploymentConfigInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDeploymentConfigCommand = serializeAws_json1_1GetDeploymentConfigCommand;
const serializeAws_json1_1GetDeploymentGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetDeploymentGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDeploymentGroupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDeploymentGroupCommand = serializeAws_json1_1GetDeploymentGroupCommand;
const serializeAws_json1_1GetDeploymentInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetDeploymentInstance",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDeploymentInstanceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDeploymentInstanceCommand = serializeAws_json1_1GetDeploymentInstanceCommand;
const serializeAws_json1_1GetDeploymentTargetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetDeploymentTarget",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDeploymentTargetInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetDeploymentTargetCommand = serializeAws_json1_1GetDeploymentTargetCommand;
const serializeAws_json1_1GetOnPremisesInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.GetOnPremisesInstance",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetOnPremisesInstanceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetOnPremisesInstanceCommand = serializeAws_json1_1GetOnPremisesInstanceCommand;
const serializeAws_json1_1ListApplicationRevisionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListApplicationRevisions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListApplicationRevisionsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListApplicationRevisionsCommand = serializeAws_json1_1ListApplicationRevisionsCommand;
const serializeAws_json1_1ListApplicationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListApplications",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListApplicationsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListApplicationsCommand = serializeAws_json1_1ListApplicationsCommand;
const serializeAws_json1_1ListDeploymentConfigsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListDeploymentConfigs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDeploymentConfigsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDeploymentConfigsCommand = serializeAws_json1_1ListDeploymentConfigsCommand;
const serializeAws_json1_1ListDeploymentGroupsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListDeploymentGroups",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDeploymentGroupsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDeploymentGroupsCommand = serializeAws_json1_1ListDeploymentGroupsCommand;
const serializeAws_json1_1ListDeploymentInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListDeploymentInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDeploymentInstancesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDeploymentInstancesCommand = serializeAws_json1_1ListDeploymentInstancesCommand;
const serializeAws_json1_1ListDeploymentsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListDeployments",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDeploymentsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDeploymentsCommand = serializeAws_json1_1ListDeploymentsCommand;
const serializeAws_json1_1ListDeploymentTargetsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListDeploymentTargets",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDeploymentTargetsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListDeploymentTargetsCommand = serializeAws_json1_1ListDeploymentTargetsCommand;
const serializeAws_json1_1ListGitHubAccountTokenNamesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListGitHubAccountTokenNames",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListGitHubAccountTokenNamesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListGitHubAccountTokenNamesCommand = serializeAws_json1_1ListGitHubAccountTokenNamesCommand;
const serializeAws_json1_1ListOnPremisesInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListOnPremisesInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListOnPremisesInstancesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListOnPremisesInstancesCommand = serializeAws_json1_1ListOnPremisesInstancesCommand;
const serializeAws_json1_1ListTagsForResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.ListTagsForResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTagsForResourceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTagsForResourceCommand = serializeAws_json1_1ListTagsForResourceCommand;
const serializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.PutLifecycleEventHookExecutionStatus",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutLifecycleEventHookExecutionStatusInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand = serializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand;
const serializeAws_json1_1RegisterApplicationRevisionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.RegisterApplicationRevision",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RegisterApplicationRevisionInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1RegisterApplicationRevisionCommand = serializeAws_json1_1RegisterApplicationRevisionCommand;
const serializeAws_json1_1RegisterOnPremisesInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.RegisterOnPremisesInstance",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RegisterOnPremisesInstanceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1RegisterOnPremisesInstanceCommand = serializeAws_json1_1RegisterOnPremisesInstanceCommand;
const serializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.RemoveTagsFromOnPremisesInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RemoveTagsFromOnPremisesInstancesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand = serializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand;
const serializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.SkipWaitTimeForInstanceTermination",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1SkipWaitTimeForInstanceTerminationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand = serializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand;
const serializeAws_json1_1StopDeploymentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.StopDeployment",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopDeploymentInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopDeploymentCommand = serializeAws_json1_1StopDeploymentCommand;
const serializeAws_json1_1TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagResourceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TagResourceCommand = serializeAws_json1_1TagResourceCommand;
const serializeAws_json1_1UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagResourceInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UntagResourceCommand = serializeAws_json1_1UntagResourceCommand;
const serializeAws_json1_1UpdateApplicationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.UpdateApplication",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateApplicationInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateApplicationCommand = serializeAws_json1_1UpdateApplicationCommand;
const serializeAws_json1_1UpdateDeploymentGroupCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "CodeDeploy_20141006.UpdateDeploymentGroup",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateDeploymentGroupInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateDeploymentGroupCommand = serializeAws_json1_1UpdateDeploymentGroupCommand;
const deserializeAws_json1_1AddTagsToOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1AddTagsToOnPremisesInstancesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1AddTagsToOnPremisesInstancesCommand = deserializeAws_json1_1AddTagsToOnPremisesInstancesCommand;
const deserializeAws_json1_1AddTagsToOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceLimitExceededException":
        case "com.amazonaws.codedeploy#InstanceLimitExceededException":
            throw await deserializeAws_json1_1InstanceLimitExceededExceptionResponse(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await deserializeAws_json1_1InstanceNameRequiredExceptionResponse(parsedOutput, context);
        case "InstanceNotRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNotRegisteredException":
            throw await deserializeAws_json1_1InstanceNotRegisteredExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await deserializeAws_json1_1InvalidTagExceptionResponse(parsedOutput, context);
        case "TagLimitExceededException":
        case "com.amazonaws.codedeploy#TagLimitExceededException":
            throw await deserializeAws_json1_1TagLimitExceededExceptionResponse(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await deserializeAws_json1_1TagRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1BatchGetApplicationRevisionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetApplicationRevisionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetApplicationRevisionsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1BatchGetApplicationRevisionsCommand = deserializeAws_json1_1BatchGetApplicationRevisionsCommand;
const deserializeAws_json1_1BatchGetApplicationRevisionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await deserializeAws_json1_1BatchLimitExceededExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await deserializeAws_json1_1InvalidRevisionExceptionResponse(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await deserializeAws_json1_1RevisionRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1BatchGetApplicationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetApplicationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetApplicationsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1BatchGetApplicationsCommand = deserializeAws_json1_1BatchGetApplicationsCommand;
const deserializeAws_json1_1BatchGetApplicationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await deserializeAws_json1_1BatchLimitExceededExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1BatchGetDeploymentGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetDeploymentGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetDeploymentGroupsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1BatchGetDeploymentGroupsCommand = deserializeAws_json1_1BatchGetDeploymentGroupsCommand;
const deserializeAws_json1_1BatchGetDeploymentGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await deserializeAws_json1_1BatchLimitExceededExceptionResponse(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1BatchGetDeploymentInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetDeploymentInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetDeploymentInstancesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1BatchGetDeploymentInstancesCommand = deserializeAws_json1_1BatchGetDeploymentInstancesCommand;
const deserializeAws_json1_1BatchGetDeploymentInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await deserializeAws_json1_1BatchLimitExceededExceptionResponse(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "InstanceIdRequiredException":
        case "com.amazonaws.codedeploy#InstanceIdRequiredException":
            throw await deserializeAws_json1_1InstanceIdRequiredExceptionResponse(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await deserializeAws_json1_1InvalidComputePlatformExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1BatchGetDeploymentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetDeploymentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetDeploymentsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1BatchGetDeploymentsCommand = deserializeAws_json1_1BatchGetDeploymentsCommand;
const deserializeAws_json1_1BatchGetDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await deserializeAws_json1_1BatchLimitExceededExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1BatchGetDeploymentTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetDeploymentTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetDeploymentTargetsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1BatchGetDeploymentTargetsCommand = deserializeAws_json1_1BatchGetDeploymentTargetsCommand;
const deserializeAws_json1_1BatchGetDeploymentTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await deserializeAws_json1_1DeploymentNotStartedExceptionResponse(parsedOutput, context);
        case "DeploymentTargetDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentTargetDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentTargetDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentTargetIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentTargetIdRequiredException":
            throw await deserializeAws_json1_1DeploymentTargetIdRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentTargetListSizeExceededException":
        case "com.amazonaws.codedeploy#DeploymentTargetListSizeExceededException":
            throw await deserializeAws_json1_1DeploymentTargetListSizeExceededExceptionResponse(parsedOutput, context);
        case "InstanceDoesNotExistException":
        case "com.amazonaws.codedeploy#InstanceDoesNotExistException":
            throw await deserializeAws_json1_1InstanceDoesNotExistExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentTargetIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentTargetIdException":
            throw await deserializeAws_json1_1InvalidDeploymentTargetIdExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1BatchGetOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetOnPremisesInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetOnPremisesInstancesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1BatchGetOnPremisesInstancesCommand = deserializeAws_json1_1BatchGetOnPremisesInstancesCommand;
const deserializeAws_json1_1BatchGetOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BatchLimitExceededException":
        case "com.amazonaws.codedeploy#BatchLimitExceededException":
            throw await deserializeAws_json1_1BatchLimitExceededExceptionResponse(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await deserializeAws_json1_1InstanceNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ContinueDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ContinueDeploymentCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ContinueDeploymentCommand = deserializeAws_json1_1ContinueDeploymentCommand;
const deserializeAws_json1_1ContinueDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentAlreadyCompletedException":
        case "com.amazonaws.codedeploy#DeploymentAlreadyCompletedException":
            throw await deserializeAws_json1_1DeploymentAlreadyCompletedExceptionResponse(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentIsNotInReadyStateException":
        case "com.amazonaws.codedeploy#DeploymentIsNotInReadyStateException":
            throw await deserializeAws_json1_1DeploymentIsNotInReadyStateExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentStatusException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStatusException":
            throw await deserializeAws_json1_1InvalidDeploymentStatusExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentWaitTypeException":
        case "com.amazonaws.codedeploy#InvalidDeploymentWaitTypeException":
            throw await deserializeAws_json1_1InvalidDeploymentWaitTypeExceptionResponse(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await deserializeAws_json1_1UnsupportedActionForDeploymentTypeExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateApplicationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateApplicationOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateApplicationCommand = deserializeAws_json1_1CreateApplicationCommand;
const deserializeAws_json1_1CreateApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationAlreadyExistsException":
        case "com.amazonaws.codedeploy#ApplicationAlreadyExistsException":
            throw await deserializeAws_json1_1ApplicationAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ApplicationLimitExceededException":
        case "com.amazonaws.codedeploy#ApplicationLimitExceededException":
            throw await deserializeAws_json1_1ApplicationLimitExceededExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await deserializeAws_json1_1InvalidComputePlatformExceptionResponse(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await deserializeAws_json1_1InvalidTagsToAddExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateDeploymentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateDeploymentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateDeploymentCommand = deserializeAws_json1_1CreateDeploymentCommand;
const deserializeAws_json1_1CreateDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlarmsLimitExceededException":
        case "com.amazonaws.codedeploy#AlarmsLimitExceededException":
            throw await deserializeAws_json1_1AlarmsLimitExceededExceptionResponse(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentLimitExceededException":
        case "com.amazonaws.codedeploy#DeploymentLimitExceededException":
            throw await deserializeAws_json1_1DeploymentLimitExceededExceptionResponse(parsedOutput, context);
        case "DescriptionTooLongException":
        case "com.amazonaws.codedeploy#DescriptionTooLongException":
            throw await deserializeAws_json1_1DescriptionTooLongExceptionResponse(parsedOutput, context);
        case "InvalidAlarmConfigException":
        case "com.amazonaws.codedeploy#InvalidAlarmConfigException":
            throw await deserializeAws_json1_1InvalidAlarmConfigExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidAutoRollbackConfigException":
        case "com.amazonaws.codedeploy#InvalidAutoRollbackConfigException":
            throw await deserializeAws_json1_1InvalidAutoRollbackConfigExceptionResponse(parsedOutput, context);
        case "InvalidAutoScalingGroupException":
        case "com.amazonaws.codedeploy#InvalidAutoScalingGroupException":
            throw await deserializeAws_json1_1InvalidAutoScalingGroupExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await deserializeAws_json1_1InvalidDeploymentConfigNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse(parsedOutput, context);
        case "InvalidFileExistsBehaviorException":
        case "com.amazonaws.codedeploy#InvalidFileExistsBehaviorException":
            throw await deserializeAws_json1_1InvalidFileExistsBehaviorExceptionResponse(parsedOutput, context);
        case "InvalidGitHubAccountTokenException":
        case "com.amazonaws.codedeploy#InvalidGitHubAccountTokenException":
            throw await deserializeAws_json1_1InvalidGitHubAccountTokenExceptionResponse(parsedOutput, context);
        case "InvalidIgnoreApplicationStopFailuresValueException":
        case "com.amazonaws.codedeploy#InvalidIgnoreApplicationStopFailuresValueException":
            throw await deserializeAws_json1_1InvalidIgnoreApplicationStopFailuresValueExceptionResponse(parsedOutput, context);
        case "InvalidLoadBalancerInfoException":
        case "com.amazonaws.codedeploy#InvalidLoadBalancerInfoException":
            throw await deserializeAws_json1_1InvalidLoadBalancerInfoExceptionResponse(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await deserializeAws_json1_1InvalidRevisionExceptionResponse(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await deserializeAws_json1_1InvalidRoleExceptionResponse(parsedOutput, context);
        case "InvalidTargetInstancesException":
        case "com.amazonaws.codedeploy#InvalidTargetInstancesException":
            throw await deserializeAws_json1_1InvalidTargetInstancesExceptionResponse(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await deserializeAws_json1_1InvalidTrafficRoutingConfigurationExceptionResponse(parsedOutput, context);
        case "InvalidUpdateOutdatedInstancesOnlyValueException":
        case "com.amazonaws.codedeploy#InvalidUpdateOutdatedInstancesOnlyValueException":
            throw await deserializeAws_json1_1InvalidUpdateOutdatedInstancesOnlyValueExceptionResponse(parsedOutput, context);
        case "RevisionDoesNotExistException":
        case "com.amazonaws.codedeploy#RevisionDoesNotExistException":
            throw await deserializeAws_json1_1RevisionDoesNotExistExceptionResponse(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await deserializeAws_json1_1RevisionRequiredExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codedeploy#ThrottlingException":
            throw await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateDeploymentConfigCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateDeploymentConfigCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateDeploymentConfigOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateDeploymentConfigCommand = deserializeAws_json1_1CreateDeploymentConfigCommand;
const deserializeAws_json1_1CreateDeploymentConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentConfigAlreadyExistsException":
        case "com.amazonaws.codedeploy#DeploymentConfigAlreadyExistsException":
            throw await deserializeAws_json1_1DeploymentConfigAlreadyExistsExceptionResponse(parsedOutput, context);
        case "DeploymentConfigLimitExceededException":
        case "com.amazonaws.codedeploy#DeploymentConfigLimitExceededException":
            throw await deserializeAws_json1_1DeploymentConfigLimitExceededExceptionResponse(parsedOutput, context);
        case "DeploymentConfigNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentConfigNameRequiredException":
            throw await deserializeAws_json1_1DeploymentConfigNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await deserializeAws_json1_1InvalidComputePlatformExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await deserializeAws_json1_1InvalidDeploymentConfigNameExceptionResponse(parsedOutput, context);
        case "InvalidMinimumHealthyHostValueException":
        case "com.amazonaws.codedeploy#InvalidMinimumHealthyHostValueException":
            throw await deserializeAws_json1_1InvalidMinimumHealthyHostValueExceptionResponse(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await deserializeAws_json1_1InvalidTrafficRoutingConfigurationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateDeploymentGroupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateDeploymentGroupCommand = deserializeAws_json1_1CreateDeploymentGroupCommand;
const deserializeAws_json1_1CreateDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlarmsLimitExceededException":
        case "com.amazonaws.codedeploy#AlarmsLimitExceededException":
            throw await deserializeAws_json1_1AlarmsLimitExceededExceptionResponse(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupAlreadyExistsException":
        case "com.amazonaws.codedeploy#DeploymentGroupAlreadyExistsException":
            throw await deserializeAws_json1_1DeploymentGroupAlreadyExistsExceptionResponse(parsedOutput, context);
        case "DeploymentGroupLimitExceededException":
        case "com.amazonaws.codedeploy#DeploymentGroupLimitExceededException":
            throw await deserializeAws_json1_1DeploymentGroupLimitExceededExceptionResponse(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse(parsedOutput, context);
        case "ECSServiceMappingLimitExceededException":
        case "com.amazonaws.codedeploy#ECSServiceMappingLimitExceededException":
            throw await deserializeAws_json1_1ECSServiceMappingLimitExceededExceptionResponse(parsedOutput, context);
        case "InvalidAlarmConfigException":
        case "com.amazonaws.codedeploy#InvalidAlarmConfigException":
            throw await deserializeAws_json1_1InvalidAlarmConfigExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidAutoRollbackConfigException":
        case "com.amazonaws.codedeploy#InvalidAutoRollbackConfigException":
            throw await deserializeAws_json1_1InvalidAutoRollbackConfigExceptionResponse(parsedOutput, context);
        case "InvalidAutoScalingGroupException":
        case "com.amazonaws.codedeploy#InvalidAutoScalingGroupException":
            throw await deserializeAws_json1_1InvalidAutoScalingGroupExceptionResponse(parsedOutput, context);
        case "InvalidBlueGreenDeploymentConfigurationException":
        case "com.amazonaws.codedeploy#InvalidBlueGreenDeploymentConfigurationException":
            throw await deserializeAws_json1_1InvalidBlueGreenDeploymentConfigurationExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await deserializeAws_json1_1InvalidDeploymentConfigNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentStyleException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStyleException":
            throw await deserializeAws_json1_1InvalidDeploymentStyleExceptionResponse(parsedOutput, context);
        case "InvalidEC2TagCombinationException":
        case "com.amazonaws.codedeploy#InvalidEC2TagCombinationException":
            throw await deserializeAws_json1_1InvalidEC2TagCombinationExceptionResponse(parsedOutput, context);
        case "InvalidEC2TagException":
        case "com.amazonaws.codedeploy#InvalidEC2TagException":
            throw await deserializeAws_json1_1InvalidEC2TagExceptionResponse(parsedOutput, context);
        case "InvalidECSServiceException":
        case "com.amazonaws.codedeploy#InvalidECSServiceException":
            throw await deserializeAws_json1_1InvalidECSServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.codedeploy#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "InvalidLoadBalancerInfoException":
        case "com.amazonaws.codedeploy#InvalidLoadBalancerInfoException":
            throw await deserializeAws_json1_1InvalidLoadBalancerInfoExceptionResponse(parsedOutput, context);
        case "InvalidOnPremisesTagCombinationException":
        case "com.amazonaws.codedeploy#InvalidOnPremisesTagCombinationException":
            throw await deserializeAws_json1_1InvalidOnPremisesTagCombinationExceptionResponse(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await deserializeAws_json1_1InvalidRoleExceptionResponse(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await deserializeAws_json1_1InvalidTagExceptionResponse(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await deserializeAws_json1_1InvalidTagsToAddExceptionResponse(parsedOutput, context);
        case "InvalidTargetGroupPairException":
        case "com.amazonaws.codedeploy#InvalidTargetGroupPairException":
            throw await deserializeAws_json1_1InvalidTargetGroupPairExceptionResponse(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await deserializeAws_json1_1InvalidTrafficRoutingConfigurationExceptionResponse(parsedOutput, context);
        case "InvalidTriggerConfigException":
        case "com.amazonaws.codedeploy#InvalidTriggerConfigException":
            throw await deserializeAws_json1_1InvalidTriggerConfigExceptionResponse(parsedOutput, context);
        case "LifecycleHookLimitExceededException":
        case "com.amazonaws.codedeploy#LifecycleHookLimitExceededException":
            throw await deserializeAws_json1_1LifecycleHookLimitExceededExceptionResponse(parsedOutput, context);
        case "RoleRequiredException":
        case "com.amazonaws.codedeploy#RoleRequiredException":
            throw await deserializeAws_json1_1RoleRequiredExceptionResponse(parsedOutput, context);
        case "TagSetListLimitExceededException":
        case "com.amazonaws.codedeploy#TagSetListLimitExceededException":
            throw await deserializeAws_json1_1TagSetListLimitExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codedeploy#ThrottlingException":
            throw await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context);
        case "TriggerTargetsLimitExceededException":
        case "com.amazonaws.codedeploy#TriggerTargetsLimitExceededException":
            throw await deserializeAws_json1_1TriggerTargetsLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteApplicationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteApplicationCommand = deserializeAws_json1_1DeleteApplicationCommand;
const deserializeAws_json1_1DeleteApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await deserializeAws_json1_1InvalidRoleExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteDeploymentConfigCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteDeploymentConfigCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteDeploymentConfigCommand = deserializeAws_json1_1DeleteDeploymentConfigCommand;
const deserializeAws_json1_1DeleteDeploymentConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentConfigInUseException":
        case "com.amazonaws.codedeploy#DeploymentConfigInUseException":
            throw await deserializeAws_json1_1DeploymentConfigInUseExceptionResponse(parsedOutput, context);
        case "DeploymentConfigNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentConfigNameRequiredException":
            throw await deserializeAws_json1_1DeploymentConfigNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await deserializeAws_json1_1InvalidDeploymentConfigNameExceptionResponse(parsedOutput, context);
        case "InvalidOperationException":
        case "com.amazonaws.codedeploy#InvalidOperationException":
            throw await deserializeAws_json1_1InvalidOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteDeploymentGroupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteDeploymentGroupCommand = deserializeAws_json1_1DeleteDeploymentGroupCommand;
const deserializeAws_json1_1DeleteDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await deserializeAws_json1_1InvalidRoleExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteGitHubAccountTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteGitHubAccountTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteGitHubAccountTokenOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteGitHubAccountTokenCommand = deserializeAws_json1_1DeleteGitHubAccountTokenCommand;
const deserializeAws_json1_1DeleteGitHubAccountTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GitHubAccountTokenDoesNotExistException":
        case "com.amazonaws.codedeploy#GitHubAccountTokenDoesNotExistException":
            throw await deserializeAws_json1_1GitHubAccountTokenDoesNotExistExceptionResponse(parsedOutput, context);
        case "GitHubAccountTokenNameRequiredException":
        case "com.amazonaws.codedeploy#GitHubAccountTokenNameRequiredException":
            throw await deserializeAws_json1_1GitHubAccountTokenNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidGitHubAccountTokenNameException":
        case "com.amazonaws.codedeploy#InvalidGitHubAccountTokenNameException":
            throw await deserializeAws_json1_1InvalidGitHubAccountTokenNameExceptionResponse(parsedOutput, context);
        case "OperationNotSupportedException":
        case "com.amazonaws.codedeploy#OperationNotSupportedException":
            throw await deserializeAws_json1_1OperationNotSupportedExceptionResponse(parsedOutput, context);
        case "ResourceValidationException":
        case "com.amazonaws.codedeploy#ResourceValidationException":
            throw await deserializeAws_json1_1ResourceValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteResourcesByExternalIdCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteResourcesByExternalIdCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteResourcesByExternalIdOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteResourcesByExternalIdCommand = deserializeAws_json1_1DeleteResourcesByExternalIdCommand;
const deserializeAws_json1_1DeleteResourcesByExternalIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    (0, smithy_client_1.throwDefaultError)({
        output,
        parsedBody,
        exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
        errorCode,
    });
};
const deserializeAws_json1_1DeregisterOnPremisesInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeregisterOnPremisesInstanceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeregisterOnPremisesInstanceCommand = deserializeAws_json1_1DeregisterOnPremisesInstanceCommand;
const deserializeAws_json1_1DeregisterOnPremisesInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await deserializeAws_json1_1InstanceNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetApplicationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetApplicationOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetApplicationCommand = deserializeAws_json1_1GetApplicationCommand;
const deserializeAws_json1_1GetApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetApplicationRevisionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetApplicationRevisionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetApplicationRevisionOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetApplicationRevisionCommand = deserializeAws_json1_1GetApplicationRevisionCommand;
const deserializeAws_json1_1GetApplicationRevisionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await deserializeAws_json1_1InvalidRevisionExceptionResponse(parsedOutput, context);
        case "RevisionDoesNotExistException":
        case "com.amazonaws.codedeploy#RevisionDoesNotExistException":
            throw await deserializeAws_json1_1RevisionDoesNotExistExceptionResponse(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await deserializeAws_json1_1RevisionRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDeploymentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDeploymentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetDeploymentCommand = deserializeAws_json1_1GetDeploymentCommand;
const deserializeAws_json1_1GetDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetDeploymentConfigCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDeploymentConfigCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDeploymentConfigOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetDeploymentConfigCommand = deserializeAws_json1_1GetDeploymentConfigCommand;
const deserializeAws_json1_1GetDeploymentConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentConfigNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentConfigNameRequiredException":
            throw await deserializeAws_json1_1DeploymentConfigNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await deserializeAws_json1_1InvalidComputePlatformExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await deserializeAws_json1_1InvalidDeploymentConfigNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDeploymentGroupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetDeploymentGroupCommand = deserializeAws_json1_1GetDeploymentGroupCommand;
const deserializeAws_json1_1GetDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetDeploymentInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDeploymentInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDeploymentInstanceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetDeploymentInstanceCommand = deserializeAws_json1_1GetDeploymentInstanceCommand;
const deserializeAws_json1_1GetDeploymentInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "InstanceDoesNotExistException":
        case "com.amazonaws.codedeploy#InstanceDoesNotExistException":
            throw await deserializeAws_json1_1InstanceDoesNotExistExceptionResponse(parsedOutput, context);
        case "InstanceIdRequiredException":
        case "com.amazonaws.codedeploy#InstanceIdRequiredException":
            throw await deserializeAws_json1_1InstanceIdRequiredExceptionResponse(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await deserializeAws_json1_1InvalidComputePlatformExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetDeploymentTargetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDeploymentTargetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDeploymentTargetOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetDeploymentTargetCommand = deserializeAws_json1_1GetDeploymentTargetCommand;
const deserializeAws_json1_1GetDeploymentTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await deserializeAws_json1_1DeploymentNotStartedExceptionResponse(parsedOutput, context);
        case "DeploymentTargetDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentTargetDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentTargetDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentTargetIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentTargetIdRequiredException":
            throw await deserializeAws_json1_1DeploymentTargetIdRequiredExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentTargetIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentTargetIdException":
            throw await deserializeAws_json1_1InvalidDeploymentTargetIdExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetOnPremisesInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetOnPremisesInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetOnPremisesInstanceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetOnPremisesInstanceCommand = deserializeAws_json1_1GetOnPremisesInstanceCommand;
const deserializeAws_json1_1GetOnPremisesInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await deserializeAws_json1_1InstanceNameRequiredExceptionResponse(parsedOutput, context);
        case "InstanceNotRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNotRegisteredException":
            throw await deserializeAws_json1_1InstanceNotRegisteredExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListApplicationRevisionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListApplicationRevisionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListApplicationRevisionsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListApplicationRevisionsCommand = deserializeAws_json1_1ListApplicationRevisionsCommand;
const deserializeAws_json1_1ListApplicationRevisionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "BucketNameFilterRequiredException":
        case "com.amazonaws.codedeploy#BucketNameFilterRequiredException":
            throw await deserializeAws_json1_1BucketNameFilterRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidBucketNameFilterException":
        case "com.amazonaws.codedeploy#InvalidBucketNameFilterException":
            throw await deserializeAws_json1_1InvalidBucketNameFilterExceptionResponse(parsedOutput, context);
        case "InvalidDeployedStateFilterException":
        case "com.amazonaws.codedeploy#InvalidDeployedStateFilterException":
            throw await deserializeAws_json1_1InvalidDeployedStateFilterExceptionResponse(parsedOutput, context);
        case "InvalidKeyPrefixFilterException":
        case "com.amazonaws.codedeploy#InvalidKeyPrefixFilterException":
            throw await deserializeAws_json1_1InvalidKeyPrefixFilterExceptionResponse(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        case "InvalidSortByException":
        case "com.amazonaws.codedeploy#InvalidSortByException":
            throw await deserializeAws_json1_1InvalidSortByExceptionResponse(parsedOutput, context);
        case "InvalidSortOrderException":
        case "com.amazonaws.codedeploy#InvalidSortOrderException":
            throw await deserializeAws_json1_1InvalidSortOrderExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListApplicationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListApplicationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListApplicationsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListApplicationsCommand = deserializeAws_json1_1ListApplicationsCommand;
const deserializeAws_json1_1ListApplicationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListDeploymentConfigsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDeploymentConfigsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDeploymentConfigsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListDeploymentConfigsCommand = deserializeAws_json1_1ListDeploymentConfigsCommand;
const deserializeAws_json1_1ListDeploymentConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListDeploymentGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDeploymentGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDeploymentGroupsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListDeploymentGroupsCommand = deserializeAws_json1_1ListDeploymentGroupsCommand;
const deserializeAws_json1_1ListDeploymentGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListDeploymentInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDeploymentInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDeploymentInstancesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListDeploymentInstancesCommand = deserializeAws_json1_1ListDeploymentInstancesCommand;
const deserializeAws_json1_1ListDeploymentInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await deserializeAws_json1_1DeploymentNotStartedExceptionResponse(parsedOutput, context);
        case "InvalidComputePlatformException":
        case "com.amazonaws.codedeploy#InvalidComputePlatformException":
            throw await deserializeAws_json1_1InvalidComputePlatformExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidDeploymentInstanceTypeException":
            throw await deserializeAws_json1_1InvalidDeploymentInstanceTypeExceptionResponse(parsedOutput, context);
        case "InvalidInstanceStatusException":
        case "com.amazonaws.codedeploy#InvalidInstanceStatusException":
            throw await deserializeAws_json1_1InvalidInstanceStatusExceptionResponse(parsedOutput, context);
        case "InvalidInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidInstanceTypeException":
            throw await deserializeAws_json1_1InvalidInstanceTypeExceptionResponse(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        case "InvalidTargetFilterNameException":
        case "com.amazonaws.codedeploy#InvalidTargetFilterNameException":
            throw await deserializeAws_json1_1InvalidTargetFilterNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListDeploymentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDeploymentsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDeploymentsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListDeploymentsCommand = deserializeAws_json1_1ListDeploymentsCommand;
const deserializeAws_json1_1ListDeploymentsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentStatusException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStatusException":
            throw await deserializeAws_json1_1InvalidDeploymentStatusExceptionResponse(parsedOutput, context);
        case "InvalidExternalIdException":
        case "com.amazonaws.codedeploy#InvalidExternalIdException":
            throw await deserializeAws_json1_1InvalidExternalIdExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.codedeploy#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        case "InvalidTimeRangeException":
        case "com.amazonaws.codedeploy#InvalidTimeRangeException":
            throw await deserializeAws_json1_1InvalidTimeRangeExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListDeploymentTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDeploymentTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDeploymentTargetsOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListDeploymentTargetsCommand = deserializeAws_json1_1ListDeploymentTargetsCommand;
const deserializeAws_json1_1ListDeploymentTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await deserializeAws_json1_1DeploymentNotStartedExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidDeploymentInstanceTypeException":
            throw await deserializeAws_json1_1InvalidDeploymentInstanceTypeExceptionResponse(parsedOutput, context);
        case "InvalidInstanceStatusException":
        case "com.amazonaws.codedeploy#InvalidInstanceStatusException":
            throw await deserializeAws_json1_1InvalidInstanceStatusExceptionResponse(parsedOutput, context);
        case "InvalidInstanceTypeException":
        case "com.amazonaws.codedeploy#InvalidInstanceTypeException":
            throw await deserializeAws_json1_1InvalidInstanceTypeExceptionResponse(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListGitHubAccountTokenNamesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListGitHubAccountTokenNamesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListGitHubAccountTokenNamesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListGitHubAccountTokenNamesCommand = deserializeAws_json1_1ListGitHubAccountTokenNamesCommand;
const deserializeAws_json1_1ListGitHubAccountTokenNamesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        case "OperationNotSupportedException":
        case "com.amazonaws.codedeploy#OperationNotSupportedException":
            throw await deserializeAws_json1_1OperationNotSupportedExceptionResponse(parsedOutput, context);
        case "ResourceValidationException":
        case "com.amazonaws.codedeploy#ResourceValidationException":
            throw await deserializeAws_json1_1ResourceValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListOnPremisesInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListOnPremisesInstancesOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListOnPremisesInstancesCommand = deserializeAws_json1_1ListOnPremisesInstancesCommand;
const deserializeAws_json1_1ListOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextTokenException":
        case "com.amazonaws.codedeploy#InvalidNextTokenException":
            throw await deserializeAws_json1_1InvalidNextTokenExceptionResponse(parsedOutput, context);
        case "InvalidRegistrationStatusException":
        case "com.amazonaws.codedeploy#InvalidRegistrationStatusException":
            throw await deserializeAws_json1_1InvalidRegistrationStatusExceptionResponse(parsedOutput, context);
        case "InvalidTagFilterException":
        case "com.amazonaws.codedeploy#InvalidTagFilterException":
            throw await deserializeAws_json1_1InvalidTagFilterExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTagsForResourceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTagsForResourceCommand = deserializeAws_json1_1ListTagsForResourceCommand;
const deserializeAws_json1_1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ArnNotSupportedException":
        case "com.amazonaws.codedeploy#ArnNotSupportedException":
            throw await deserializeAws_json1_1ArnNotSupportedExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.codedeploy#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codedeploy#ResourceArnRequiredException":
            throw await deserializeAws_json1_1ResourceArnRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutLifecycleEventHookExecutionStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutLifecycleEventHookExecutionStatusOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand = deserializeAws_json1_1PutLifecycleEventHookExecutionStatusCommand;
const deserializeAws_json1_1PutLifecycleEventHookExecutionStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "InvalidLifecycleEventHookExecutionIdException":
        case "com.amazonaws.codedeploy#InvalidLifecycleEventHookExecutionIdException":
            throw await deserializeAws_json1_1InvalidLifecycleEventHookExecutionIdExceptionResponse(parsedOutput, context);
        case "InvalidLifecycleEventHookExecutionStatusException":
        case "com.amazonaws.codedeploy#InvalidLifecycleEventHookExecutionStatusException":
            throw await deserializeAws_json1_1InvalidLifecycleEventHookExecutionStatusExceptionResponse(parsedOutput, context);
        case "LifecycleEventAlreadyCompletedException":
        case "com.amazonaws.codedeploy#LifecycleEventAlreadyCompletedException":
            throw await deserializeAws_json1_1LifecycleEventAlreadyCompletedExceptionResponse(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await deserializeAws_json1_1UnsupportedActionForDeploymentTypeExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1RegisterApplicationRevisionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RegisterApplicationRevisionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1RegisterApplicationRevisionCommand = deserializeAws_json1_1RegisterApplicationRevisionCommand;
const deserializeAws_json1_1RegisterApplicationRevisionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "DescriptionTooLongException":
        case "com.amazonaws.codedeploy#DescriptionTooLongException":
            throw await deserializeAws_json1_1DescriptionTooLongExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidRevisionException":
        case "com.amazonaws.codedeploy#InvalidRevisionException":
            throw await deserializeAws_json1_1InvalidRevisionExceptionResponse(parsedOutput, context);
        case "RevisionRequiredException":
        case "com.amazonaws.codedeploy#RevisionRequiredException":
            throw await deserializeAws_json1_1RevisionRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1RegisterOnPremisesInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RegisterOnPremisesInstanceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1RegisterOnPremisesInstanceCommand = deserializeAws_json1_1RegisterOnPremisesInstanceCommand;
const deserializeAws_json1_1RegisterOnPremisesInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IamArnRequiredException":
        case "com.amazonaws.codedeploy#IamArnRequiredException":
            throw await deserializeAws_json1_1IamArnRequiredExceptionResponse(parsedOutput, context);
        case "IamSessionArnAlreadyRegisteredException":
        case "com.amazonaws.codedeploy#IamSessionArnAlreadyRegisteredException":
            throw await deserializeAws_json1_1IamSessionArnAlreadyRegisteredExceptionResponse(parsedOutput, context);
        case "IamUserArnAlreadyRegisteredException":
        case "com.amazonaws.codedeploy#IamUserArnAlreadyRegisteredException":
            throw await deserializeAws_json1_1IamUserArnAlreadyRegisteredExceptionResponse(parsedOutput, context);
        case "IamUserArnRequiredException":
        case "com.amazonaws.codedeploy#IamUserArnRequiredException":
            throw await deserializeAws_json1_1IamUserArnRequiredExceptionResponse(parsedOutput, context);
        case "InstanceNameAlreadyRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNameAlreadyRegisteredException":
            throw await deserializeAws_json1_1InstanceNameAlreadyRegisteredExceptionResponse(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await deserializeAws_json1_1InstanceNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidIamSessionArnException":
        case "com.amazonaws.codedeploy#InvalidIamSessionArnException":
            throw await deserializeAws_json1_1InvalidIamSessionArnExceptionResponse(parsedOutput, context);
        case "InvalidIamUserArnException":
        case "com.amazonaws.codedeploy#InvalidIamUserArnException":
            throw await deserializeAws_json1_1InvalidIamUserArnExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        case "MultipleIamArnsProvidedException":
        case "com.amazonaws.codedeploy#MultipleIamArnsProvidedException":
            throw await deserializeAws_json1_1MultipleIamArnsProvidedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand = deserializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommand;
const deserializeAws_json1_1RemoveTagsFromOnPremisesInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InstanceLimitExceededException":
        case "com.amazonaws.codedeploy#InstanceLimitExceededException":
            throw await deserializeAws_json1_1InstanceLimitExceededExceptionResponse(parsedOutput, context);
        case "InstanceNameRequiredException":
        case "com.amazonaws.codedeploy#InstanceNameRequiredException":
            throw await deserializeAws_json1_1InstanceNameRequiredExceptionResponse(parsedOutput, context);
        case "InstanceNotRegisteredException":
        case "com.amazonaws.codedeploy#InstanceNotRegisteredException":
            throw await deserializeAws_json1_1InstanceNotRegisteredExceptionResponse(parsedOutput, context);
        case "InvalidInstanceNameException":
        case "com.amazonaws.codedeploy#InvalidInstanceNameException":
            throw await deserializeAws_json1_1InvalidInstanceNameExceptionResponse(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await deserializeAws_json1_1InvalidTagExceptionResponse(parsedOutput, context);
        case "TagLimitExceededException":
        case "com.amazonaws.codedeploy#TagLimitExceededException":
            throw await deserializeAws_json1_1TagLimitExceededExceptionResponse(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await deserializeAws_json1_1TagRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1SkipWaitTimeForInstanceTerminationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand = deserializeAws_json1_1SkipWaitTimeForInstanceTerminationCommand;
const deserializeAws_json1_1SkipWaitTimeForInstanceTerminationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentAlreadyCompletedException":
        case "com.amazonaws.codedeploy#DeploymentAlreadyCompletedException":
            throw await deserializeAws_json1_1DeploymentAlreadyCompletedExceptionResponse(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentNotStartedException":
        case "com.amazonaws.codedeploy#DeploymentNotStartedException":
            throw await deserializeAws_json1_1DeploymentNotStartedExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await deserializeAws_json1_1UnsupportedActionForDeploymentTypeExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1StopDeploymentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopDeploymentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopDeploymentOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StopDeploymentCommand = deserializeAws_json1_1StopDeploymentCommand;
const deserializeAws_json1_1StopDeploymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeploymentAlreadyCompletedException":
        case "com.amazonaws.codedeploy#DeploymentAlreadyCompletedException":
            throw await deserializeAws_json1_1DeploymentAlreadyCompletedExceptionResponse(parsedOutput, context);
        case "DeploymentDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentIdRequiredException":
        case "com.amazonaws.codedeploy#DeploymentIdRequiredException":
            throw await deserializeAws_json1_1DeploymentIdRequiredExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentIdException":
        case "com.amazonaws.codedeploy#InvalidDeploymentIdException":
            throw await deserializeAws_json1_1InvalidDeploymentIdExceptionResponse(parsedOutput, context);
        case "UnsupportedActionForDeploymentTypeException":
        case "com.amazonaws.codedeploy#UnsupportedActionForDeploymentTypeException":
            throw await deserializeAws_json1_1UnsupportedActionForDeploymentTypeExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1TagResourceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1TagResourceCommand = deserializeAws_json1_1TagResourceCommand;
const deserializeAws_json1_1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ArnNotSupportedException":
        case "com.amazonaws.codedeploy#ArnNotSupportedException":
            throw await deserializeAws_json1_1ArnNotSupportedExceptionResponse(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.codedeploy#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await deserializeAws_json1_1InvalidTagsToAddExceptionResponse(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codedeploy#ResourceArnRequiredException":
            throw await deserializeAws_json1_1ResourceArnRequiredExceptionResponse(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await deserializeAws_json1_1TagRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UntagResourceOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UntagResourceCommand = deserializeAws_json1_1UntagResourceCommand;
const deserializeAws_json1_1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ArnNotSupportedException":
        case "com.amazonaws.codedeploy#ArnNotSupportedException":
            throw await deserializeAws_json1_1ArnNotSupportedExceptionResponse(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.codedeploy#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidTagsToAddException":
        case "com.amazonaws.codedeploy#InvalidTagsToAddException":
            throw await deserializeAws_json1_1InvalidTagsToAddExceptionResponse(parsedOutput, context);
        case "ResourceArnRequiredException":
        case "com.amazonaws.codedeploy#ResourceArnRequiredException":
            throw await deserializeAws_json1_1ResourceArnRequiredExceptionResponse(parsedOutput, context);
        case "TagRequiredException":
        case "com.amazonaws.codedeploy#TagRequiredException":
            throw await deserializeAws_json1_1TagRequiredExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateApplicationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateApplicationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateApplicationCommand = deserializeAws_json1_1UpdateApplicationCommand;
const deserializeAws_json1_1UpdateApplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ApplicationAlreadyExistsException":
        case "com.amazonaws.codedeploy#ApplicationAlreadyExistsException":
            throw await deserializeAws_json1_1ApplicationAlreadyExistsExceptionResponse(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateDeploymentGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateDeploymentGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateDeploymentGroupOutput(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateDeploymentGroupCommand = deserializeAws_json1_1UpdateDeploymentGroupCommand;
const deserializeAws_json1_1UpdateDeploymentGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlarmsLimitExceededException":
        case "com.amazonaws.codedeploy#AlarmsLimitExceededException":
            throw await deserializeAws_json1_1AlarmsLimitExceededExceptionResponse(parsedOutput, context);
        case "ApplicationDoesNotExistException":
        case "com.amazonaws.codedeploy#ApplicationDoesNotExistException":
            throw await deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse(parsedOutput, context);
        case "ApplicationNameRequiredException":
        case "com.amazonaws.codedeploy#ApplicationNameRequiredException":
            throw await deserializeAws_json1_1ApplicationNameRequiredExceptionResponse(parsedOutput, context);
        case "DeploymentConfigDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentConfigDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupAlreadyExistsException":
        case "com.amazonaws.codedeploy#DeploymentGroupAlreadyExistsException":
            throw await deserializeAws_json1_1DeploymentGroupAlreadyExistsExceptionResponse(parsedOutput, context);
        case "DeploymentGroupDoesNotExistException":
        case "com.amazonaws.codedeploy#DeploymentGroupDoesNotExistException":
            throw await deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse(parsedOutput, context);
        case "DeploymentGroupNameRequiredException":
        case "com.amazonaws.codedeploy#DeploymentGroupNameRequiredException":
            throw await deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse(parsedOutput, context);
        case "ECSServiceMappingLimitExceededException":
        case "com.amazonaws.codedeploy#ECSServiceMappingLimitExceededException":
            throw await deserializeAws_json1_1ECSServiceMappingLimitExceededExceptionResponse(parsedOutput, context);
        case "InvalidAlarmConfigException":
        case "com.amazonaws.codedeploy#InvalidAlarmConfigException":
            throw await deserializeAws_json1_1InvalidAlarmConfigExceptionResponse(parsedOutput, context);
        case "InvalidApplicationNameException":
        case "com.amazonaws.codedeploy#InvalidApplicationNameException":
            throw await deserializeAws_json1_1InvalidApplicationNameExceptionResponse(parsedOutput, context);
        case "InvalidAutoRollbackConfigException":
        case "com.amazonaws.codedeploy#InvalidAutoRollbackConfigException":
            throw await deserializeAws_json1_1InvalidAutoRollbackConfigExceptionResponse(parsedOutput, context);
        case "InvalidAutoScalingGroupException":
        case "com.amazonaws.codedeploy#InvalidAutoScalingGroupException":
            throw await deserializeAws_json1_1InvalidAutoScalingGroupExceptionResponse(parsedOutput, context);
        case "InvalidBlueGreenDeploymentConfigurationException":
        case "com.amazonaws.codedeploy#InvalidBlueGreenDeploymentConfigurationException":
            throw await deserializeAws_json1_1InvalidBlueGreenDeploymentConfigurationExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentConfigNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentConfigNameException":
            throw await deserializeAws_json1_1InvalidDeploymentConfigNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentGroupNameException":
        case "com.amazonaws.codedeploy#InvalidDeploymentGroupNameException":
            throw await deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse(parsedOutput, context);
        case "InvalidDeploymentStyleException":
        case "com.amazonaws.codedeploy#InvalidDeploymentStyleException":
            throw await deserializeAws_json1_1InvalidDeploymentStyleExceptionResponse(parsedOutput, context);
        case "InvalidEC2TagCombinationException":
        case "com.amazonaws.codedeploy#InvalidEC2TagCombinationException":
            throw await deserializeAws_json1_1InvalidEC2TagCombinationExceptionResponse(parsedOutput, context);
        case "InvalidEC2TagException":
        case "com.amazonaws.codedeploy#InvalidEC2TagException":
            throw await deserializeAws_json1_1InvalidEC2TagExceptionResponse(parsedOutput, context);
        case "InvalidECSServiceException":
        case "com.amazonaws.codedeploy#InvalidECSServiceException":
            throw await deserializeAws_json1_1InvalidECSServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.codedeploy#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "InvalidLoadBalancerInfoException":
        case "com.amazonaws.codedeploy#InvalidLoadBalancerInfoException":
            throw await deserializeAws_json1_1InvalidLoadBalancerInfoExceptionResponse(parsedOutput, context);
        case "InvalidOnPremisesTagCombinationException":
        case "com.amazonaws.codedeploy#InvalidOnPremisesTagCombinationException":
            throw await deserializeAws_json1_1InvalidOnPremisesTagCombinationExceptionResponse(parsedOutput, context);
        case "InvalidRoleException":
        case "com.amazonaws.codedeploy#InvalidRoleException":
            throw await deserializeAws_json1_1InvalidRoleExceptionResponse(parsedOutput, context);
        case "InvalidTagException":
        case "com.amazonaws.codedeploy#InvalidTagException":
            throw await deserializeAws_json1_1InvalidTagExceptionResponse(parsedOutput, context);
        case "InvalidTargetGroupPairException":
        case "com.amazonaws.codedeploy#InvalidTargetGroupPairException":
            throw await deserializeAws_json1_1InvalidTargetGroupPairExceptionResponse(parsedOutput, context);
        case "InvalidTrafficRoutingConfigurationException":
        case "com.amazonaws.codedeploy#InvalidTrafficRoutingConfigurationException":
            throw await deserializeAws_json1_1InvalidTrafficRoutingConfigurationExceptionResponse(parsedOutput, context);
        case "InvalidTriggerConfigException":
        case "com.amazonaws.codedeploy#InvalidTriggerConfigException":
            throw await deserializeAws_json1_1InvalidTriggerConfigExceptionResponse(parsedOutput, context);
        case "LifecycleHookLimitExceededException":
        case "com.amazonaws.codedeploy#LifecycleHookLimitExceededException":
            throw await deserializeAws_json1_1LifecycleHookLimitExceededExceptionResponse(parsedOutput, context);
        case "TagSetListLimitExceededException":
        case "com.amazonaws.codedeploy#TagSetListLimitExceededException":
            throw await deserializeAws_json1_1TagSetListLimitExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codedeploy#ThrottlingException":
            throw await deserializeAws_json1_1ThrottlingExceptionResponse(parsedOutput, context);
        case "TriggerTargetsLimitExceededException":
        case "com.amazonaws.codedeploy#TriggerTargetsLimitExceededException":
            throw await deserializeAws_json1_1TriggerTargetsLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: CodeDeployServiceException_1.CodeDeployServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1AlarmsLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1AlarmsLimitExceededException(body, context);
    const exception = new models_0_1.AlarmsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ApplicationAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ApplicationAlreadyExistsException(body, context);
    const exception = new models_0_1.ApplicationAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ApplicationDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ApplicationDoesNotExistException(body, context);
    const exception = new models_0_1.ApplicationDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ApplicationLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ApplicationLimitExceededException(body, context);
    const exception = new models_0_1.ApplicationLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ApplicationNameRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ApplicationNameRequiredException(body, context);
    const exception = new models_0_1.ApplicationNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ArnNotSupportedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ArnNotSupportedException(body, context);
    const exception = new models_0_1.ArnNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1BatchLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1BatchLimitExceededException(body, context);
    const exception = new models_0_1.BatchLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1BucketNameFilterRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1BucketNameFilterRequiredException(body, context);
    const exception = new models_0_1.BucketNameFilterRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentAlreadyCompletedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentAlreadyCompletedException(body, context);
    const exception = new models_0_1.DeploymentAlreadyCompletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentConfigAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentConfigAlreadyExistsException(body, context);
    const exception = new models_0_1.DeploymentConfigAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentConfigDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentConfigDoesNotExistException(body, context);
    const exception = new models_0_1.DeploymentConfigDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentConfigInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentConfigInUseException(body, context);
    const exception = new models_0_1.DeploymentConfigInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentConfigLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentConfigLimitExceededException(body, context);
    const exception = new models_0_1.DeploymentConfigLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentConfigNameRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentConfigNameRequiredException(body, context);
    const exception = new models_0_1.DeploymentConfigNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentDoesNotExistException(body, context);
    const exception = new models_0_1.DeploymentDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentGroupAlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentGroupAlreadyExistsException(body, context);
    const exception = new models_0_1.DeploymentGroupAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentGroupDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentGroupDoesNotExistException(body, context);
    const exception = new models_0_1.DeploymentGroupDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentGroupLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentGroupLimitExceededException(body, context);
    const exception = new models_0_1.DeploymentGroupLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentGroupNameRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentGroupNameRequiredException(body, context);
    const exception = new models_0_1.DeploymentGroupNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentIdRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentIdRequiredException(body, context);
    const exception = new models_0_1.DeploymentIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentIsNotInReadyStateExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentIsNotInReadyStateException(body, context);
    const exception = new models_0_1.DeploymentIsNotInReadyStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentLimitExceededException(body, context);
    const exception = new models_0_1.DeploymentLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentNotStartedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentNotStartedException(body, context);
    const exception = new models_0_1.DeploymentNotStartedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentTargetDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentTargetDoesNotExistException(body, context);
    const exception = new models_0_1.DeploymentTargetDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentTargetIdRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentTargetIdRequiredException(body, context);
    const exception = new models_0_1.DeploymentTargetIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DeploymentTargetListSizeExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DeploymentTargetListSizeExceededException(body, context);
    const exception = new models_0_1.DeploymentTargetListSizeExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1DescriptionTooLongExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DescriptionTooLongException(body, context);
    const exception = new models_0_1.DescriptionTooLongException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ECSServiceMappingLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ECSServiceMappingLimitExceededException(body, context);
    const exception = new models_0_1.ECSServiceMappingLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1GitHubAccountTokenDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1GitHubAccountTokenDoesNotExistException(body, context);
    const exception = new models_0_1.GitHubAccountTokenDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1GitHubAccountTokenNameRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1GitHubAccountTokenNameRequiredException(body, context);
    const exception = new models_0_1.GitHubAccountTokenNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1IamArnRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IamArnRequiredException(body, context);
    const exception = new models_0_1.IamArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1IamSessionArnAlreadyRegisteredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IamSessionArnAlreadyRegisteredException(body, context);
    const exception = new models_0_1.IamSessionArnAlreadyRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1IamUserArnAlreadyRegisteredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IamUserArnAlreadyRegisteredException(body, context);
    const exception = new models_0_1.IamUserArnAlreadyRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1IamUserArnRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IamUserArnRequiredException(body, context);
    const exception = new models_0_1.IamUserArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InstanceDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InstanceDoesNotExistException(body, context);
    const exception = new models_0_1.InstanceDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InstanceIdRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InstanceIdRequiredException(body, context);
    const exception = new models_0_1.InstanceIdRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InstanceLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InstanceLimitExceededException(body, context);
    const exception = new models_0_1.InstanceLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InstanceNameAlreadyRegisteredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InstanceNameAlreadyRegisteredException(body, context);
    const exception = new models_0_1.InstanceNameAlreadyRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InstanceNameRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InstanceNameRequiredException(body, context);
    const exception = new models_0_1.InstanceNameRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InstanceNotRegisteredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InstanceNotRegisteredException(body, context);
    const exception = new models_0_1.InstanceNotRegisteredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidAlarmConfigExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidAlarmConfigException(body, context);
    const exception = new models_0_1.InvalidAlarmConfigException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidApplicationNameExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidApplicationNameException(body, context);
    const exception = new models_0_1.InvalidApplicationNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidArnExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidArnException(body, context);
    const exception = new models_0_1.InvalidArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidAutoRollbackConfigExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidAutoRollbackConfigException(body, context);
    const exception = new models_0_1.InvalidAutoRollbackConfigException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidAutoScalingGroupExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidAutoScalingGroupException(body, context);
    const exception = new models_0_1.InvalidAutoScalingGroupException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidBlueGreenDeploymentConfigurationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidBlueGreenDeploymentConfigurationException(body, context);
    const exception = new models_0_1.InvalidBlueGreenDeploymentConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidBucketNameFilterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidBucketNameFilterException(body, context);
    const exception = new models_0_1.InvalidBucketNameFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidComputePlatformExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidComputePlatformException(body, context);
    const exception = new models_0_1.InvalidComputePlatformException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeployedStateFilterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeployedStateFilterException(body, context);
    const exception = new models_0_1.InvalidDeployedStateFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentConfigNameExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentConfigNameException(body, context);
    const exception = new models_0_1.InvalidDeploymentConfigNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentGroupNameExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentGroupNameException(body, context);
    const exception = new models_0_1.InvalidDeploymentGroupNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentIdExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentIdException(body, context);
    const exception = new models_0_1.InvalidDeploymentIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentInstanceTypeExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentInstanceTypeException(body, context);
    const exception = new models_0_1.InvalidDeploymentInstanceTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentStatusExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentStatusException(body, context);
    const exception = new models_0_1.InvalidDeploymentStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentStyleExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentStyleException(body, context);
    const exception = new models_0_1.InvalidDeploymentStyleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentTargetIdExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentTargetIdException(body, context);
    const exception = new models_0_1.InvalidDeploymentTargetIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidDeploymentWaitTypeExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidDeploymentWaitTypeException(body, context);
    const exception = new models_0_1.InvalidDeploymentWaitTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidEC2TagCombinationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidEC2TagCombinationException(body, context);
    const exception = new models_0_1.InvalidEC2TagCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidEC2TagExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidEC2TagException(body, context);
    const exception = new models_0_1.InvalidEC2TagException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidECSServiceExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidECSServiceException(body, context);
    const exception = new models_0_1.InvalidECSServiceException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidExternalIdExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidExternalIdException(body, context);
    const exception = new models_0_1.InvalidExternalIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidFileExistsBehaviorExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidFileExistsBehaviorException(body, context);
    const exception = new models_0_1.InvalidFileExistsBehaviorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidGitHubAccountTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidGitHubAccountTokenException(body, context);
    const exception = new models_0_1.InvalidGitHubAccountTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidGitHubAccountTokenNameExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidGitHubAccountTokenNameException(body, context);
    const exception = new models_0_1.InvalidGitHubAccountTokenNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidIamSessionArnExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidIamSessionArnException(body, context);
    const exception = new models_0_1.InvalidIamSessionArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidIamUserArnExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidIamUserArnException(body, context);
    const exception = new models_0_1.InvalidIamUserArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidIgnoreApplicationStopFailuresValueExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidIgnoreApplicationStopFailuresValueException(body, context);
    const exception = new models_0_1.InvalidIgnoreApplicationStopFailuresValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidInputExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidInputException(body, context);
    const exception = new models_0_1.InvalidInputException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidInstanceNameExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidInstanceNameException(body, context);
    const exception = new models_0_1.InvalidInstanceNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidInstanceStatusExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidInstanceStatusException(body, context);
    const exception = new models_0_1.InvalidInstanceStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidInstanceTypeExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidInstanceTypeException(body, context);
    const exception = new models_0_1.InvalidInstanceTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidKeyPrefixFilterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidKeyPrefixFilterException(body, context);
    const exception = new models_0_1.InvalidKeyPrefixFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidLifecycleEventHookExecutionIdExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidLifecycleEventHookExecutionIdException(body, context);
    const exception = new models_0_1.InvalidLifecycleEventHookExecutionIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidLifecycleEventHookExecutionStatusExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidLifecycleEventHookExecutionStatusException(body, context);
    const exception = new models_0_1.InvalidLifecycleEventHookExecutionStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidLoadBalancerInfoExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidLoadBalancerInfoException(body, context);
    const exception = new models_0_1.InvalidLoadBalancerInfoException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidMinimumHealthyHostValueExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidMinimumHealthyHostValueException(body, context);
    const exception = new models_0_1.InvalidMinimumHealthyHostValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidNextTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidNextTokenException(body, context);
    const exception = new models_0_1.InvalidNextTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidOnPremisesTagCombinationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidOnPremisesTagCombinationException(body, context);
    const exception = new models_0_1.InvalidOnPremisesTagCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidOperationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidOperationException(body, context);
    const exception = new models_0_1.InvalidOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidRegistrationStatusExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidRegistrationStatusException(body, context);
    const exception = new models_0_1.InvalidRegistrationStatusException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidRevisionExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidRevisionException(body, context);
    const exception = new models_0_1.InvalidRevisionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidRoleExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidRoleException(body, context);
    const exception = new models_0_1.InvalidRoleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidSortByExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidSortByException(body, context);
    const exception = new models_0_1.InvalidSortByException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidSortOrderExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidSortOrderException(body, context);
    const exception = new models_0_1.InvalidSortOrderException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTagExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTagException(body, context);
    const exception = new models_0_1.InvalidTagException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTagFilterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTagFilterException(body, context);
    const exception = new models_0_1.InvalidTagFilterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTagsToAddExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTagsToAddException(body, context);
    const exception = new models_0_1.InvalidTagsToAddException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTargetFilterNameExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTargetFilterNameException(body, context);
    const exception = new models_0_1.InvalidTargetFilterNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTargetGroupPairExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTargetGroupPairException(body, context);
    const exception = new models_0_1.InvalidTargetGroupPairException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTargetInstancesExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTargetInstancesException(body, context);
    const exception = new models_0_1.InvalidTargetInstancesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTimeRangeExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTimeRangeException(body, context);
    const exception = new models_0_1.InvalidTimeRangeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTrafficRoutingConfigurationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTrafficRoutingConfigurationException(body, context);
    const exception = new models_0_1.InvalidTrafficRoutingConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidTriggerConfigExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidTriggerConfigException(body, context);
    const exception = new models_0_1.InvalidTriggerConfigException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidUpdateOutdatedInstancesOnlyValueExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidUpdateOutdatedInstancesOnlyValueException(body, context);
    const exception = new models_0_1.InvalidUpdateOutdatedInstancesOnlyValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1LifecycleEventAlreadyCompletedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LifecycleEventAlreadyCompletedException(body, context);
    const exception = new models_0_1.LifecycleEventAlreadyCompletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1LifecycleHookLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LifecycleHookLimitExceededException(body, context);
    const exception = new models_0_1.LifecycleHookLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1MultipleIamArnsProvidedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1MultipleIamArnsProvidedException(body, context);
    const exception = new models_0_1.MultipleIamArnsProvidedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1OperationNotSupportedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1OperationNotSupportedException(body, context);
    const exception = new models_0_1.OperationNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ResourceArnRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceArnRequiredException(body, context);
    const exception = new models_0_1.ResourceArnRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ResourceValidationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceValidationException(body, context);
    const exception = new models_0_1.ResourceValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1RevisionDoesNotExistExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1RevisionDoesNotExistException(body, context);
    const exception = new models_0_1.RevisionDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1RevisionRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1RevisionRequiredException(body, context);
    const exception = new models_0_1.RevisionRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1RoleRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1RoleRequiredException(body, context);
    const exception = new models_0_1.RoleRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TagLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TagLimitExceededException(body, context);
    const exception = new models_0_1.TagLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TagRequiredExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TagRequiredException(body, context);
    const exception = new models_0_1.TagRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TagSetListLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TagSetListLimitExceededException(body, context);
    const exception = new models_0_1.TagSetListLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ThrottlingExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ThrottlingException(body, context);
    const exception = new models_0_1.ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TriggerTargetsLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TriggerTargetsLimitExceededException(body, context);
    const exception = new models_0_1.TriggerTargetsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1UnsupportedActionForDeploymentTypeExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UnsupportedActionForDeploymentTypeException(body, context);
    const exception = new models_0_1.UnsupportedActionForDeploymentTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const serializeAws_json1_1AddTagsToOnPremisesInstancesInput = (input, context) => {
    return {
        ...(input.instanceNames != null && {
            instanceNames: serializeAws_json1_1InstanceNameList(input.instanceNames, context),
        }),
        ...(input.tags != null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    };
};
const serializeAws_json1_1Alarm = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
    };
};
const serializeAws_json1_1AlarmConfiguration = (input, context) => {
    return {
        ...(input.alarms != null && { alarms: serializeAws_json1_1AlarmList(input.alarms, context) }),
        ...(input.enabled != null && { enabled: input.enabled }),
        ...(input.ignorePollAlarmFailure != null && { ignorePollAlarmFailure: input.ignorePollAlarmFailure }),
    };
};
const serializeAws_json1_1AlarmList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Alarm(entry, context);
    });
};
const serializeAws_json1_1ApplicationsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1AppSpecContent = (input, context) => {
    return {
        ...(input.content != null && { content: input.content }),
        ...(input.sha256 != null && { sha256: input.sha256 }),
    };
};
const serializeAws_json1_1AutoRollbackConfiguration = (input, context) => {
    return {
        ...(input.enabled != null && { enabled: input.enabled }),
        ...(input.events != null && { events: serializeAws_json1_1AutoRollbackEventsList(input.events, context) }),
    };
};
const serializeAws_json1_1AutoRollbackEventsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1AutoScalingGroupNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1BatchGetApplicationRevisionsInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.revisions != null && { revisions: serializeAws_json1_1RevisionLocationList(input.revisions, context) }),
    };
};
const serializeAws_json1_1BatchGetApplicationsInput = (input, context) => {
    return {
        ...(input.applicationNames != null && {
            applicationNames: serializeAws_json1_1ApplicationsList(input.applicationNames, context),
        }),
    };
};
const serializeAws_json1_1BatchGetDeploymentGroupsInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.deploymentGroupNames != null && {
            deploymentGroupNames: serializeAws_json1_1DeploymentGroupsList(input.deploymentGroupNames, context),
        }),
    };
};
const serializeAws_json1_1BatchGetDeploymentInstancesInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.instanceIds != null && { instanceIds: serializeAws_json1_1InstancesList(input.instanceIds, context) }),
    };
};
const serializeAws_json1_1BatchGetDeploymentsInput = (input, context) => {
    return {
        ...(input.deploymentIds != null && {
            deploymentIds: serializeAws_json1_1DeploymentsList(input.deploymentIds, context),
        }),
    };
};
const serializeAws_json1_1BatchGetDeploymentTargetsInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.targetIds != null && { targetIds: serializeAws_json1_1TargetIdList(input.targetIds, context) }),
    };
};
const serializeAws_json1_1BatchGetOnPremisesInstancesInput = (input, context) => {
    return {
        ...(input.instanceNames != null && {
            instanceNames: serializeAws_json1_1InstanceNameList(input.instanceNames, context),
        }),
    };
};
const serializeAws_json1_1BlueGreenDeploymentConfiguration = (input, context) => {
    return {
        ...(input.deploymentReadyOption != null && {
            deploymentReadyOption: serializeAws_json1_1DeploymentReadyOption(input.deploymentReadyOption, context),
        }),
        ...(input.greenFleetProvisioningOption != null && {
            greenFleetProvisioningOption: serializeAws_json1_1GreenFleetProvisioningOption(input.greenFleetProvisioningOption, context),
        }),
        ...(input.terminateBlueInstancesOnDeploymentSuccess != null && {
            terminateBlueInstancesOnDeploymentSuccess: serializeAws_json1_1BlueInstanceTerminationOption(input.terminateBlueInstancesOnDeploymentSuccess, context),
        }),
    };
};
const serializeAws_json1_1BlueInstanceTerminationOption = (input, context) => {
    return {
        ...(input.action != null && { action: input.action }),
        ...(input.terminationWaitTimeInMinutes != null && {
            terminationWaitTimeInMinutes: input.terminationWaitTimeInMinutes,
        }),
    };
};
const serializeAws_json1_1ContinueDeploymentInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.deploymentWaitType != null && { deploymentWaitType: input.deploymentWaitType }),
    };
};
const serializeAws_json1_1CreateApplicationInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.computePlatform != null && { computePlatform: input.computePlatform }),
        ...(input.tags != null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    };
};
const serializeAws_json1_1CreateDeploymentConfigInput = (input, context) => {
    return {
        ...(input.computePlatform != null && { computePlatform: input.computePlatform }),
        ...(input.deploymentConfigName != null && { deploymentConfigName: input.deploymentConfigName }),
        ...(input.minimumHealthyHosts != null && {
            minimumHealthyHosts: serializeAws_json1_1MinimumHealthyHosts(input.minimumHealthyHosts, context),
        }),
        ...(input.trafficRoutingConfig != null && {
            trafficRoutingConfig: serializeAws_json1_1TrafficRoutingConfig(input.trafficRoutingConfig, context),
        }),
    };
};
const serializeAws_json1_1CreateDeploymentGroupInput = (input, context) => {
    return {
        ...(input.alarmConfiguration != null && {
            alarmConfiguration: serializeAws_json1_1AlarmConfiguration(input.alarmConfiguration, context),
        }),
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.autoRollbackConfiguration != null && {
            autoRollbackConfiguration: serializeAws_json1_1AutoRollbackConfiguration(input.autoRollbackConfiguration, context),
        }),
        ...(input.autoScalingGroups != null && {
            autoScalingGroups: serializeAws_json1_1AutoScalingGroupNameList(input.autoScalingGroups, context),
        }),
        ...(input.blueGreenDeploymentConfiguration != null && {
            blueGreenDeploymentConfiguration: serializeAws_json1_1BlueGreenDeploymentConfiguration(input.blueGreenDeploymentConfiguration, context),
        }),
        ...(input.deploymentConfigName != null && { deploymentConfigName: input.deploymentConfigName }),
        ...(input.deploymentGroupName != null && { deploymentGroupName: input.deploymentGroupName }),
        ...(input.deploymentStyle != null && {
            deploymentStyle: serializeAws_json1_1DeploymentStyle(input.deploymentStyle, context),
        }),
        ...(input.ec2TagFilters != null && {
            ec2TagFilters: serializeAws_json1_1EC2TagFilterList(input.ec2TagFilters, context),
        }),
        ...(input.ec2TagSet != null && { ec2TagSet: serializeAws_json1_1EC2TagSet(input.ec2TagSet, context) }),
        ...(input.ecsServices != null && { ecsServices: serializeAws_json1_1ECSServiceList(input.ecsServices, context) }),
        ...(input.loadBalancerInfo != null && {
            loadBalancerInfo: serializeAws_json1_1LoadBalancerInfo(input.loadBalancerInfo, context),
        }),
        ...(input.onPremisesInstanceTagFilters != null && {
            onPremisesInstanceTagFilters: serializeAws_json1_1TagFilterList(input.onPremisesInstanceTagFilters, context),
        }),
        ...(input.onPremisesTagSet != null && {
            onPremisesTagSet: serializeAws_json1_1OnPremisesTagSet(input.onPremisesTagSet, context),
        }),
        ...(input.outdatedInstancesStrategy != null && { outdatedInstancesStrategy: input.outdatedInstancesStrategy }),
        ...(input.serviceRoleArn != null && { serviceRoleArn: input.serviceRoleArn }),
        ...(input.tags != null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
        ...(input.triggerConfigurations != null && {
            triggerConfigurations: serializeAws_json1_1TriggerConfigList(input.triggerConfigurations, context),
        }),
    };
};
const serializeAws_json1_1CreateDeploymentInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.autoRollbackConfiguration != null && {
            autoRollbackConfiguration: serializeAws_json1_1AutoRollbackConfiguration(input.autoRollbackConfiguration, context),
        }),
        ...(input.deploymentConfigName != null && { deploymentConfigName: input.deploymentConfigName }),
        ...(input.deploymentGroupName != null && { deploymentGroupName: input.deploymentGroupName }),
        ...(input.description != null && { description: input.description }),
        ...(input.fileExistsBehavior != null && { fileExistsBehavior: input.fileExistsBehavior }),
        ...(input.ignoreApplicationStopFailures != null && {
            ignoreApplicationStopFailures: input.ignoreApplicationStopFailures,
        }),
        ...(input.overrideAlarmConfiguration != null && {
            overrideAlarmConfiguration: serializeAws_json1_1AlarmConfiguration(input.overrideAlarmConfiguration, context),
        }),
        ...(input.revision != null && { revision: serializeAws_json1_1RevisionLocation(input.revision, context) }),
        ...(input.targetInstances != null && {
            targetInstances: serializeAws_json1_1TargetInstances(input.targetInstances, context),
        }),
        ...(input.updateOutdatedInstancesOnly != null && {
            updateOutdatedInstancesOnly: input.updateOutdatedInstancesOnly,
        }),
    };
};
const serializeAws_json1_1DeleteApplicationInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
    };
};
const serializeAws_json1_1DeleteDeploymentConfigInput = (input, context) => {
    return {
        ...(input.deploymentConfigName != null && { deploymentConfigName: input.deploymentConfigName }),
    };
};
const serializeAws_json1_1DeleteDeploymentGroupInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.deploymentGroupName != null && { deploymentGroupName: input.deploymentGroupName }),
    };
};
const serializeAws_json1_1DeleteGitHubAccountTokenInput = (input, context) => {
    return {
        ...(input.tokenName != null && { tokenName: input.tokenName }),
    };
};
const serializeAws_json1_1DeleteResourcesByExternalIdInput = (input, context) => {
    return {
        ...(input.externalId != null && { externalId: input.externalId }),
    };
};
const serializeAws_json1_1DeploymentGroupsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DeploymentReadyOption = (input, context) => {
    return {
        ...(input.actionOnTimeout != null && { actionOnTimeout: input.actionOnTimeout }),
        ...(input.waitTimeInMinutes != null && { waitTimeInMinutes: input.waitTimeInMinutes }),
    };
};
const serializeAws_json1_1DeploymentsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DeploymentStatusList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DeploymentStyle = (input, context) => {
    return {
        ...(input.deploymentOption != null && { deploymentOption: input.deploymentOption }),
        ...(input.deploymentType != null && { deploymentType: input.deploymentType }),
    };
};
const serializeAws_json1_1DeregisterOnPremisesInstanceInput = (input, context) => {
    return {
        ...(input.instanceName != null && { instanceName: input.instanceName }),
    };
};
const serializeAws_json1_1EC2TagFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_json1_1EC2TagFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1EC2TagFilter(entry, context);
    });
};
const serializeAws_json1_1EC2TagSet = (input, context) => {
    return {
        ...(input.ec2TagSetList != null && {
            ec2TagSetList: serializeAws_json1_1EC2TagSetList(input.ec2TagSetList, context),
        }),
    };
};
const serializeAws_json1_1EC2TagSetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1EC2TagFilterList(entry, context);
    });
};
const serializeAws_json1_1ECSService = (input, context) => {
    return {
        ...(input.clusterName != null && { clusterName: input.clusterName }),
        ...(input.serviceName != null && { serviceName: input.serviceName }),
    };
};
const serializeAws_json1_1ECSServiceList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ECSService(entry, context);
    });
};
const serializeAws_json1_1ELBInfo = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
    };
};
const serializeAws_json1_1ELBInfoList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ELBInfo(entry, context);
    });
};
const serializeAws_json1_1FilterValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1GetApplicationInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
    };
};
const serializeAws_json1_1GetApplicationRevisionInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.revision != null && { revision: serializeAws_json1_1RevisionLocation(input.revision, context) }),
    };
};
const serializeAws_json1_1GetDeploymentConfigInput = (input, context) => {
    return {
        ...(input.deploymentConfigName != null && { deploymentConfigName: input.deploymentConfigName }),
    };
};
const serializeAws_json1_1GetDeploymentGroupInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.deploymentGroupName != null && { deploymentGroupName: input.deploymentGroupName }),
    };
};
const serializeAws_json1_1GetDeploymentInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
    };
};
const serializeAws_json1_1GetDeploymentInstanceInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.instanceId != null && { instanceId: input.instanceId }),
    };
};
const serializeAws_json1_1GetDeploymentTargetInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.targetId != null && { targetId: input.targetId }),
    };
};
const serializeAws_json1_1GetOnPremisesInstanceInput = (input, context) => {
    return {
        ...(input.instanceName != null && { instanceName: input.instanceName }),
    };
};
const serializeAws_json1_1GitHubLocation = (input, context) => {
    return {
        ...(input.commitId != null && { commitId: input.commitId }),
        ...(input.repository != null && { repository: input.repository }),
    };
};
const serializeAws_json1_1GreenFleetProvisioningOption = (input, context) => {
    return {
        ...(input.action != null && { action: input.action }),
    };
};
const serializeAws_json1_1InstanceNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1InstancesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1InstanceStatusList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1InstanceTypeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ListApplicationRevisionsInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.deployed != null && { deployed: input.deployed }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.s3Bucket != null && { s3Bucket: input.s3Bucket }),
        ...(input.s3KeyPrefix != null && { s3KeyPrefix: input.s3KeyPrefix }),
        ...(input.sortBy != null && { sortBy: input.sortBy }),
        ...(input.sortOrder != null && { sortOrder: input.sortOrder }),
    };
};
const serializeAws_json1_1ListApplicationsInput = (input, context) => {
    return {
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListDeploymentConfigsInput = (input, context) => {
    return {
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListDeploymentGroupsInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListDeploymentInstancesInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.instanceStatusFilter != null && {
            instanceStatusFilter: serializeAws_json1_1InstanceStatusList(input.instanceStatusFilter, context),
        }),
        ...(input.instanceTypeFilter != null && {
            instanceTypeFilter: serializeAws_json1_1InstanceTypeList(input.instanceTypeFilter, context),
        }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListDeploymentsInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.createTimeRange != null && {
            createTimeRange: serializeAws_json1_1TimeRange(input.createTimeRange, context),
        }),
        ...(input.deploymentGroupName != null && { deploymentGroupName: input.deploymentGroupName }),
        ...(input.externalId != null && { externalId: input.externalId }),
        ...(input.includeOnlyStatuses != null && {
            includeOnlyStatuses: serializeAws_json1_1DeploymentStatusList(input.includeOnlyStatuses, context),
        }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListDeploymentTargetsInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.targetFilters != null && {
            targetFilters: serializeAws_json1_1TargetFilters(input.targetFilters, context),
        }),
    };
};
const serializeAws_json1_1ListenerArnList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ListGitHubAccountTokenNamesInput = (input, context) => {
    return {
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListOnPremisesInstancesInput = (input, context) => {
    return {
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.registrationStatus != null && { registrationStatus: input.registrationStatus }),
        ...(input.tagFilters != null && { tagFilters: serializeAws_json1_1TagFilterList(input.tagFilters, context) }),
    };
};
const serializeAws_json1_1ListTagsForResourceInput = (input, context) => {
    return {
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const serializeAws_json1_1LoadBalancerInfo = (input, context) => {
    return {
        ...(input.elbInfoList != null && { elbInfoList: serializeAws_json1_1ELBInfoList(input.elbInfoList, context) }),
        ...(input.targetGroupInfoList != null && {
            targetGroupInfoList: serializeAws_json1_1TargetGroupInfoList(input.targetGroupInfoList, context),
        }),
        ...(input.targetGroupPairInfoList != null && {
            targetGroupPairInfoList: serializeAws_json1_1TargetGroupPairInfoList(input.targetGroupPairInfoList, context),
        }),
    };
};
const serializeAws_json1_1MinimumHealthyHosts = (input, context) => {
    return {
        ...(input.type != null && { type: input.type }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1OnPremisesTagSet = (input, context) => {
    return {
        ...(input.onPremisesTagSetList != null && {
            onPremisesTagSetList: serializeAws_json1_1OnPremisesTagSetList(input.onPremisesTagSetList, context),
        }),
    };
};
const serializeAws_json1_1OnPremisesTagSetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1TagFilterList(entry, context);
    });
};
const serializeAws_json1_1PutLifecycleEventHookExecutionStatusInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
        ...(input.lifecycleEventHookExecutionId != null && {
            lifecycleEventHookExecutionId: input.lifecycleEventHookExecutionId,
        }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1RawString = (input, context) => {
    return {
        ...(input.content != null && { content: input.content }),
        ...(input.sha256 != null && { sha256: input.sha256 }),
    };
};
const serializeAws_json1_1RegisterApplicationRevisionInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.description != null && { description: input.description }),
        ...(input.revision != null && { revision: serializeAws_json1_1RevisionLocation(input.revision, context) }),
    };
};
const serializeAws_json1_1RegisterOnPremisesInstanceInput = (input, context) => {
    return {
        ...(input.iamSessionArn != null && { iamSessionArn: input.iamSessionArn }),
        ...(input.iamUserArn != null && { iamUserArn: input.iamUserArn }),
        ...(input.instanceName != null && { instanceName: input.instanceName }),
    };
};
const serializeAws_json1_1RemoveTagsFromOnPremisesInstancesInput = (input, context) => {
    return {
        ...(input.instanceNames != null && {
            instanceNames: serializeAws_json1_1InstanceNameList(input.instanceNames, context),
        }),
        ...(input.tags != null && { tags: serializeAws_json1_1TagList(input.tags, context) }),
    };
};
const serializeAws_json1_1RevisionLocation = (input, context) => {
    return {
        ...(input.appSpecContent != null && {
            appSpecContent: serializeAws_json1_1AppSpecContent(input.appSpecContent, context),
        }),
        ...(input.gitHubLocation != null && {
            gitHubLocation: serializeAws_json1_1GitHubLocation(input.gitHubLocation, context),
        }),
        ...(input.revisionType != null && { revisionType: input.revisionType }),
        ...(input.s3Location != null && { s3Location: serializeAws_json1_1S3Location(input.s3Location, context) }),
        ...(input.string != null && { string: serializeAws_json1_1RawString(input.string, context) }),
    };
};
const serializeAws_json1_1RevisionLocationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1RevisionLocation(entry, context);
    });
};
const serializeAws_json1_1S3Location = (input, context) => {
    return {
        ...(input.bucket != null && { bucket: input.bucket }),
        ...(input.bundleType != null && { bundleType: input.bundleType }),
        ...(input.eTag != null && { eTag: input.eTag }),
        ...(input.key != null && { key: input.key }),
        ...(input.version != null && { version: input.version }),
    };
};
const serializeAws_json1_1SkipWaitTimeForInstanceTerminationInput = (input, context) => {
    return {
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
    };
};
const serializeAws_json1_1StopDeploymentInput = (input, context) => {
    return {
        ...(input.autoRollbackEnabled != null && { autoRollbackEnabled: input.autoRollbackEnabled }),
        ...(input.deploymentId != null && { deploymentId: input.deploymentId }),
    };
};
const serializeAws_json1_1Tag = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_json1_1TagFilter = (input, context) => {
    return {
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_json1_1TagFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1TagFilter(entry, context);
    });
};
const serializeAws_json1_1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Tag(entry, context);
    });
};
const serializeAws_json1_1TagResourceInput = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
    };
};
const serializeAws_json1_1TargetFilters = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_json1_1FilterValueList(value, context);
        return acc;
    }, {});
};
const serializeAws_json1_1TargetGroupInfo = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
    };
};
const serializeAws_json1_1TargetGroupInfoList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1TargetGroupInfo(entry, context);
    });
};
const serializeAws_json1_1TargetGroupPairInfo = (input, context) => {
    return {
        ...(input.prodTrafficRoute != null && {
            prodTrafficRoute: serializeAws_json1_1TrafficRoute(input.prodTrafficRoute, context),
        }),
        ...(input.targetGroups != null && {
            targetGroups: serializeAws_json1_1TargetGroupInfoList(input.targetGroups, context),
        }),
        ...(input.testTrafficRoute != null && {
            testTrafficRoute: serializeAws_json1_1TrafficRoute(input.testTrafficRoute, context),
        }),
    };
};
const serializeAws_json1_1TargetGroupPairInfoList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1TargetGroupPairInfo(entry, context);
    });
};
const serializeAws_json1_1TargetIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TargetInstances = (input, context) => {
    return {
        ...(input.autoScalingGroups != null && {
            autoScalingGroups: serializeAws_json1_1AutoScalingGroupNameList(input.autoScalingGroups, context),
        }),
        ...(input.ec2TagSet != null && { ec2TagSet: serializeAws_json1_1EC2TagSet(input.ec2TagSet, context) }),
        ...(input.tagFilters != null && { tagFilters: serializeAws_json1_1EC2TagFilterList(input.tagFilters, context) }),
    };
};
const serializeAws_json1_1TimeBasedCanary = (input, context) => {
    return {
        ...(input.canaryInterval != null && { canaryInterval: input.canaryInterval }),
        ...(input.canaryPercentage != null && { canaryPercentage: input.canaryPercentage }),
    };
};
const serializeAws_json1_1TimeBasedLinear = (input, context) => {
    return {
        ...(input.linearInterval != null && { linearInterval: input.linearInterval }),
        ...(input.linearPercentage != null && { linearPercentage: input.linearPercentage }),
    };
};
const serializeAws_json1_1TimeRange = (input, context) => {
    return {
        ...(input.end != null && { end: Math.round(input.end.getTime() / 1000) }),
        ...(input.start != null && { start: Math.round(input.start.getTime() / 1000) }),
    };
};
const serializeAws_json1_1TrafficRoute = (input, context) => {
    return {
        ...(input.listenerArns != null && {
            listenerArns: serializeAws_json1_1ListenerArnList(input.listenerArns, context),
        }),
    };
};
const serializeAws_json1_1TrafficRoutingConfig = (input, context) => {
    return {
        ...(input.timeBasedCanary != null && {
            timeBasedCanary: serializeAws_json1_1TimeBasedCanary(input.timeBasedCanary, context),
        }),
        ...(input.timeBasedLinear != null && {
            timeBasedLinear: serializeAws_json1_1TimeBasedLinear(input.timeBasedLinear, context),
        }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1TriggerConfig = (input, context) => {
    return {
        ...(input.triggerEvents != null && {
            triggerEvents: serializeAws_json1_1TriggerEventTypeList(input.triggerEvents, context),
        }),
        ...(input.triggerName != null && { triggerName: input.triggerName }),
        ...(input.triggerTargetArn != null && { triggerTargetArn: input.triggerTargetArn }),
    };
};
const serializeAws_json1_1TriggerConfigList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1TriggerConfig(entry, context);
    });
};
const serializeAws_json1_1TriggerEventTypeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1UntagResourceInput = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
        ...(input.TagKeys != null && { TagKeys: serializeAws_json1_1TagKeyList(input.TagKeys, context) }),
    };
};
const serializeAws_json1_1UpdateApplicationInput = (input, context) => {
    return {
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.newApplicationName != null && { newApplicationName: input.newApplicationName }),
    };
};
const serializeAws_json1_1UpdateDeploymentGroupInput = (input, context) => {
    return {
        ...(input.alarmConfiguration != null && {
            alarmConfiguration: serializeAws_json1_1AlarmConfiguration(input.alarmConfiguration, context),
        }),
        ...(input.applicationName != null && { applicationName: input.applicationName }),
        ...(input.autoRollbackConfiguration != null && {
            autoRollbackConfiguration: serializeAws_json1_1AutoRollbackConfiguration(input.autoRollbackConfiguration, context),
        }),
        ...(input.autoScalingGroups != null && {
            autoScalingGroups: serializeAws_json1_1AutoScalingGroupNameList(input.autoScalingGroups, context),
        }),
        ...(input.blueGreenDeploymentConfiguration != null && {
            blueGreenDeploymentConfiguration: serializeAws_json1_1BlueGreenDeploymentConfiguration(input.blueGreenDeploymentConfiguration, context),
        }),
        ...(input.currentDeploymentGroupName != null && { currentDeploymentGroupName: input.currentDeploymentGroupName }),
        ...(input.deploymentConfigName != null && { deploymentConfigName: input.deploymentConfigName }),
        ...(input.deploymentStyle != null && {
            deploymentStyle: serializeAws_json1_1DeploymentStyle(input.deploymentStyle, context),
        }),
        ...(input.ec2TagFilters != null && {
            ec2TagFilters: serializeAws_json1_1EC2TagFilterList(input.ec2TagFilters, context),
        }),
        ...(input.ec2TagSet != null && { ec2TagSet: serializeAws_json1_1EC2TagSet(input.ec2TagSet, context) }),
        ...(input.ecsServices != null && { ecsServices: serializeAws_json1_1ECSServiceList(input.ecsServices, context) }),
        ...(input.loadBalancerInfo != null && {
            loadBalancerInfo: serializeAws_json1_1LoadBalancerInfo(input.loadBalancerInfo, context),
        }),
        ...(input.newDeploymentGroupName != null && { newDeploymentGroupName: input.newDeploymentGroupName }),
        ...(input.onPremisesInstanceTagFilters != null && {
            onPremisesInstanceTagFilters: serializeAws_json1_1TagFilterList(input.onPremisesInstanceTagFilters, context),
        }),
        ...(input.onPremisesTagSet != null && {
            onPremisesTagSet: serializeAws_json1_1OnPremisesTagSet(input.onPremisesTagSet, context),
        }),
        ...(input.outdatedInstancesStrategy != null && { outdatedInstancesStrategy: input.outdatedInstancesStrategy }),
        ...(input.serviceRoleArn != null && { serviceRoleArn: input.serviceRoleArn }),
        ...(input.triggerConfigurations != null && {
            triggerConfigurations: serializeAws_json1_1TriggerConfigList(input.triggerConfigurations, context),
        }),
    };
};
const deserializeAws_json1_1Alarm = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
    };
};
const deserializeAws_json1_1AlarmConfiguration = (output, context) => {
    return {
        alarms: output.alarms != null ? deserializeAws_json1_1AlarmList(output.alarms, context) : undefined,
        enabled: (0, smithy_client_1.expectBoolean)(output.enabled),
        ignorePollAlarmFailure: (0, smithy_client_1.expectBoolean)(output.ignorePollAlarmFailure),
    };
};
const deserializeAws_json1_1AlarmList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Alarm(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1AlarmsLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ApplicationAlreadyExistsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ApplicationDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ApplicationInfo = (output, context) => {
    return {
        applicationId: (0, smithy_client_1.expectString)(output.applicationId),
        applicationName: (0, smithy_client_1.expectString)(output.applicationName),
        computePlatform: (0, smithy_client_1.expectString)(output.computePlatform),
        createTime: output.createTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createTime))) : undefined,
        gitHubAccountName: (0, smithy_client_1.expectString)(output.gitHubAccountName),
        linkedToGitHub: (0, smithy_client_1.expectBoolean)(output.linkedToGitHub),
    };
};
const deserializeAws_json1_1ApplicationLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ApplicationNameRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ApplicationsInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ApplicationInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ApplicationsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1AppSpecContent = (output, context) => {
    return {
        content: (0, smithy_client_1.expectString)(output.content),
        sha256: (0, smithy_client_1.expectString)(output.sha256),
    };
};
const deserializeAws_json1_1ArnNotSupportedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1AutoRollbackConfiguration = (output, context) => {
    return {
        enabled: (0, smithy_client_1.expectBoolean)(output.enabled),
        events: output.events != null ? deserializeAws_json1_1AutoRollbackEventsList(output.events, context) : undefined,
    };
};
const deserializeAws_json1_1AutoRollbackEventsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1AutoScalingGroup = (output, context) => {
    return {
        hook: (0, smithy_client_1.expectString)(output.hook),
        name: (0, smithy_client_1.expectString)(output.name),
    };
};
const deserializeAws_json1_1AutoScalingGroupList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1AutoScalingGroup(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1AutoScalingGroupNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1BatchGetApplicationRevisionsOutput = (output, context) => {
    return {
        applicationName: (0, smithy_client_1.expectString)(output.applicationName),
        errorMessage: (0, smithy_client_1.expectString)(output.errorMessage),
        revisions: output.revisions != null ? deserializeAws_json1_1RevisionInfoList(output.revisions, context) : undefined,
    };
};
const deserializeAws_json1_1BatchGetApplicationsOutput = (output, context) => {
    return {
        applicationsInfo: output.applicationsInfo != null
            ? deserializeAws_json1_1ApplicationsInfoList(output.applicationsInfo, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetDeploymentGroupsOutput = (output, context) => {
    return {
        deploymentGroupsInfo: output.deploymentGroupsInfo != null
            ? deserializeAws_json1_1DeploymentGroupInfoList(output.deploymentGroupsInfo, context)
            : undefined,
        errorMessage: (0, smithy_client_1.expectString)(output.errorMessage),
    };
};
const deserializeAws_json1_1BatchGetDeploymentInstancesOutput = (output, context) => {
    return {
        errorMessage: (0, smithy_client_1.expectString)(output.errorMessage),
        instancesSummary: output.instancesSummary != null
            ? deserializeAws_json1_1InstanceSummaryList(output.instancesSummary, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetDeploymentsOutput = (output, context) => {
    return {
        deploymentsInfo: output.deploymentsInfo != null
            ? deserializeAws_json1_1DeploymentsInfoList(output.deploymentsInfo, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetDeploymentTargetsOutput = (output, context) => {
    return {
        deploymentTargets: output.deploymentTargets != null
            ? deserializeAws_json1_1DeploymentTargetList(output.deploymentTargets, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetOnPremisesInstancesOutput = (output, context) => {
    return {
        instanceInfos: output.instanceInfos != null ? deserializeAws_json1_1InstanceInfoList(output.instanceInfos, context) : undefined,
    };
};
const deserializeAws_json1_1BatchLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1BlueGreenDeploymentConfiguration = (output, context) => {
    return {
        deploymentReadyOption: output.deploymentReadyOption != null
            ? deserializeAws_json1_1DeploymentReadyOption(output.deploymentReadyOption, context)
            : undefined,
        greenFleetProvisioningOption: output.greenFleetProvisioningOption != null
            ? deserializeAws_json1_1GreenFleetProvisioningOption(output.greenFleetProvisioningOption, context)
            : undefined,
        terminateBlueInstancesOnDeploymentSuccess: output.terminateBlueInstancesOnDeploymentSuccess != null
            ? deserializeAws_json1_1BlueInstanceTerminationOption(output.terminateBlueInstancesOnDeploymentSuccess, context)
            : undefined,
    };
};
const deserializeAws_json1_1BlueInstanceTerminationOption = (output, context) => {
    return {
        action: (0, smithy_client_1.expectString)(output.action),
        terminationWaitTimeInMinutes: (0, smithy_client_1.expectInt32)(output.terminationWaitTimeInMinutes),
    };
};
const deserializeAws_json1_1BucketNameFilterRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1CloudFormationTarget = (output, context) => {
    return {
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastUpdatedAt)))
            : undefined,
        lifecycleEvents: output.lifecycleEvents != null
            ? deserializeAws_json1_1LifecycleEventList(output.lifecycleEvents, context)
            : undefined,
        resourceType: (0, smithy_client_1.expectString)(output.resourceType),
        status: (0, smithy_client_1.expectString)(output.status),
        targetId: (0, smithy_client_1.expectString)(output.targetId),
        targetVersionWeight: (0, smithy_client_1.limitedParseDouble)(output.targetVersionWeight),
    };
};
const deserializeAws_json1_1CreateApplicationOutput = (output, context) => {
    return {
        applicationId: (0, smithy_client_1.expectString)(output.applicationId),
    };
};
const deserializeAws_json1_1CreateDeploymentConfigOutput = (output, context) => {
    return {
        deploymentConfigId: (0, smithy_client_1.expectString)(output.deploymentConfigId),
    };
};
const deserializeAws_json1_1CreateDeploymentGroupOutput = (output, context) => {
    return {
        deploymentGroupId: (0, smithy_client_1.expectString)(output.deploymentGroupId),
    };
};
const deserializeAws_json1_1CreateDeploymentOutput = (output, context) => {
    return {
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
    };
};
const deserializeAws_json1_1DeleteDeploymentGroupOutput = (output, context) => {
    return {
        hooksNotCleanedUp: output.hooksNotCleanedUp != null
            ? deserializeAws_json1_1AutoScalingGroupList(output.hooksNotCleanedUp, context)
            : undefined,
    };
};
const deserializeAws_json1_1DeleteGitHubAccountTokenOutput = (output, context) => {
    return {
        tokenName: (0, smithy_client_1.expectString)(output.tokenName),
    };
};
const deserializeAws_json1_1DeleteResourcesByExternalIdOutput = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeploymentAlreadyCompletedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentConfigAlreadyExistsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentConfigDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentConfigInfo = (output, context) => {
    return {
        computePlatform: (0, smithy_client_1.expectString)(output.computePlatform),
        createTime: output.createTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createTime))) : undefined,
        deploymentConfigId: (0, smithy_client_1.expectString)(output.deploymentConfigId),
        deploymentConfigName: (0, smithy_client_1.expectString)(output.deploymentConfigName),
        minimumHealthyHosts: output.minimumHealthyHosts != null
            ? deserializeAws_json1_1MinimumHealthyHosts(output.minimumHealthyHosts, context)
            : undefined,
        trafficRoutingConfig: output.trafficRoutingConfig != null
            ? deserializeAws_json1_1TrafficRoutingConfig(output.trafficRoutingConfig, context)
            : undefined,
    };
};
const deserializeAws_json1_1DeploymentConfigInUseException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentConfigLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentConfigNameRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentConfigsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DeploymentDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentGroupAlreadyExistsException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentGroupDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentGroupInfo = (output, context) => {
    return {
        alarmConfiguration: output.alarmConfiguration != null
            ? deserializeAws_json1_1AlarmConfiguration(output.alarmConfiguration, context)
            : undefined,
        applicationName: (0, smithy_client_1.expectString)(output.applicationName),
        autoRollbackConfiguration: output.autoRollbackConfiguration != null
            ? deserializeAws_json1_1AutoRollbackConfiguration(output.autoRollbackConfiguration, context)
            : undefined,
        autoScalingGroups: output.autoScalingGroups != null
            ? deserializeAws_json1_1AutoScalingGroupList(output.autoScalingGroups, context)
            : undefined,
        blueGreenDeploymentConfiguration: output.blueGreenDeploymentConfiguration != null
            ? deserializeAws_json1_1BlueGreenDeploymentConfiguration(output.blueGreenDeploymentConfiguration, context)
            : undefined,
        computePlatform: (0, smithy_client_1.expectString)(output.computePlatform),
        deploymentConfigName: (0, smithy_client_1.expectString)(output.deploymentConfigName),
        deploymentGroupId: (0, smithy_client_1.expectString)(output.deploymentGroupId),
        deploymentGroupName: (0, smithy_client_1.expectString)(output.deploymentGroupName),
        deploymentStyle: output.deploymentStyle != null
            ? deserializeAws_json1_1DeploymentStyle(output.deploymentStyle, context)
            : undefined,
        ec2TagFilters: output.ec2TagFilters != null ? deserializeAws_json1_1EC2TagFilterList(output.ec2TagFilters, context) : undefined,
        ec2TagSet: output.ec2TagSet != null ? deserializeAws_json1_1EC2TagSet(output.ec2TagSet, context) : undefined,
        ecsServices: output.ecsServices != null ? deserializeAws_json1_1ECSServiceList(output.ecsServices, context) : undefined,
        lastAttemptedDeployment: output.lastAttemptedDeployment != null
            ? deserializeAws_json1_1LastDeploymentInfo(output.lastAttemptedDeployment, context)
            : undefined,
        lastSuccessfulDeployment: output.lastSuccessfulDeployment != null
            ? deserializeAws_json1_1LastDeploymentInfo(output.lastSuccessfulDeployment, context)
            : undefined,
        loadBalancerInfo: output.loadBalancerInfo != null
            ? deserializeAws_json1_1LoadBalancerInfo(output.loadBalancerInfo, context)
            : undefined,
        onPremisesInstanceTagFilters: output.onPremisesInstanceTagFilters != null
            ? deserializeAws_json1_1TagFilterList(output.onPremisesInstanceTagFilters, context)
            : undefined,
        onPremisesTagSet: output.onPremisesTagSet != null
            ? deserializeAws_json1_1OnPremisesTagSet(output.onPremisesTagSet, context)
            : undefined,
        outdatedInstancesStrategy: (0, smithy_client_1.expectString)(output.outdatedInstancesStrategy),
        serviceRoleArn: (0, smithy_client_1.expectString)(output.serviceRoleArn),
        targetRevision: output.targetRevision != null
            ? deserializeAws_json1_1RevisionLocation(output.targetRevision, context)
            : undefined,
        triggerConfigurations: output.triggerConfigurations != null
            ? deserializeAws_json1_1TriggerConfigList(output.triggerConfigurations, context)
            : undefined,
    };
};
const deserializeAws_json1_1DeploymentGroupInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DeploymentGroupInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DeploymentGroupLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentGroupNameRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentGroupsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DeploymentIdRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentInfo = (output, context) => {
    return {
        additionalDeploymentStatusInfo: (0, smithy_client_1.expectString)(output.additionalDeploymentStatusInfo),
        applicationName: (0, smithy_client_1.expectString)(output.applicationName),
        autoRollbackConfiguration: output.autoRollbackConfiguration != null
            ? deserializeAws_json1_1AutoRollbackConfiguration(output.autoRollbackConfiguration, context)
            : undefined,
        blueGreenDeploymentConfiguration: output.blueGreenDeploymentConfiguration != null
            ? deserializeAws_json1_1BlueGreenDeploymentConfiguration(output.blueGreenDeploymentConfiguration, context)
            : undefined,
        completeTime: output.completeTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.completeTime)))
            : undefined,
        computePlatform: (0, smithy_client_1.expectString)(output.computePlatform),
        createTime: output.createTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createTime))) : undefined,
        creator: (0, smithy_client_1.expectString)(output.creator),
        deploymentConfigName: (0, smithy_client_1.expectString)(output.deploymentConfigName),
        deploymentGroupName: (0, smithy_client_1.expectString)(output.deploymentGroupName),
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
        deploymentOverview: output.deploymentOverview != null
            ? deserializeAws_json1_1DeploymentOverview(output.deploymentOverview, context)
            : undefined,
        deploymentStatusMessages: output.deploymentStatusMessages != null
            ? deserializeAws_json1_1DeploymentStatusMessageList(output.deploymentStatusMessages, context)
            : undefined,
        deploymentStyle: output.deploymentStyle != null
            ? deserializeAws_json1_1DeploymentStyle(output.deploymentStyle, context)
            : undefined,
        description: (0, smithy_client_1.expectString)(output.description),
        errorInformation: output.errorInformation != null
            ? deserializeAws_json1_1ErrorInformation(output.errorInformation, context)
            : undefined,
        externalId: (0, smithy_client_1.expectString)(output.externalId),
        fileExistsBehavior: (0, smithy_client_1.expectString)(output.fileExistsBehavior),
        ignoreApplicationStopFailures: (0, smithy_client_1.expectBoolean)(output.ignoreApplicationStopFailures),
        instanceTerminationWaitTimeStarted: (0, smithy_client_1.expectBoolean)(output.instanceTerminationWaitTimeStarted),
        loadBalancerInfo: output.loadBalancerInfo != null
            ? deserializeAws_json1_1LoadBalancerInfo(output.loadBalancerInfo, context)
            : undefined,
        overrideAlarmConfiguration: output.overrideAlarmConfiguration != null
            ? deserializeAws_json1_1AlarmConfiguration(output.overrideAlarmConfiguration, context)
            : undefined,
        previousRevision: output.previousRevision != null
            ? deserializeAws_json1_1RevisionLocation(output.previousRevision, context)
            : undefined,
        relatedDeployments: output.relatedDeployments != null
            ? deserializeAws_json1_1RelatedDeployments(output.relatedDeployments, context)
            : undefined,
        revision: output.revision != null ? deserializeAws_json1_1RevisionLocation(output.revision, context) : undefined,
        rollbackInfo: output.rollbackInfo != null ? deserializeAws_json1_1RollbackInfo(output.rollbackInfo, context) : undefined,
        startTime: output.startTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.startTime))) : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        targetInstances: output.targetInstances != null
            ? deserializeAws_json1_1TargetInstances(output.targetInstances, context)
            : undefined,
        updateOutdatedInstancesOnly: (0, smithy_client_1.expectBoolean)(output.updateOutdatedInstancesOnly),
    };
};
const deserializeAws_json1_1DeploymentIsNotInReadyStateException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentNotStartedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentOverview = (output, context) => {
    return {
        Failed: (0, smithy_client_1.expectLong)(output.Failed),
        InProgress: (0, smithy_client_1.expectLong)(output.InProgress),
        Pending: (0, smithy_client_1.expectLong)(output.Pending),
        Ready: (0, smithy_client_1.expectLong)(output.Ready),
        Skipped: (0, smithy_client_1.expectLong)(output.Skipped),
        Succeeded: (0, smithy_client_1.expectLong)(output.Succeeded),
    };
};
const deserializeAws_json1_1DeploymentReadyOption = (output, context) => {
    return {
        actionOnTimeout: (0, smithy_client_1.expectString)(output.actionOnTimeout),
        waitTimeInMinutes: (0, smithy_client_1.expectInt32)(output.waitTimeInMinutes),
    };
};
const deserializeAws_json1_1DeploymentsInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DeploymentInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DeploymentsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DeploymentStatusMessageList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DeploymentStyle = (output, context) => {
    return {
        deploymentOption: (0, smithy_client_1.expectString)(output.deploymentOption),
        deploymentType: (0, smithy_client_1.expectString)(output.deploymentType),
    };
};
const deserializeAws_json1_1DeploymentTarget = (output, context) => {
    return {
        cloudFormationTarget: output.cloudFormationTarget != null
            ? deserializeAws_json1_1CloudFormationTarget(output.cloudFormationTarget, context)
            : undefined,
        deploymentTargetType: (0, smithy_client_1.expectString)(output.deploymentTargetType),
        ecsTarget: output.ecsTarget != null ? deserializeAws_json1_1ECSTarget(output.ecsTarget, context) : undefined,
        instanceTarget: output.instanceTarget != null ? deserializeAws_json1_1InstanceTarget(output.instanceTarget, context) : undefined,
        lambdaTarget: output.lambdaTarget != null ? deserializeAws_json1_1LambdaTarget(output.lambdaTarget, context) : undefined,
    };
};
const deserializeAws_json1_1DeploymentTargetDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentTargetIdRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DeploymentTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DeploymentTarget(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DeploymentTargetListSizeExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1DescriptionTooLongException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1Diagnostics = (output, context) => {
    return {
        errorCode: (0, smithy_client_1.expectString)(output.errorCode),
        logTail: (0, smithy_client_1.expectString)(output.logTail),
        message: (0, smithy_client_1.expectString)(output.message),
        scriptName: (0, smithy_client_1.expectString)(output.scriptName),
    };
};
const deserializeAws_json1_1EC2TagFilter = (output, context) => {
    return {
        Key: (0, smithy_client_1.expectString)(output.Key),
        Type: (0, smithy_client_1.expectString)(output.Type),
        Value: (0, smithy_client_1.expectString)(output.Value),
    };
};
const deserializeAws_json1_1EC2TagFilterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1EC2TagFilter(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1EC2TagSet = (output, context) => {
    return {
        ec2TagSetList: output.ec2TagSetList != null ? deserializeAws_json1_1EC2TagSetList(output.ec2TagSetList, context) : undefined,
    };
};
const deserializeAws_json1_1EC2TagSetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1EC2TagFilterList(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ECSService = (output, context) => {
    return {
        clusterName: (0, smithy_client_1.expectString)(output.clusterName),
        serviceName: (0, smithy_client_1.expectString)(output.serviceName),
    };
};
const deserializeAws_json1_1ECSServiceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ECSService(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ECSServiceMappingLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ECSTarget = (output, context) => {
    return {
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastUpdatedAt)))
            : undefined,
        lifecycleEvents: output.lifecycleEvents != null
            ? deserializeAws_json1_1LifecycleEventList(output.lifecycleEvents, context)
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        targetArn: (0, smithy_client_1.expectString)(output.targetArn),
        targetId: (0, smithy_client_1.expectString)(output.targetId),
        taskSetsInfo: output.taskSetsInfo != null ? deserializeAws_json1_1ECSTaskSetList(output.taskSetsInfo, context) : undefined,
    };
};
const deserializeAws_json1_1ECSTaskSet = (output, context) => {
    return {
        desiredCount: (0, smithy_client_1.expectLong)(output.desiredCount),
        identifer: (0, smithy_client_1.expectString)(output.identifer),
        pendingCount: (0, smithy_client_1.expectLong)(output.pendingCount),
        runningCount: (0, smithy_client_1.expectLong)(output.runningCount),
        status: (0, smithy_client_1.expectString)(output.status),
        targetGroup: output.targetGroup != null ? deserializeAws_json1_1TargetGroupInfo(output.targetGroup, context) : undefined,
        taskSetLabel: (0, smithy_client_1.expectString)(output.taskSetLabel),
        trafficWeight: (0, smithy_client_1.limitedParseDouble)(output.trafficWeight),
    };
};
const deserializeAws_json1_1ECSTaskSetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ECSTaskSet(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ELBInfo = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
    };
};
const deserializeAws_json1_1ELBInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ELBInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ErrorInformation = (output, context) => {
    return {
        code: (0, smithy_client_1.expectString)(output.code),
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1GenericRevisionInfo = (output, context) => {
    return {
        deploymentGroups: output.deploymentGroups != null
            ? deserializeAws_json1_1DeploymentGroupsList(output.deploymentGroups, context)
            : undefined,
        description: (0, smithy_client_1.expectString)(output.description),
        firstUsedTime: output.firstUsedTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.firstUsedTime)))
            : undefined,
        lastUsedTime: output.lastUsedTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastUsedTime)))
            : undefined,
        registerTime: output.registerTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.registerTime)))
            : undefined,
    };
};
const deserializeAws_json1_1GetApplicationOutput = (output, context) => {
    return {
        application: output.application != null ? deserializeAws_json1_1ApplicationInfo(output.application, context) : undefined,
    };
};
const deserializeAws_json1_1GetApplicationRevisionOutput = (output, context) => {
    return {
        applicationName: (0, smithy_client_1.expectString)(output.applicationName),
        revision: output.revision != null ? deserializeAws_json1_1RevisionLocation(output.revision, context) : undefined,
        revisionInfo: output.revisionInfo != null ? deserializeAws_json1_1GenericRevisionInfo(output.revisionInfo, context) : undefined,
    };
};
const deserializeAws_json1_1GetDeploymentConfigOutput = (output, context) => {
    return {
        deploymentConfigInfo: output.deploymentConfigInfo != null
            ? deserializeAws_json1_1DeploymentConfigInfo(output.deploymentConfigInfo, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDeploymentGroupOutput = (output, context) => {
    return {
        deploymentGroupInfo: output.deploymentGroupInfo != null
            ? deserializeAws_json1_1DeploymentGroupInfo(output.deploymentGroupInfo, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDeploymentInstanceOutput = (output, context) => {
    return {
        instanceSummary: output.instanceSummary != null
            ? deserializeAws_json1_1InstanceSummary(output.instanceSummary, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDeploymentOutput = (output, context) => {
    return {
        deploymentInfo: output.deploymentInfo != null ? deserializeAws_json1_1DeploymentInfo(output.deploymentInfo, context) : undefined,
    };
};
const deserializeAws_json1_1GetDeploymentTargetOutput = (output, context) => {
    return {
        deploymentTarget: output.deploymentTarget != null
            ? deserializeAws_json1_1DeploymentTarget(output.deploymentTarget, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetOnPremisesInstanceOutput = (output, context) => {
    return {
        instanceInfo: output.instanceInfo != null ? deserializeAws_json1_1InstanceInfo(output.instanceInfo, context) : undefined,
    };
};
const deserializeAws_json1_1GitHubAccountTokenDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1GitHubAccountTokenNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1GitHubAccountTokenNameRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1GitHubLocation = (output, context) => {
    return {
        commitId: (0, smithy_client_1.expectString)(output.commitId),
        repository: (0, smithy_client_1.expectString)(output.repository),
    };
};
const deserializeAws_json1_1GreenFleetProvisioningOption = (output, context) => {
    return {
        action: (0, smithy_client_1.expectString)(output.action),
    };
};
const deserializeAws_json1_1IamArnRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1IamSessionArnAlreadyRegisteredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1IamUserArnAlreadyRegisteredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1IamUserArnRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InstanceDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InstanceIdRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InstanceInfo = (output, context) => {
    return {
        deregisterTime: output.deregisterTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.deregisterTime)))
            : undefined,
        iamSessionArn: (0, smithy_client_1.expectString)(output.iamSessionArn),
        iamUserArn: (0, smithy_client_1.expectString)(output.iamUserArn),
        instanceArn: (0, smithy_client_1.expectString)(output.instanceArn),
        instanceName: (0, smithy_client_1.expectString)(output.instanceName),
        registerTime: output.registerTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.registerTime)))
            : undefined,
        tags: output.tags != null ? deserializeAws_json1_1TagList(output.tags, context) : undefined,
    };
};
const deserializeAws_json1_1InstanceInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1InstanceInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1InstanceLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InstanceNameAlreadyRegisteredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InstanceNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1InstanceNameRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InstanceNotRegisteredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InstancesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1InstanceSummary = (output, context) => {
    return {
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
        instanceId: (0, smithy_client_1.expectString)(output.instanceId),
        instanceType: (0, smithy_client_1.expectString)(output.instanceType),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastUpdatedAt)))
            : undefined,
        lifecycleEvents: output.lifecycleEvents != null
            ? deserializeAws_json1_1LifecycleEventList(output.lifecycleEvents, context)
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_json1_1InstanceSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1InstanceSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1InstanceTarget = (output, context) => {
    return {
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
        instanceLabel: (0, smithy_client_1.expectString)(output.instanceLabel),
        lastUpdatedAt: output.lastUpdatedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastUpdatedAt)))
            : undefined,
        lifecycleEvents: output.lifecycleEvents != null
            ? deserializeAws_json1_1LifecycleEventList(output.lifecycleEvents, context)
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        targetArn: (0, smithy_client_1.expectString)(output.targetArn),
        targetId: (0, smithy_client_1.expectString)(output.targetId),
    };
};
const deserializeAws_json1_1InvalidAlarmConfigException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidApplicationNameException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidArnException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidAutoRollbackConfigException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidAutoScalingGroupException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidBlueGreenDeploymentConfigurationException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidBucketNameFilterException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidComputePlatformException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeployedStateFilterException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentConfigNameException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentGroupNameException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentIdException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentInstanceTypeException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentStatusException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentStyleException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentTargetIdException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidDeploymentWaitTypeException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidEC2TagCombinationException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidEC2TagException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidECSServiceException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidExternalIdException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidFileExistsBehaviorException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidGitHubAccountTokenException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidGitHubAccountTokenNameException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidIamSessionArnException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidIamUserArnException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidIgnoreApplicationStopFailuresValueException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidInputException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidInstanceNameException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidInstanceStatusException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidInstanceTypeException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidKeyPrefixFilterException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidLifecycleEventHookExecutionIdException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidLifecycleEventHookExecutionStatusException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidLoadBalancerInfoException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidMinimumHealthyHostValueException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidNextTokenException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidOnPremisesTagCombinationException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidOperationException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidRegistrationStatusException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidRevisionException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidRoleException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidSortByException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidSortOrderException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTagException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTagFilterException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTagsToAddException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTargetFilterNameException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTargetGroupPairException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTargetInstancesException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTimeRangeException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTrafficRoutingConfigurationException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidTriggerConfigException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1InvalidUpdateOutdatedInstancesOnlyValueException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1LambdaFunctionInfo = (output, context) => {
    return {
        currentVersion: (0, smithy_client_1.expectString)(output.currentVersion),
        functionAlias: (0, smithy_client_1.expectString)(output.functionAlias),
        functionName: (0, smithy_client_1.expectString)(output.functionName),
        targetVersion: (0, smithy_client_1.expectString)(output.targetVersion),
        targetVersionWeight: (0, smithy_client_1.limitedParseDouble)(output.targetVersionWeight),
    };
};
const deserializeAws_json1_1LambdaTarget = (output, context) => {
    return {
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
        lambdaFunctionInfo: output.lambdaFunctionInfo != null
            ? deserializeAws_json1_1LambdaFunctionInfo(output.lambdaFunctionInfo, context)
            : undefined,
        lastUpdatedAt: output.lastUpdatedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastUpdatedAt)))
            : undefined,
        lifecycleEvents: output.lifecycleEvents != null
            ? deserializeAws_json1_1LifecycleEventList(output.lifecycleEvents, context)
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        targetArn: (0, smithy_client_1.expectString)(output.targetArn),
        targetId: (0, smithy_client_1.expectString)(output.targetId),
    };
};
const deserializeAws_json1_1LastDeploymentInfo = (output, context) => {
    return {
        createTime: output.createTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createTime))) : undefined,
        deploymentId: (0, smithy_client_1.expectString)(output.deploymentId),
        endTime: output.endTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.endTime))) : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_json1_1LifecycleEvent = (output, context) => {
    return {
        diagnostics: output.diagnostics != null ? deserializeAws_json1_1Diagnostics(output.diagnostics, context) : undefined,
        endTime: output.endTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.endTime))) : undefined,
        lifecycleEventName: (0, smithy_client_1.expectString)(output.lifecycleEventName),
        startTime: output.startTime != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.startTime))) : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_json1_1LifecycleEventAlreadyCompletedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1LifecycleEventList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1LifecycleEvent(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1LifecycleHookLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ListApplicationRevisionsOutput = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        revisions: output.revisions != null ? deserializeAws_json1_1RevisionLocationList(output.revisions, context) : undefined,
    };
};
const deserializeAws_json1_1ListApplicationsOutput = (output, context) => {
    return {
        applications: output.applications != null ? deserializeAws_json1_1ApplicationsList(output.applications, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListDeploymentConfigsOutput = (output, context) => {
    return {
        deploymentConfigsList: output.deploymentConfigsList != null
            ? deserializeAws_json1_1DeploymentConfigsList(output.deploymentConfigsList, context)
            : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListDeploymentGroupsOutput = (output, context) => {
    return {
        applicationName: (0, smithy_client_1.expectString)(output.applicationName),
        deploymentGroups: output.deploymentGroups != null
            ? deserializeAws_json1_1DeploymentGroupsList(output.deploymentGroups, context)
            : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListDeploymentInstancesOutput = (output, context) => {
    return {
        instancesList: output.instancesList != null ? deserializeAws_json1_1InstancesList(output.instancesList, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListDeploymentsOutput = (output, context) => {
    return {
        deployments: output.deployments != null ? deserializeAws_json1_1DeploymentsList(output.deployments, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListDeploymentTargetsOutput = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        targetIds: output.targetIds != null ? deserializeAws_json1_1TargetIdList(output.targetIds, context) : undefined,
    };
};
const deserializeAws_json1_1ListenerArnList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1ListGitHubAccountTokenNamesOutput = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        tokenNameList: output.tokenNameList != null
            ? deserializeAws_json1_1GitHubAccountTokenNameList(output.tokenNameList, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListOnPremisesInstancesOutput = (output, context) => {
    return {
        instanceNames: output.instanceNames != null ? deserializeAws_json1_1InstanceNameList(output.instanceNames, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListTagsForResourceOutput = (output, context) => {
    return {
        NextToken: (0, smithy_client_1.expectString)(output.NextToken),
        Tags: output.Tags != null ? deserializeAws_json1_1TagList(output.Tags, context) : undefined,
    };
};
const deserializeAws_json1_1LoadBalancerInfo = (output, context) => {
    return {
        elbInfoList: output.elbInfoList != null ? deserializeAws_json1_1ELBInfoList(output.elbInfoList, context) : undefined,
        targetGroupInfoList: output.targetGroupInfoList != null
            ? deserializeAws_json1_1TargetGroupInfoList(output.targetGroupInfoList, context)
            : undefined,
        targetGroupPairInfoList: output.targetGroupPairInfoList != null
            ? deserializeAws_json1_1TargetGroupPairInfoList(output.targetGroupPairInfoList, context)
            : undefined,
    };
};
const deserializeAws_json1_1MinimumHealthyHosts = (output, context) => {
    return {
        type: (0, smithy_client_1.expectString)(output.type),
        value: (0, smithy_client_1.expectInt32)(output.value),
    };
};
const deserializeAws_json1_1MultipleIamArnsProvidedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1OnPremisesTagSet = (output, context) => {
    return {
        onPremisesTagSetList: output.onPremisesTagSetList != null
            ? deserializeAws_json1_1OnPremisesTagSetList(output.onPremisesTagSetList, context)
            : undefined,
    };
};
const deserializeAws_json1_1OnPremisesTagSetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TagFilterList(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1OperationNotSupportedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1PutLifecycleEventHookExecutionStatusOutput = (output, context) => {
    return {
        lifecycleEventHookExecutionId: (0, smithy_client_1.expectString)(output.lifecycleEventHookExecutionId),
    };
};
const deserializeAws_json1_1RawString = (output, context) => {
    return {
        content: (0, smithy_client_1.expectString)(output.content),
        sha256: (0, smithy_client_1.expectString)(output.sha256),
    };
};
const deserializeAws_json1_1RelatedDeployments = (output, context) => {
    return {
        autoUpdateOutdatedInstancesDeploymentIds: output.autoUpdateOutdatedInstancesDeploymentIds != null
            ? deserializeAws_json1_1DeploymentsList(output.autoUpdateOutdatedInstancesDeploymentIds, context)
            : undefined,
        autoUpdateOutdatedInstancesRootDeploymentId: (0, smithy_client_1.expectString)(output.autoUpdateOutdatedInstancesRootDeploymentId),
    };
};
const deserializeAws_json1_1ResourceArnRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ResourceValidationException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1RevisionDoesNotExistException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1RevisionInfo = (output, context) => {
    return {
        genericRevisionInfo: output.genericRevisionInfo != null
            ? deserializeAws_json1_1GenericRevisionInfo(output.genericRevisionInfo, context)
            : undefined,
        revisionLocation: output.revisionLocation != null
            ? deserializeAws_json1_1RevisionLocation(output.revisionLocation, context)
            : undefined,
    };
};
const deserializeAws_json1_1RevisionInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1RevisionInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1RevisionLocation = (output, context) => {
    return {
        appSpecContent: output.appSpecContent != null ? deserializeAws_json1_1AppSpecContent(output.appSpecContent, context) : undefined,
        gitHubLocation: output.gitHubLocation != null ? deserializeAws_json1_1GitHubLocation(output.gitHubLocation, context) : undefined,
        revisionType: (0, smithy_client_1.expectString)(output.revisionType),
        s3Location: output.s3Location != null ? deserializeAws_json1_1S3Location(output.s3Location, context) : undefined,
        string: output.string != null ? deserializeAws_json1_1RawString(output.string, context) : undefined,
    };
};
const deserializeAws_json1_1RevisionLocationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1RevisionLocation(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1RevisionRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1RoleRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1RollbackInfo = (output, context) => {
    return {
        rollbackDeploymentId: (0, smithy_client_1.expectString)(output.rollbackDeploymentId),
        rollbackMessage: (0, smithy_client_1.expectString)(output.rollbackMessage),
        rollbackTriggeringDeploymentId: (0, smithy_client_1.expectString)(output.rollbackTriggeringDeploymentId),
    };
};
const deserializeAws_json1_1S3Location = (output, context) => {
    return {
        bucket: (0, smithy_client_1.expectString)(output.bucket),
        bundleType: (0, smithy_client_1.expectString)(output.bundleType),
        eTag: (0, smithy_client_1.expectString)(output.eTag),
        key: (0, smithy_client_1.expectString)(output.key),
        version: (0, smithy_client_1.expectString)(output.version),
    };
};
const deserializeAws_json1_1StopDeploymentOutput = (output, context) => {
    return {
        status: (0, smithy_client_1.expectString)(output.status),
        statusMessage: (0, smithy_client_1.expectString)(output.statusMessage),
    };
};
const deserializeAws_json1_1Tag = (output, context) => {
    return {
        Key: (0, smithy_client_1.expectString)(output.Key),
        Value: (0, smithy_client_1.expectString)(output.Value),
    };
};
const deserializeAws_json1_1TagFilter = (output, context) => {
    return {
        Key: (0, smithy_client_1.expectString)(output.Key),
        Type: (0, smithy_client_1.expectString)(output.Type),
        Value: (0, smithy_client_1.expectString)(output.Value),
    };
};
const deserializeAws_json1_1TagFilterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TagFilter(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TagLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Tag(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TagRequiredException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1TagResourceOutput = (output, context) => {
    return {};
};
const deserializeAws_json1_1TagSetListLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1TargetGroupInfo = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
    };
};
const deserializeAws_json1_1TargetGroupInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TargetGroupInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TargetGroupPairInfo = (output, context) => {
    return {
        prodTrafficRoute: output.prodTrafficRoute != null
            ? deserializeAws_json1_1TrafficRoute(output.prodTrafficRoute, context)
            : undefined,
        targetGroups: output.targetGroups != null ? deserializeAws_json1_1TargetGroupInfoList(output.targetGroups, context) : undefined,
        testTrafficRoute: output.testTrafficRoute != null
            ? deserializeAws_json1_1TrafficRoute(output.testTrafficRoute, context)
            : undefined,
    };
};
const deserializeAws_json1_1TargetGroupPairInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TargetGroupPairInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TargetIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1TargetInstances = (output, context) => {
    return {
        autoScalingGroups: output.autoScalingGroups != null
            ? deserializeAws_json1_1AutoScalingGroupNameList(output.autoScalingGroups, context)
            : undefined,
        ec2TagSet: output.ec2TagSet != null ? deserializeAws_json1_1EC2TagSet(output.ec2TagSet, context) : undefined,
        tagFilters: output.tagFilters != null ? deserializeAws_json1_1EC2TagFilterList(output.tagFilters, context) : undefined,
    };
};
const deserializeAws_json1_1ThrottlingException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1TimeBasedCanary = (output, context) => {
    return {
        canaryInterval: (0, smithy_client_1.expectInt32)(output.canaryInterval),
        canaryPercentage: (0, smithy_client_1.expectInt32)(output.canaryPercentage),
    };
};
const deserializeAws_json1_1TimeBasedLinear = (output, context) => {
    return {
        linearInterval: (0, smithy_client_1.expectInt32)(output.linearInterval),
        linearPercentage: (0, smithy_client_1.expectInt32)(output.linearPercentage),
    };
};
const deserializeAws_json1_1TrafficRoute = (output, context) => {
    return {
        listenerArns: output.listenerArns != null ? deserializeAws_json1_1ListenerArnList(output.listenerArns, context) : undefined,
    };
};
const deserializeAws_json1_1TrafficRoutingConfig = (output, context) => {
    return {
        timeBasedCanary: output.timeBasedCanary != null
            ? deserializeAws_json1_1TimeBasedCanary(output.timeBasedCanary, context)
            : undefined,
        timeBasedLinear: output.timeBasedLinear != null
            ? deserializeAws_json1_1TimeBasedLinear(output.timeBasedLinear, context)
            : undefined,
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1TriggerConfig = (output, context) => {
    return {
        triggerEvents: output.triggerEvents != null
            ? deserializeAws_json1_1TriggerEventTypeList(output.triggerEvents, context)
            : undefined,
        triggerName: (0, smithy_client_1.expectString)(output.triggerName),
        triggerTargetArn: (0, smithy_client_1.expectString)(output.triggerTargetArn),
    };
};
const deserializeAws_json1_1TriggerConfigList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TriggerConfig(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TriggerEventTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1TriggerTargetsLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1UnsupportedActionForDeploymentTypeException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1UntagResourceOutput = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateDeploymentGroupOutput = (output, context) => {
    return {
        hooksNotCleanedUp: output.hooksNotCleanedUp != null
            ? deserializeAws_json1_1AutoScalingGroupList(output.hooksNotCleanedUp, context)
            : undefined,
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 23271:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(97035));
const client_sts_1 = __nccwpck_require__(52209);
const config_resolver_1 = __nccwpck_require__(56153);
const credential_provider_node_1 = __nccwpck_require__(75531);
const hash_node_1 = __nccwpck_require__(97442);
const middleware_retry_1 = __nccwpck_require__(96064);
const node_config_provider_1 = __nccwpck_require__(87684);
const node_http_handler_1 = __nccwpck_require__(68805);
const util_body_length_node_1 = __nccwpck_require__(74147);
const util_retry_1 = __nccwpck_require__(99395);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const util_utf8_node_1 = __nccwpck_require__(66278);
const runtimeConfig_shared_1 = __nccwpck_require__(99336);
const smithy_client_1 = __nccwpck_require__(4963);
const util_defaults_mode_node_1 = __nccwpck_require__(74243);
const smithy_client_2 = __nccwpck_require__(4963);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        utf8Decoder: config?.utf8Decoder ?? util_utf8_node_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_node_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 99336:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const url_parser_1 = __nccwpck_require__(2992);
const util_base64_1 = __nccwpck_require__(97727);
const endpointResolver_1 = __nccwpck_require__(15124);
const getRuntimeConfig = (config) => ({
    apiVersion: "2014-10-06",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "CodeDeploy",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 18924:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(22912), exports);


/***/ }),

/***/ 22912:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilDeploymentSuccessful = exports.waitForDeploymentSuccessful = void 0;
const util_waiter_1 = __nccwpck_require__(21627);
const GetDeploymentCommand_1 = __nccwpck_require__(87255);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetDeploymentCommand_1.GetDeploymentCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                return result.deploymentInfo.status;
            };
            if (returnComparator() === "Succeeded") {
                return { state: util_waiter_1.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.deploymentInfo.status;
            };
            if (returnComparator() === "Failed") {
                return { state: util_waiter_1.WaiterState.FAILURE, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.deploymentInfo.status;
            };
            if (returnComparator() === "Stopped") {
                return { state: util_waiter_1.WaiterState.FAILURE, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForDeploymentSuccessful = async (params, input) => {
    const serviceDefaults = { minDelay: 15, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForDeploymentSuccessful = waitForDeploymentSuccessful;
const waitUntilDeploymentSuccessful = async (params, input) => {
    const serviceDefaults = { minDelay: 15, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilDeploymentSuccessful = waitUntilDeploymentSuccessful;


/***/ }),

/***/ 79074:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECS = void 0;
const CreateCapacityProviderCommand_1 = __nccwpck_require__(24286);
const CreateClusterCommand_1 = __nccwpck_require__(39837);
const CreateServiceCommand_1 = __nccwpck_require__(60897);
const CreateTaskSetCommand_1 = __nccwpck_require__(31781);
const DeleteAccountSettingCommand_1 = __nccwpck_require__(71334);
const DeleteAttributesCommand_1 = __nccwpck_require__(88362);
const DeleteCapacityProviderCommand_1 = __nccwpck_require__(7608);
const DeleteClusterCommand_1 = __nccwpck_require__(36303);
const DeleteServiceCommand_1 = __nccwpck_require__(70362);
const DeleteTaskSetCommand_1 = __nccwpck_require__(97462);
const DeregisterContainerInstanceCommand_1 = __nccwpck_require__(83594);
const DeregisterTaskDefinitionCommand_1 = __nccwpck_require__(87388);
const DescribeCapacityProvidersCommand_1 = __nccwpck_require__(42171);
const DescribeClustersCommand_1 = __nccwpck_require__(74863);
const DescribeContainerInstancesCommand_1 = __nccwpck_require__(28965);
const DescribeServicesCommand_1 = __nccwpck_require__(1000);
const DescribeTaskDefinitionCommand_1 = __nccwpck_require__(80991);
const DescribeTasksCommand_1 = __nccwpck_require__(59793);
const DescribeTaskSetsCommand_1 = __nccwpck_require__(40105);
const DiscoverPollEndpointCommand_1 = __nccwpck_require__(21923);
const ExecuteCommandCommand_1 = __nccwpck_require__(79414);
const GetTaskProtectionCommand_1 = __nccwpck_require__(98165);
const ListAccountSettingsCommand_1 = __nccwpck_require__(89726);
const ListAttributesCommand_1 = __nccwpck_require__(51415);
const ListClustersCommand_1 = __nccwpck_require__(92960);
const ListContainerInstancesCommand_1 = __nccwpck_require__(85133);
const ListServicesByNamespaceCommand_1 = __nccwpck_require__(2796);
const ListServicesCommand_1 = __nccwpck_require__(51752);
const ListTagsForResourceCommand_1 = __nccwpck_require__(69786);
const ListTaskDefinitionFamiliesCommand_1 = __nccwpck_require__(62735);
const ListTaskDefinitionsCommand_1 = __nccwpck_require__(27068);
const ListTasksCommand_1 = __nccwpck_require__(67517);
const PutAccountSettingCommand_1 = __nccwpck_require__(25364);
const PutAccountSettingDefaultCommand_1 = __nccwpck_require__(84597);
const PutAttributesCommand_1 = __nccwpck_require__(57327);
const PutClusterCapacityProvidersCommand_1 = __nccwpck_require__(60177);
const RegisterContainerInstanceCommand_1 = __nccwpck_require__(10590);
const RegisterTaskDefinitionCommand_1 = __nccwpck_require__(96309);
const RunTaskCommand_1 = __nccwpck_require__(55037);
const StartTaskCommand_1 = __nccwpck_require__(93535);
const StopTaskCommand_1 = __nccwpck_require__(98004);
const SubmitAttachmentStateChangesCommand_1 = __nccwpck_require__(10047);
const SubmitContainerStateChangeCommand_1 = __nccwpck_require__(60946);
const SubmitTaskStateChangeCommand_1 = __nccwpck_require__(92999);
const TagResourceCommand_1 = __nccwpck_require__(38275);
const UntagResourceCommand_1 = __nccwpck_require__(46926);
const UpdateCapacityProviderCommand_1 = __nccwpck_require__(11810);
const UpdateClusterCommand_1 = __nccwpck_require__(2219);
const UpdateClusterSettingsCommand_1 = __nccwpck_require__(76288);
const UpdateContainerAgentCommand_1 = __nccwpck_require__(32759);
const UpdateContainerInstancesStateCommand_1 = __nccwpck_require__(11453);
const UpdateServiceCommand_1 = __nccwpck_require__(17075);
const UpdateServicePrimaryTaskSetCommand_1 = __nccwpck_require__(94016);
const UpdateTaskProtectionCommand_1 = __nccwpck_require__(86555);
const UpdateTaskSetCommand_1 = __nccwpck_require__(45753);
const ECSClient_1 = __nccwpck_require__(55714);
class ECS extends ECSClient_1.ECSClient {
    createCapacityProvider(args, optionsOrCb, cb) {
        const command = new CreateCapacityProviderCommand_1.CreateCapacityProviderCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createCluster(args, optionsOrCb, cb) {
        const command = new CreateClusterCommand_1.CreateClusterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createService(args, optionsOrCb, cb) {
        const command = new CreateServiceCommand_1.CreateServiceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    createTaskSet(args, optionsOrCb, cb) {
        const command = new CreateTaskSetCommand_1.CreateTaskSetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteAccountSetting(args, optionsOrCb, cb) {
        const command = new DeleteAccountSettingCommand_1.DeleteAccountSettingCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteAttributes(args, optionsOrCb, cb) {
        const command = new DeleteAttributesCommand_1.DeleteAttributesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteCapacityProvider(args, optionsOrCb, cb) {
        const command = new DeleteCapacityProviderCommand_1.DeleteCapacityProviderCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteCluster(args, optionsOrCb, cb) {
        const command = new DeleteClusterCommand_1.DeleteClusterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteService(args, optionsOrCb, cb) {
        const command = new DeleteServiceCommand_1.DeleteServiceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deleteTaskSet(args, optionsOrCb, cb) {
        const command = new DeleteTaskSetCommand_1.DeleteTaskSetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deregisterContainerInstance(args, optionsOrCb, cb) {
        const command = new DeregisterContainerInstanceCommand_1.DeregisterContainerInstanceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    deregisterTaskDefinition(args, optionsOrCb, cb) {
        const command = new DeregisterTaskDefinitionCommand_1.DeregisterTaskDefinitionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeCapacityProviders(args, optionsOrCb, cb) {
        const command = new DescribeCapacityProvidersCommand_1.DescribeCapacityProvidersCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeClusters(args, optionsOrCb, cb) {
        const command = new DescribeClustersCommand_1.DescribeClustersCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeContainerInstances(args, optionsOrCb, cb) {
        const command = new DescribeContainerInstancesCommand_1.DescribeContainerInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeServices(args, optionsOrCb, cb) {
        const command = new DescribeServicesCommand_1.DescribeServicesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeTaskDefinition(args, optionsOrCb, cb) {
        const command = new DescribeTaskDefinitionCommand_1.DescribeTaskDefinitionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeTasks(args, optionsOrCb, cb) {
        const command = new DescribeTasksCommand_1.DescribeTasksCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    describeTaskSets(args, optionsOrCb, cb) {
        const command = new DescribeTaskSetsCommand_1.DescribeTaskSetsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    discoverPollEndpoint(args, optionsOrCb, cb) {
        const command = new DiscoverPollEndpointCommand_1.DiscoverPollEndpointCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    executeCommand(args, optionsOrCb, cb) {
        const command = new ExecuteCommandCommand_1.ExecuteCommandCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getTaskProtection(args, optionsOrCb, cb) {
        const command = new GetTaskProtectionCommand_1.GetTaskProtectionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listAccountSettings(args, optionsOrCb, cb) {
        const command = new ListAccountSettingsCommand_1.ListAccountSettingsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listAttributes(args, optionsOrCb, cb) {
        const command = new ListAttributesCommand_1.ListAttributesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listClusters(args, optionsOrCb, cb) {
        const command = new ListClustersCommand_1.ListClustersCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listContainerInstances(args, optionsOrCb, cb) {
        const command = new ListContainerInstancesCommand_1.ListContainerInstancesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listServices(args, optionsOrCb, cb) {
        const command = new ListServicesCommand_1.ListServicesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listServicesByNamespace(args, optionsOrCb, cb) {
        const command = new ListServicesByNamespaceCommand_1.ListServicesByNamespaceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listTagsForResource(args, optionsOrCb, cb) {
        const command = new ListTagsForResourceCommand_1.ListTagsForResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listTaskDefinitionFamilies(args, optionsOrCb, cb) {
        const command = new ListTaskDefinitionFamiliesCommand_1.ListTaskDefinitionFamiliesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listTaskDefinitions(args, optionsOrCb, cb) {
        const command = new ListTaskDefinitionsCommand_1.ListTaskDefinitionsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listTasks(args, optionsOrCb, cb) {
        const command = new ListTasksCommand_1.ListTasksCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putAccountSetting(args, optionsOrCb, cb) {
        const command = new PutAccountSettingCommand_1.PutAccountSettingCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putAccountSettingDefault(args, optionsOrCb, cb) {
        const command = new PutAccountSettingDefaultCommand_1.PutAccountSettingDefaultCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putAttributes(args, optionsOrCb, cb) {
        const command = new PutAttributesCommand_1.PutAttributesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    putClusterCapacityProviders(args, optionsOrCb, cb) {
        const command = new PutClusterCapacityProvidersCommand_1.PutClusterCapacityProvidersCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    registerContainerInstance(args, optionsOrCb, cb) {
        const command = new RegisterContainerInstanceCommand_1.RegisterContainerInstanceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    registerTaskDefinition(args, optionsOrCb, cb) {
        const command = new RegisterTaskDefinitionCommand_1.RegisterTaskDefinitionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    runTask(args, optionsOrCb, cb) {
        const command = new RunTaskCommand_1.RunTaskCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    startTask(args, optionsOrCb, cb) {
        const command = new StartTaskCommand_1.StartTaskCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    stopTask(args, optionsOrCb, cb) {
        const command = new StopTaskCommand_1.StopTaskCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    submitAttachmentStateChanges(args, optionsOrCb, cb) {
        const command = new SubmitAttachmentStateChangesCommand_1.SubmitAttachmentStateChangesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    submitContainerStateChange(args, optionsOrCb, cb) {
        const command = new SubmitContainerStateChangeCommand_1.SubmitContainerStateChangeCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    submitTaskStateChange(args, optionsOrCb, cb) {
        const command = new SubmitTaskStateChangeCommand_1.SubmitTaskStateChangeCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    tagResource(args, optionsOrCb, cb) {
        const command = new TagResourceCommand_1.TagResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    untagResource(args, optionsOrCb, cb) {
        const command = new UntagResourceCommand_1.UntagResourceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateCapacityProvider(args, optionsOrCb, cb) {
        const command = new UpdateCapacityProviderCommand_1.UpdateCapacityProviderCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateCluster(args, optionsOrCb, cb) {
        const command = new UpdateClusterCommand_1.UpdateClusterCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateClusterSettings(args, optionsOrCb, cb) {
        const command = new UpdateClusterSettingsCommand_1.UpdateClusterSettingsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateContainerAgent(args, optionsOrCb, cb) {
        const command = new UpdateContainerAgentCommand_1.UpdateContainerAgentCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateContainerInstancesState(args, optionsOrCb, cb) {
        const command = new UpdateContainerInstancesStateCommand_1.UpdateContainerInstancesStateCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateService(args, optionsOrCb, cb) {
        const command = new UpdateServiceCommand_1.UpdateServiceCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateServicePrimaryTaskSet(args, optionsOrCb, cb) {
        const command = new UpdateServicePrimaryTaskSetCommand_1.UpdateServicePrimaryTaskSetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateTaskProtection(args, optionsOrCb, cb) {
        const command = new UpdateTaskProtectionCommand_1.UpdateTaskProtectionCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    updateTaskSet(args, optionsOrCb, cb) {
        const command = new UpdateTaskSetCommand_1.UpdateTaskSetCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
}
exports.ECS = ECS;


/***/ }),

/***/ 55714:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECSClient = void 0;
const config_resolver_1 = __nccwpck_require__(56153);
const middleware_content_length_1 = __nccwpck_require__(42245);
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_retry_1 = __nccwpck_require__(96064);
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const smithy_client_1 = __nccwpck_require__(4963);
const EndpointParameters_1 = __nccwpck_require__(19970);
const runtimeConfig_1 = __nccwpck_require__(47246);
class ECSClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.ECSClient = ECSClient;


/***/ }),

/***/ 24286:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateCapacityProviderCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class CreateCapacityProviderCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateCapacityProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "CreateCapacityProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateCapacityProviderRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateCapacityProviderResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateCapacityProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateCapacityProviderCommand)(output, context);
    }
}
exports.CreateCapacityProviderCommand = CreateCapacityProviderCommand;


/***/ }),

/***/ 39837:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateClusterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class CreateClusterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateClusterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "CreateClusterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateClusterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateClusterResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateClusterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateClusterCommand)(output, context);
    }
}
exports.CreateClusterCommand = CreateClusterCommand;


/***/ }),

/***/ 60897:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateServiceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class CreateServiceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateServiceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "CreateServiceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateServiceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateServiceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateServiceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateServiceCommand)(output, context);
    }
}
exports.CreateServiceCommand = CreateServiceCommand;


/***/ }),

/***/ 31781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTaskSetCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class CreateTaskSetCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateTaskSetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "CreateTaskSetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateTaskSetRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateTaskSetResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1CreateTaskSetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1CreateTaskSetCommand)(output, context);
    }
}
exports.CreateTaskSetCommand = CreateTaskSetCommand;


/***/ }),

/***/ 71334:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteAccountSettingCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeleteAccountSettingCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteAccountSettingCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeleteAccountSettingCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteAccountSettingRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteAccountSettingResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteAccountSettingCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteAccountSettingCommand)(output, context);
    }
}
exports.DeleteAccountSettingCommand = DeleteAccountSettingCommand;


/***/ }),

/***/ 88362:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteAttributesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeleteAttributesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteAttributesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeleteAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteAttributesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteAttributesCommand)(output, context);
    }
}
exports.DeleteAttributesCommand = DeleteAttributesCommand;


/***/ }),

/***/ 7608:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteCapacityProviderCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeleteCapacityProviderCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteCapacityProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeleteCapacityProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteCapacityProviderRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteCapacityProviderResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteCapacityProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteCapacityProviderCommand)(output, context);
    }
}
exports.DeleteCapacityProviderCommand = DeleteCapacityProviderCommand;


/***/ }),

/***/ 36303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteClusterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeleteClusterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteClusterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeleteClusterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteClusterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteClusterResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteClusterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteClusterCommand)(output, context);
    }
}
exports.DeleteClusterCommand = DeleteClusterCommand;


/***/ }),

/***/ 70362:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteServiceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeleteServiceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteServiceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeleteServiceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteServiceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteServiceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteServiceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteServiceCommand)(output, context);
    }
}
exports.DeleteServiceCommand = DeleteServiceCommand;


/***/ }),

/***/ 97462:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteTaskSetCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeleteTaskSetCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteTaskSetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeleteTaskSetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteTaskSetRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeleteTaskSetResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeleteTaskSetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeleteTaskSetCommand)(output, context);
    }
}
exports.DeleteTaskSetCommand = DeleteTaskSetCommand;


/***/ }),

/***/ 83594:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeregisterContainerInstanceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeregisterContainerInstanceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeregisterContainerInstanceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeregisterContainerInstanceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeregisterContainerInstanceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeregisterContainerInstanceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeregisterContainerInstanceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeregisterContainerInstanceCommand)(output, context);
    }
}
exports.DeregisterContainerInstanceCommand = DeregisterContainerInstanceCommand;


/***/ }),

/***/ 87388:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeregisterTaskDefinitionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DeregisterTaskDefinitionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeregisterTaskDefinitionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DeregisterTaskDefinitionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeregisterTaskDefinitionRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DeregisterTaskDefinitionResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DeregisterTaskDefinitionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DeregisterTaskDefinitionCommand)(output, context);
    }
}
exports.DeregisterTaskDefinitionCommand = DeregisterTaskDefinitionCommand;


/***/ }),

/***/ 42171:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeCapacityProvidersCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DescribeCapacityProvidersCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeCapacityProvidersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DescribeCapacityProvidersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeCapacityProvidersRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeCapacityProvidersResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeCapacityProvidersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeCapacityProvidersCommand)(output, context);
    }
}
exports.DescribeCapacityProvidersCommand = DescribeCapacityProvidersCommand;


/***/ }),

/***/ 74863:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeClustersCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DescribeClustersCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeClustersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DescribeClustersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeClustersRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeClustersResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeClustersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeClustersCommand)(output, context);
    }
}
exports.DescribeClustersCommand = DescribeClustersCommand;


/***/ }),

/***/ 28965:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeContainerInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DescribeContainerInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeContainerInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DescribeContainerInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeContainerInstancesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeContainerInstancesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeContainerInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeContainerInstancesCommand)(output, context);
    }
}
exports.DescribeContainerInstancesCommand = DescribeContainerInstancesCommand;


/***/ }),

/***/ 1000:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeServicesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DescribeServicesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeServicesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DescribeServicesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeServicesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeServicesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeServicesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeServicesCommand)(output, context);
    }
}
exports.DescribeServicesCommand = DescribeServicesCommand;


/***/ }),

/***/ 80991:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeTaskDefinitionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DescribeTaskDefinitionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeTaskDefinitionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DescribeTaskDefinitionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeTaskDefinitionRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeTaskDefinitionResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeTaskDefinitionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeTaskDefinitionCommand)(output, context);
    }
}
exports.DescribeTaskDefinitionCommand = DescribeTaskDefinitionCommand;


/***/ }),

/***/ 40105:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeTaskSetsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DescribeTaskSetsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeTaskSetsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DescribeTaskSetsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeTaskSetsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeTaskSetsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeTaskSetsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeTaskSetsCommand)(output, context);
    }
}
exports.DescribeTaskSetsCommand = DescribeTaskSetsCommand;


/***/ }),

/***/ 59793:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeTasksCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DescribeTasksCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeTasksCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DescribeTasksCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeTasksRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeTasksResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DescribeTasksCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DescribeTasksCommand)(output, context);
    }
}
exports.DescribeTasksCommand = DescribeTasksCommand;


/***/ }),

/***/ 21923:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiscoverPollEndpointCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class DiscoverPollEndpointCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DiscoverPollEndpointCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "DiscoverPollEndpointCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DiscoverPollEndpointRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DiscoverPollEndpointResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1DiscoverPollEndpointCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1DiscoverPollEndpointCommand)(output, context);
    }
}
exports.DiscoverPollEndpointCommand = DiscoverPollEndpointCommand;


/***/ }),

/***/ 79414:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecuteCommandCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ExecuteCommandCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ExecuteCommandCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ExecuteCommandCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ExecuteCommandRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ExecuteCommandResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ExecuteCommandCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ExecuteCommandCommand)(output, context);
    }
}
exports.ExecuteCommandCommand = ExecuteCommandCommand;


/***/ }),

/***/ 98165:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetTaskProtectionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class GetTaskProtectionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetTaskProtectionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "GetTaskProtectionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetTaskProtectionRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetTaskProtectionResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1GetTaskProtectionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1GetTaskProtectionCommand)(output, context);
    }
}
exports.GetTaskProtectionCommand = GetTaskProtectionCommand;


/***/ }),

/***/ 89726:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountSettingsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListAccountSettingsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountSettingsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListAccountSettingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAccountSettingsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListAccountSettingsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListAccountSettingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListAccountSettingsCommand)(output, context);
    }
}
exports.ListAccountSettingsCommand = ListAccountSettingsCommand;


/***/ }),

/***/ 51415:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAttributesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListAttributesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAttributesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListAttributesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListAttributesCommand)(output, context);
    }
}
exports.ListAttributesCommand = ListAttributesCommand;


/***/ }),

/***/ 92960:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListClustersCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListClustersCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListClustersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListClustersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListClustersRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListClustersResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListClustersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListClustersCommand)(output, context);
    }
}
exports.ListClustersCommand = ListClustersCommand;


/***/ }),

/***/ 85133:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListContainerInstancesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListContainerInstancesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListContainerInstancesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListContainerInstancesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListContainerInstancesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListContainerInstancesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListContainerInstancesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListContainerInstancesCommand)(output, context);
    }
}
exports.ListContainerInstancesCommand = ListContainerInstancesCommand;


/***/ }),

/***/ 2796:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListServicesByNamespaceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListServicesByNamespaceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListServicesByNamespaceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListServicesByNamespaceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListServicesByNamespaceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListServicesByNamespaceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListServicesByNamespaceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListServicesByNamespaceCommand)(output, context);
    }
}
exports.ListServicesByNamespaceCommand = ListServicesByNamespaceCommand;


/***/ }),

/***/ 51752:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListServicesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListServicesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListServicesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListServicesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListServicesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListServicesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListServicesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListServicesCommand)(output, context);
    }
}
exports.ListServicesCommand = ListServicesCommand;


/***/ }),

/***/ 69786:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTagsForResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListTagsForResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTagsForResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListTagsForResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListTagsForResourceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListTagsForResourceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListTagsForResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListTagsForResourceCommand)(output, context);
    }
}
exports.ListTagsForResourceCommand = ListTagsForResourceCommand;


/***/ }),

/***/ 62735:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTaskDefinitionFamiliesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListTaskDefinitionFamiliesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTaskDefinitionFamiliesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListTaskDefinitionFamiliesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListTaskDefinitionFamiliesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListTaskDefinitionFamiliesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListTaskDefinitionFamiliesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListTaskDefinitionFamiliesCommand)(output, context);
    }
}
exports.ListTaskDefinitionFamiliesCommand = ListTaskDefinitionFamiliesCommand;


/***/ }),

/***/ 27068:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTaskDefinitionsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListTaskDefinitionsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTaskDefinitionsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListTaskDefinitionsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListTaskDefinitionsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListTaskDefinitionsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListTaskDefinitionsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListTaskDefinitionsCommand)(output, context);
    }
}
exports.ListTaskDefinitionsCommand = ListTaskDefinitionsCommand;


/***/ }),

/***/ 67517:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTasksCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class ListTasksCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTasksCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "ListTasksCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListTasksRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListTasksResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1ListTasksCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1ListTasksCommand)(output, context);
    }
}
exports.ListTasksCommand = ListTasksCommand;


/***/ }),

/***/ 25364:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutAccountSettingCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class PutAccountSettingCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutAccountSettingCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "PutAccountSettingCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutAccountSettingRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutAccountSettingResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutAccountSettingCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutAccountSettingCommand)(output, context);
    }
}
exports.PutAccountSettingCommand = PutAccountSettingCommand;


/***/ }),

/***/ 84597:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutAccountSettingDefaultCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class PutAccountSettingDefaultCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutAccountSettingDefaultCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "PutAccountSettingDefaultCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutAccountSettingDefaultRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutAccountSettingDefaultResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutAccountSettingDefaultCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutAccountSettingDefaultCommand)(output, context);
    }
}
exports.PutAccountSettingDefaultCommand = PutAccountSettingDefaultCommand;


/***/ }),

/***/ 57327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutAttributesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class PutAttributesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutAttributesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "PutAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutAttributesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutAttributesCommand)(output, context);
    }
}
exports.PutAttributesCommand = PutAttributesCommand;


/***/ }),

/***/ 60177:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutClusterCapacityProvidersCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class PutClusterCapacityProvidersCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, PutClusterCapacityProvidersCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "PutClusterCapacityProvidersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.PutClusterCapacityProvidersRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.PutClusterCapacityProvidersResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1PutClusterCapacityProvidersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1PutClusterCapacityProvidersCommand)(output, context);
    }
}
exports.PutClusterCapacityProvidersCommand = PutClusterCapacityProvidersCommand;


/***/ }),

/***/ 10590:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterContainerInstanceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class RegisterContainerInstanceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RegisterContainerInstanceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "RegisterContainerInstanceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RegisterContainerInstanceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.RegisterContainerInstanceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1RegisterContainerInstanceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1RegisterContainerInstanceCommand)(output, context);
    }
}
exports.RegisterContainerInstanceCommand = RegisterContainerInstanceCommand;


/***/ }),

/***/ 96309:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterTaskDefinitionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class RegisterTaskDefinitionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RegisterTaskDefinitionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "RegisterTaskDefinitionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RegisterTaskDefinitionRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.RegisterTaskDefinitionResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1RegisterTaskDefinitionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1RegisterTaskDefinitionCommand)(output, context);
    }
}
exports.RegisterTaskDefinitionCommand = RegisterTaskDefinitionCommand;


/***/ }),

/***/ 55037:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunTaskCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class RunTaskCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RunTaskCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "RunTaskCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RunTaskRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.RunTaskResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1RunTaskCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1RunTaskCommand)(output, context);
    }
}
exports.RunTaskCommand = RunTaskCommand;


/***/ }),

/***/ 93535:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StartTaskCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class StartTaskCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StartTaskCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "StartTaskCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.StartTaskRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.StartTaskResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1StartTaskCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1StartTaskCommand)(output, context);
    }
}
exports.StartTaskCommand = StartTaskCommand;


/***/ }),

/***/ 98004:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StopTaskCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class StopTaskCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StopTaskCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "StopTaskCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.StopTaskRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.StopTaskResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1StopTaskCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1StopTaskCommand)(output, context);
    }
}
exports.StopTaskCommand = StopTaskCommand;


/***/ }),

/***/ 10047:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubmitAttachmentStateChangesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class SubmitAttachmentStateChangesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SubmitAttachmentStateChangesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "SubmitAttachmentStateChangesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.SubmitAttachmentStateChangesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.SubmitAttachmentStateChangesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1SubmitAttachmentStateChangesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1SubmitAttachmentStateChangesCommand)(output, context);
    }
}
exports.SubmitAttachmentStateChangesCommand = SubmitAttachmentStateChangesCommand;


/***/ }),

/***/ 60946:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubmitContainerStateChangeCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class SubmitContainerStateChangeCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SubmitContainerStateChangeCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "SubmitContainerStateChangeCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.SubmitContainerStateChangeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.SubmitContainerStateChangeResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1SubmitContainerStateChangeCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1SubmitContainerStateChangeCommand)(output, context);
    }
}
exports.SubmitContainerStateChangeCommand = SubmitContainerStateChangeCommand;


/***/ }),

/***/ 92999:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubmitTaskStateChangeCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class SubmitTaskStateChangeCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SubmitTaskStateChangeCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "SubmitTaskStateChangeCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.SubmitTaskStateChangeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.SubmitTaskStateChangeResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1SubmitTaskStateChangeCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1SubmitTaskStateChangeCommand)(output, context);
    }
}
exports.SubmitTaskStateChangeCommand = SubmitTaskStateChangeCommand;


/***/ }),

/***/ 38275:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class TagResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "TagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.TagResourceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.TagResourceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1TagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1TagResourceCommand)(output, context);
    }
}
exports.TagResourceCommand = TagResourceCommand;


/***/ }),

/***/ 46926:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagResourceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UntagResourceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagResourceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UntagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UntagResourceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UntagResourceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UntagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UntagResourceCommand)(output, context);
    }
}
exports.UntagResourceCommand = UntagResourceCommand;


/***/ }),

/***/ 11810:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateCapacityProviderCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateCapacityProviderCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateCapacityProviderCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateCapacityProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateCapacityProviderRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateCapacityProviderResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateCapacityProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateCapacityProviderCommand)(output, context);
    }
}
exports.UpdateCapacityProviderCommand = UpdateCapacityProviderCommand;


/***/ }),

/***/ 2219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateClusterCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateClusterCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateClusterCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateClusterCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateClusterRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateClusterResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateClusterCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateClusterCommand)(output, context);
    }
}
exports.UpdateClusterCommand = UpdateClusterCommand;


/***/ }),

/***/ 76288:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateClusterSettingsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateClusterSettingsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateClusterSettingsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateClusterSettingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateClusterSettingsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateClusterSettingsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateClusterSettingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateClusterSettingsCommand)(output, context);
    }
}
exports.UpdateClusterSettingsCommand = UpdateClusterSettingsCommand;


/***/ }),

/***/ 32759:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateContainerAgentCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateContainerAgentCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateContainerAgentCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateContainerAgentCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateContainerAgentRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateContainerAgentResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateContainerAgentCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateContainerAgentCommand)(output, context);
    }
}
exports.UpdateContainerAgentCommand = UpdateContainerAgentCommand;


/***/ }),

/***/ 11453:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateContainerInstancesStateCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateContainerInstancesStateCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateContainerInstancesStateCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateContainerInstancesStateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateContainerInstancesStateRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateContainerInstancesStateResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateContainerInstancesStateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateContainerInstancesStateCommand)(output, context);
    }
}
exports.UpdateContainerInstancesStateCommand = UpdateContainerInstancesStateCommand;


/***/ }),

/***/ 17075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateServiceCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateServiceCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateServiceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateServiceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateServiceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateServiceResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateServiceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateServiceCommand)(output, context);
    }
}
exports.UpdateServiceCommand = UpdateServiceCommand;


/***/ }),

/***/ 94016:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateServicePrimaryTaskSetCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateServicePrimaryTaskSetCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateServicePrimaryTaskSetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateServicePrimaryTaskSetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateServicePrimaryTaskSetRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateServicePrimaryTaskSetResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateServicePrimaryTaskSetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateServicePrimaryTaskSetCommand)(output, context);
    }
}
exports.UpdateServicePrimaryTaskSetCommand = UpdateServicePrimaryTaskSetCommand;


/***/ }),

/***/ 86555:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateTaskProtectionCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateTaskProtectionCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateTaskProtectionCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateTaskProtectionCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateTaskProtectionRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateTaskProtectionResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateTaskProtectionCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateTaskProtectionCommand)(output, context);
    }
}
exports.UpdateTaskProtectionCommand = UpdateTaskProtectionCommand;


/***/ }),

/***/ 45753:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateTaskSetCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(89402);
const Aws_json1_1_1 = __nccwpck_require__(56556);
class UpdateTaskSetCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateTaskSetCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "ECSClient";
        const commandName = "UpdateTaskSetCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.UpdateTaskSetRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.UpdateTaskSetResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.serializeAws_json1_1UpdateTaskSetCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.deserializeAws_json1_1UpdateTaskSetCommand)(output, context);
    }
}
exports.UpdateTaskSetCommand = UpdateTaskSetCommand;


/***/ }),

/***/ 65233:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(24286), exports);
tslib_1.__exportStar(__nccwpck_require__(39837), exports);
tslib_1.__exportStar(__nccwpck_require__(60897), exports);
tslib_1.__exportStar(__nccwpck_require__(31781), exports);
tslib_1.__exportStar(__nccwpck_require__(71334), exports);
tslib_1.__exportStar(__nccwpck_require__(88362), exports);
tslib_1.__exportStar(__nccwpck_require__(7608), exports);
tslib_1.__exportStar(__nccwpck_require__(36303), exports);
tslib_1.__exportStar(__nccwpck_require__(70362), exports);
tslib_1.__exportStar(__nccwpck_require__(97462), exports);
tslib_1.__exportStar(__nccwpck_require__(83594), exports);
tslib_1.__exportStar(__nccwpck_require__(87388), exports);
tslib_1.__exportStar(__nccwpck_require__(42171), exports);
tslib_1.__exportStar(__nccwpck_require__(74863), exports);
tslib_1.__exportStar(__nccwpck_require__(28965), exports);
tslib_1.__exportStar(__nccwpck_require__(1000), exports);
tslib_1.__exportStar(__nccwpck_require__(80991), exports);
tslib_1.__exportStar(__nccwpck_require__(40105), exports);
tslib_1.__exportStar(__nccwpck_require__(59793), exports);
tslib_1.__exportStar(__nccwpck_require__(21923), exports);
tslib_1.__exportStar(__nccwpck_require__(79414), exports);
tslib_1.__exportStar(__nccwpck_require__(98165), exports);
tslib_1.__exportStar(__nccwpck_require__(89726), exports);
tslib_1.__exportStar(__nccwpck_require__(51415), exports);
tslib_1.__exportStar(__nccwpck_require__(92960), exports);
tslib_1.__exportStar(__nccwpck_require__(85133), exports);
tslib_1.__exportStar(__nccwpck_require__(2796), exports);
tslib_1.__exportStar(__nccwpck_require__(51752), exports);
tslib_1.__exportStar(__nccwpck_require__(69786), exports);
tslib_1.__exportStar(__nccwpck_require__(62735), exports);
tslib_1.__exportStar(__nccwpck_require__(27068), exports);
tslib_1.__exportStar(__nccwpck_require__(67517), exports);
tslib_1.__exportStar(__nccwpck_require__(25364), exports);
tslib_1.__exportStar(__nccwpck_require__(84597), exports);
tslib_1.__exportStar(__nccwpck_require__(57327), exports);
tslib_1.__exportStar(__nccwpck_require__(60177), exports);
tslib_1.__exportStar(__nccwpck_require__(10590), exports);
tslib_1.__exportStar(__nccwpck_require__(96309), exports);
tslib_1.__exportStar(__nccwpck_require__(55037), exports);
tslib_1.__exportStar(__nccwpck_require__(93535), exports);
tslib_1.__exportStar(__nccwpck_require__(98004), exports);
tslib_1.__exportStar(__nccwpck_require__(10047), exports);
tslib_1.__exportStar(__nccwpck_require__(60946), exports);
tslib_1.__exportStar(__nccwpck_require__(92999), exports);
tslib_1.__exportStar(__nccwpck_require__(38275), exports);
tslib_1.__exportStar(__nccwpck_require__(46926), exports);
tslib_1.__exportStar(__nccwpck_require__(11810), exports);
tslib_1.__exportStar(__nccwpck_require__(2219), exports);
tslib_1.__exportStar(__nccwpck_require__(76288), exports);
tslib_1.__exportStar(__nccwpck_require__(32759), exports);
tslib_1.__exportStar(__nccwpck_require__(11453), exports);
tslib_1.__exportStar(__nccwpck_require__(17075), exports);
tslib_1.__exportStar(__nccwpck_require__(94016), exports);
tslib_1.__exportStar(__nccwpck_require__(86555), exports);
tslib_1.__exportStar(__nccwpck_require__(45753), exports);


/***/ }),

/***/ 19970:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "ecs",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 55021:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(83635);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 83635:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const q = "fn", r = "argv", s = "ref";
const a = true, b = false, c = "String", d = "PartitionResult", e = "tree", f = "error", g = "endpoint", h = { "required": true, "default": false, "type": "Boolean" }, i = { [s]: "Endpoint" }, j = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] }, k = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] }, l = {}, m = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: d }, "supportsFIPS"] }] }, n = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: d }, "supportsDualStack"] }] }, o = [j], p = [k];
const _data = { version: "1.0", parameters: { Region: { required: a, type: c }, UseDualStack: h, UseFIPS: h, Endpoint: { required: b, type: c } }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: d }], type: e, rules: [{ conditions: [{ [q]: "isSet", [r]: [i] }], type: e, rules: [{ conditions: o, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: f }, { type: e, rules: [{ conditions: p, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: f }, { endpoint: { url: i, properties: l, headers: l }, type: g }] }] }, { conditions: [j, k], type: e, rules: [{ conditions: [m, n], type: e, rules: [{ endpoint: { url: "https://ecs-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: l, headers: l }, type: g }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: f }] }, { conditions: o, type: e, rules: [{ conditions: [m], type: e, rules: [{ type: e, rules: [{ endpoint: { url: "https://ecs-fips.{Region}.{PartitionResult#dnsSuffix}", properties: l, headers: l }, type: g }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: f }] }, { conditions: p, type: e, rules: [{ conditions: [n], type: e, rules: [{ endpoint: { url: "https://ecs.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: l, headers: l }, type: g }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: f }] }, { endpoint: { url: "https://ecs.{Region}.{PartitionResult#dnsSuffix}", properties: l, headers: l }, type: g }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 18209:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECSServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(79074), exports);
tslib_1.__exportStar(__nccwpck_require__(55714), exports);
tslib_1.__exportStar(__nccwpck_require__(65233), exports);
tslib_1.__exportStar(__nccwpck_require__(22040), exports);
tslib_1.__exportStar(__nccwpck_require__(84488), exports);
tslib_1.__exportStar(__nccwpck_require__(64379), exports);
var ECSServiceException_1 = __nccwpck_require__(47688);
Object.defineProperty(exports, "ECSServiceException", ({ enumerable: true, get: function () { return ECSServiceException_1.ECSServiceException; } }));


/***/ }),

/***/ 47688:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECSServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
class ECSServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, ECSServiceException.prototype);
    }
}
exports.ECSServiceException = ECSServiceException;


/***/ }),

/***/ 22040:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(89402), exports);


/***/ }),

/***/ 89402:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpcMode = exports.UlimitName = exports.ResourceType = exports.TransportProtocol = exports.ApplicationProtocol = exports.DeviceCgroupPermission = exports.FirelensConfigurationType = exports.EnvironmentFileType = exports.ContainerCondition = exports.Compatibility = exports.InstanceHealthCheckType = exports.InstanceHealthCheckState = exports.TaskSetNotFoundException = exports.ClusterContainsTasksException = exports.ClusterContainsServicesException = exports.ClusterContainsContainerInstancesException = exports.TargetNotFoundException = exports.TargetType = exports.SettingName = exports.ServiceNotFoundException = exports.ServiceNotActiveException = exports.UnsupportedFeatureException = exports.PlatformUnknownException = exports.PlatformTaskDefinitionIncompatibilityException = exports.NamespaceNotFoundException = exports.StabilityStatus = exports.ScaleUnit = exports.DeploymentRolloutState = exports.LogDriver = exports.SchedulingStrategy = exports.PropagateTags = exports.PlacementStrategyType = exports.PlacementConstraintType = exports.AssignPublicIp = exports.LaunchType = exports.DeploymentControllerType = exports.ClusterNotFoundException = exports.ClusterSettingName = exports.ExecuteCommandLogging = exports.UpdateInProgressException = exports.ServerException = exports.LimitExceededException = exports.InvalidParameterException = exports.CapacityProviderUpdateStatus = exports.CapacityProviderStatus = exports.ManagedTerminationProtection = exports.ManagedScalingStatus = exports.ClientException = exports.AgentUpdateStatus = exports.AccessDeniedException = void 0;
exports.ClusterFilterSensitiveLog = exports.ClusterServiceConnectDefaultsFilterSensitiveLog = exports.AttachmentFilterSensitiveLog = exports.KeyValuePairFilterSensitiveLog = exports.CreateClusterRequestFilterSensitiveLog = exports.ClusterSettingFilterSensitiveLog = exports.ClusterServiceConnectDefaultsRequestFilterSensitiveLog = exports.CapacityProviderStrategyItemFilterSensitiveLog = exports.ClusterConfigurationFilterSensitiveLog = exports.ExecuteCommandConfigurationFilterSensitiveLog = exports.ExecuteCommandLogConfigurationFilterSensitiveLog = exports.CreateCapacityProviderResponseFilterSensitiveLog = exports.CapacityProviderFilterSensitiveLog = exports.CreateCapacityProviderRequestFilterSensitiveLog = exports.TagFilterSensitiveLog = exports.AutoScalingGroupProviderFilterSensitiveLog = exports.ManagedScalingFilterSensitiveLog = exports.NoUpdateAvailableException = exports.MissingVersionException = exports.BlockedException = exports.PlatformDeviceType = exports.ResourceInUseException = exports.AttributeLimitExceededException = exports.DesiredStatus = exports.SortOrder = exports.TaskDefinitionFamilyStatus = exports.ContainerInstanceStatus = exports.ResourceNotFoundException = exports.TargetNotConnectedException = exports.TaskSetField = exports.TaskStopCode = exports.ManagedAgentName = exports.HealthStatus = exports.Connectivity = exports.TaskField = exports.TaskDefinitionField = exports.ServiceField = exports.ContainerInstanceField = exports.ClusterField = exports.CapacityProviderField = exports.EFSTransitEncryption = exports.EFSAuthorizationConfigIAM = exports.Scope = exports.TaskDefinitionStatus = exports.OSFamily = exports.CPUArchitecture = exports.ProxyConfigurationType = exports.TaskDefinitionPlacementConstraintType = exports.PidMode = exports.NetworkMode = void 0;
exports.EnvironmentFileFilterSensitiveLog = exports.ContainerDependencyFilterSensitiveLog = exports.DeregisterTaskDefinitionRequestFilterSensitiveLog = exports.DeregisterContainerInstanceResponseFilterSensitiveLog = exports.ContainerInstanceFilterSensitiveLog = exports.VersionInfoFilterSensitiveLog = exports.ResourceFilterSensitiveLog = exports.ContainerInstanceHealthStatusFilterSensitiveLog = exports.InstanceHealthCheckResultFilterSensitiveLog = exports.DeregisterContainerInstanceRequestFilterSensitiveLog = exports.DeleteTaskSetResponseFilterSensitiveLog = exports.DeleteTaskSetRequestFilterSensitiveLog = exports.DeleteServiceResponseFilterSensitiveLog = exports.DeleteServiceRequestFilterSensitiveLog = exports.DeleteClusterResponseFilterSensitiveLog = exports.DeleteClusterRequestFilterSensitiveLog = exports.DeleteCapacityProviderResponseFilterSensitiveLog = exports.DeleteCapacityProviderRequestFilterSensitiveLog = exports.DeleteAttributesResponseFilterSensitiveLog = exports.DeleteAttributesRequestFilterSensitiveLog = exports.AttributeFilterSensitiveLog = exports.DeleteAccountSettingResponseFilterSensitiveLog = exports.SettingFilterSensitiveLog = exports.DeleteAccountSettingRequestFilterSensitiveLog = exports.CreateTaskSetResponseFilterSensitiveLog = exports.CreateTaskSetRequestFilterSensitiveLog = exports.CreateServiceResponseFilterSensitiveLog = exports.ServiceFilterSensitiveLog = exports.TaskSetFilterSensitiveLog = exports.ScaleFilterSensitiveLog = exports.ServiceEventFilterSensitiveLog = exports.DeploymentFilterSensitiveLog = exports.ServiceConnectServiceResourceFilterSensitiveLog = exports.CreateServiceRequestFilterSensitiveLog = exports.ServiceRegistryFilterSensitiveLog = exports.ServiceConnectConfigurationFilterSensitiveLog = exports.ServiceConnectServiceFilterSensitiveLog = exports.ServiceConnectClientAliasFilterSensitiveLog = exports.LogConfigurationFilterSensitiveLog = exports.SecretFilterSensitiveLog = exports.PlacementStrategyFilterSensitiveLog = exports.PlacementConstraintFilterSensitiveLog = exports.NetworkConfigurationFilterSensitiveLog = exports.AwsVpcConfigurationFilterSensitiveLog = exports.LoadBalancerFilterSensitiveLog = exports.DeploymentControllerFilterSensitiveLog = exports.DeploymentConfigurationFilterSensitiveLog = exports.DeploymentCircuitBreakerFilterSensitiveLog = exports.DeploymentAlarmsFilterSensitiveLog = exports.CreateClusterResponseFilterSensitiveLog = void 0;
exports.DescribeTasksResponseFilterSensitiveLog = exports.TaskFilterSensitiveLog = exports.TaskOverrideFilterSensitiveLog = exports.InferenceAcceleratorOverrideFilterSensitiveLog = exports.ContainerOverrideFilterSensitiveLog = exports.ContainerFilterSensitiveLog = exports.NetworkInterfaceFilterSensitiveLog = exports.NetworkBindingFilterSensitiveLog = exports.ManagedAgentFilterSensitiveLog = exports.DescribeTasksRequestFilterSensitiveLog = exports.DescribeTaskDefinitionResponseFilterSensitiveLog = exports.DescribeTaskDefinitionRequestFilterSensitiveLog = exports.DescribeServicesResponseFilterSensitiveLog = exports.DescribeServicesRequestFilterSensitiveLog = exports.DescribeContainerInstancesResponseFilterSensitiveLog = exports.DescribeContainerInstancesRequestFilterSensitiveLog = exports.DescribeClustersResponseFilterSensitiveLog = exports.DescribeClustersRequestFilterSensitiveLog = exports.DescribeCapacityProvidersResponseFilterSensitiveLog = exports.FailureFilterSensitiveLog = exports.DescribeCapacityProvidersRequestFilterSensitiveLog = exports.DeregisterTaskDefinitionResponseFilterSensitiveLog = exports.TaskDefinitionFilterSensitiveLog = exports.VolumeFilterSensitiveLog = exports.HostVolumePropertiesFilterSensitiveLog = exports.FSxWindowsFileServerVolumeConfigurationFilterSensitiveLog = exports.FSxWindowsFileServerAuthorizationConfigFilterSensitiveLog = exports.EFSVolumeConfigurationFilterSensitiveLog = exports.EFSAuthorizationConfigFilterSensitiveLog = exports.DockerVolumeConfigurationFilterSensitiveLog = exports.RuntimePlatformFilterSensitiveLog = exports.ProxyConfigurationFilterSensitiveLog = exports.TaskDefinitionPlacementConstraintFilterSensitiveLog = exports.InferenceAcceleratorFilterSensitiveLog = exports.EphemeralStorageFilterSensitiveLog = exports.ContainerDefinitionFilterSensitiveLog = exports.VolumeFromFilterSensitiveLog = exports.UlimitFilterSensitiveLog = exports.SystemControlFilterSensitiveLog = exports.ResourceRequirementFilterSensitiveLog = exports.RepositoryCredentialsFilterSensitiveLog = exports.PortMappingFilterSensitiveLog = exports.MountPointFilterSensitiveLog = exports.LinuxParametersFilterSensitiveLog = exports.TmpfsFilterSensitiveLog = exports.DeviceFilterSensitiveLog = exports.KernelCapabilitiesFilterSensitiveLog = exports.HealthCheckFilterSensitiveLog = exports.FirelensConfigurationFilterSensitiveLog = exports.HostEntryFilterSensitiveLog = void 0;
exports.AttachmentStateChangeFilterSensitiveLog = exports.StopTaskResponseFilterSensitiveLog = exports.StopTaskRequestFilterSensitiveLog = exports.StartTaskResponseFilterSensitiveLog = exports.StartTaskRequestFilterSensitiveLog = exports.RunTaskResponseFilterSensitiveLog = exports.RunTaskRequestFilterSensitiveLog = exports.RegisterTaskDefinitionResponseFilterSensitiveLog = exports.RegisterTaskDefinitionRequestFilterSensitiveLog = exports.RegisterContainerInstanceResponseFilterSensitiveLog = exports.RegisterContainerInstanceRequestFilterSensitiveLog = exports.PlatformDeviceFilterSensitiveLog = exports.PutClusterCapacityProvidersResponseFilterSensitiveLog = exports.PutClusterCapacityProvidersRequestFilterSensitiveLog = exports.PutAttributesResponseFilterSensitiveLog = exports.PutAttributesRequestFilterSensitiveLog = exports.PutAccountSettingDefaultResponseFilterSensitiveLog = exports.PutAccountSettingDefaultRequestFilterSensitiveLog = exports.PutAccountSettingResponseFilterSensitiveLog = exports.PutAccountSettingRequestFilterSensitiveLog = exports.ListTasksResponseFilterSensitiveLog = exports.ListTasksRequestFilterSensitiveLog = exports.ListTaskDefinitionsResponseFilterSensitiveLog = exports.ListTaskDefinitionsRequestFilterSensitiveLog = exports.ListTaskDefinitionFamiliesResponseFilterSensitiveLog = exports.ListTaskDefinitionFamiliesRequestFilterSensitiveLog = exports.ListTagsForResourceResponseFilterSensitiveLog = exports.ListTagsForResourceRequestFilterSensitiveLog = exports.ListServicesByNamespaceResponseFilterSensitiveLog = exports.ListServicesByNamespaceRequestFilterSensitiveLog = exports.ListServicesResponseFilterSensitiveLog = exports.ListServicesRequestFilterSensitiveLog = exports.ListContainerInstancesResponseFilterSensitiveLog = exports.ListContainerInstancesRequestFilterSensitiveLog = exports.ListClustersResponseFilterSensitiveLog = exports.ListClustersRequestFilterSensitiveLog = exports.ListAttributesResponseFilterSensitiveLog = exports.ListAttributesRequestFilterSensitiveLog = exports.ListAccountSettingsResponseFilterSensitiveLog = exports.ListAccountSettingsRequestFilterSensitiveLog = exports.GetTaskProtectionResponseFilterSensitiveLog = exports.ProtectedTaskFilterSensitiveLog = exports.GetTaskProtectionRequestFilterSensitiveLog = exports.ExecuteCommandResponseFilterSensitiveLog = exports.SessionFilterSensitiveLog = exports.ExecuteCommandRequestFilterSensitiveLog = exports.DiscoverPollEndpointResponseFilterSensitiveLog = exports.DiscoverPollEndpointRequestFilterSensitiveLog = exports.DescribeTaskSetsResponseFilterSensitiveLog = exports.DescribeTaskSetsRequestFilterSensitiveLog = void 0;
exports.UpdateTaskSetResponseFilterSensitiveLog = exports.UpdateTaskSetRequestFilterSensitiveLog = exports.UpdateTaskProtectionResponseFilterSensitiveLog = exports.UpdateTaskProtectionRequestFilterSensitiveLog = exports.UpdateServicePrimaryTaskSetResponseFilterSensitiveLog = exports.UpdateServicePrimaryTaskSetRequestFilterSensitiveLog = exports.UpdateServiceResponseFilterSensitiveLog = exports.UpdateServiceRequestFilterSensitiveLog = exports.UpdateContainerInstancesStateResponseFilterSensitiveLog = exports.UpdateContainerInstancesStateRequestFilterSensitiveLog = exports.UpdateContainerAgentResponseFilterSensitiveLog = exports.UpdateContainerAgentRequestFilterSensitiveLog = exports.UpdateClusterSettingsResponseFilterSensitiveLog = exports.UpdateClusterSettingsRequestFilterSensitiveLog = exports.UpdateClusterResponseFilterSensitiveLog = exports.UpdateClusterRequestFilterSensitiveLog = exports.UpdateCapacityProviderResponseFilterSensitiveLog = exports.UpdateCapacityProviderRequestFilterSensitiveLog = exports.AutoScalingGroupProviderUpdateFilterSensitiveLog = exports.UntagResourceResponseFilterSensitiveLog = exports.UntagResourceRequestFilterSensitiveLog = exports.TagResourceResponseFilterSensitiveLog = exports.TagResourceRequestFilterSensitiveLog = exports.SubmitTaskStateChangeResponseFilterSensitiveLog = exports.SubmitTaskStateChangeRequestFilterSensitiveLog = exports.ManagedAgentStateChangeFilterSensitiveLog = exports.ContainerStateChangeFilterSensitiveLog = exports.SubmitContainerStateChangeResponseFilterSensitiveLog = exports.SubmitContainerStateChangeRequestFilterSensitiveLog = exports.SubmitAttachmentStateChangesResponseFilterSensitiveLog = exports.SubmitAttachmentStateChangesRequestFilterSensitiveLog = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const ECSServiceException_1 = __nccwpck_require__(47688);
class AccessDeniedException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
    }
}
exports.AccessDeniedException = AccessDeniedException;
var AgentUpdateStatus;
(function (AgentUpdateStatus) {
    AgentUpdateStatus["FAILED"] = "FAILED";
    AgentUpdateStatus["PENDING"] = "PENDING";
    AgentUpdateStatus["STAGED"] = "STAGED";
    AgentUpdateStatus["STAGING"] = "STAGING";
    AgentUpdateStatus["UPDATED"] = "UPDATED";
    AgentUpdateStatus["UPDATING"] = "UPDATING";
})(AgentUpdateStatus = exports.AgentUpdateStatus || (exports.AgentUpdateStatus = {}));
class ClientException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClientException.prototype);
    }
}
exports.ClientException = ClientException;
var ManagedScalingStatus;
(function (ManagedScalingStatus) {
    ManagedScalingStatus["DISABLED"] = "DISABLED";
    ManagedScalingStatus["ENABLED"] = "ENABLED";
})(ManagedScalingStatus = exports.ManagedScalingStatus || (exports.ManagedScalingStatus = {}));
var ManagedTerminationProtection;
(function (ManagedTerminationProtection) {
    ManagedTerminationProtection["DISABLED"] = "DISABLED";
    ManagedTerminationProtection["ENABLED"] = "ENABLED";
})(ManagedTerminationProtection = exports.ManagedTerminationProtection || (exports.ManagedTerminationProtection = {}));
var CapacityProviderStatus;
(function (CapacityProviderStatus) {
    CapacityProviderStatus["ACTIVE"] = "ACTIVE";
    CapacityProviderStatus["INACTIVE"] = "INACTIVE";
})(CapacityProviderStatus = exports.CapacityProviderStatus || (exports.CapacityProviderStatus = {}));
var CapacityProviderUpdateStatus;
(function (CapacityProviderUpdateStatus) {
    CapacityProviderUpdateStatus["DELETE_COMPLETE"] = "DELETE_COMPLETE";
    CapacityProviderUpdateStatus["DELETE_FAILED"] = "DELETE_FAILED";
    CapacityProviderUpdateStatus["DELETE_IN_PROGRESS"] = "DELETE_IN_PROGRESS";
    CapacityProviderUpdateStatus["UPDATE_COMPLETE"] = "UPDATE_COMPLETE";
    CapacityProviderUpdateStatus["UPDATE_FAILED"] = "UPDATE_FAILED";
    CapacityProviderUpdateStatus["UPDATE_IN_PROGRESS"] = "UPDATE_IN_PROGRESS";
})(CapacityProviderUpdateStatus = exports.CapacityProviderUpdateStatus || (exports.CapacityProviderUpdateStatus = {}));
class InvalidParameterException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "InvalidParameterException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidParameterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidParameterException.prototype);
    }
}
exports.InvalidParameterException = InvalidParameterException;
class LimitExceededException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
}
exports.LimitExceededException = LimitExceededException;
class ServerException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "ServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, ServerException.prototype);
    }
}
exports.ServerException = ServerException;
class UpdateInProgressException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "UpdateInProgressException",
            $fault: "client",
            ...opts,
        });
        this.name = "UpdateInProgressException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UpdateInProgressException.prototype);
    }
}
exports.UpdateInProgressException = UpdateInProgressException;
var ExecuteCommandLogging;
(function (ExecuteCommandLogging) {
    ExecuteCommandLogging["DEFAULT"] = "DEFAULT";
    ExecuteCommandLogging["NONE"] = "NONE";
    ExecuteCommandLogging["OVERRIDE"] = "OVERRIDE";
})(ExecuteCommandLogging = exports.ExecuteCommandLogging || (exports.ExecuteCommandLogging = {}));
var ClusterSettingName;
(function (ClusterSettingName) {
    ClusterSettingName["CONTAINER_INSIGHTS"] = "containerInsights";
})(ClusterSettingName = exports.ClusterSettingName || (exports.ClusterSettingName = {}));
class ClusterNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterNotFoundException.prototype);
    }
}
exports.ClusterNotFoundException = ClusterNotFoundException;
var DeploymentControllerType;
(function (DeploymentControllerType) {
    DeploymentControllerType["CODE_DEPLOY"] = "CODE_DEPLOY";
    DeploymentControllerType["ECS"] = "ECS";
    DeploymentControllerType["EXTERNAL"] = "EXTERNAL";
})(DeploymentControllerType = exports.DeploymentControllerType || (exports.DeploymentControllerType = {}));
var LaunchType;
(function (LaunchType) {
    LaunchType["EC2"] = "EC2";
    LaunchType["EXTERNAL"] = "EXTERNAL";
    LaunchType["FARGATE"] = "FARGATE";
})(LaunchType = exports.LaunchType || (exports.LaunchType = {}));
var AssignPublicIp;
(function (AssignPublicIp) {
    AssignPublicIp["DISABLED"] = "DISABLED";
    AssignPublicIp["ENABLED"] = "ENABLED";
})(AssignPublicIp = exports.AssignPublicIp || (exports.AssignPublicIp = {}));
var PlacementConstraintType;
(function (PlacementConstraintType) {
    PlacementConstraintType["DISTINCT_INSTANCE"] = "distinctInstance";
    PlacementConstraintType["MEMBER_OF"] = "memberOf";
})(PlacementConstraintType = exports.PlacementConstraintType || (exports.PlacementConstraintType = {}));
var PlacementStrategyType;
(function (PlacementStrategyType) {
    PlacementStrategyType["BINPACK"] = "binpack";
    PlacementStrategyType["RANDOM"] = "random";
    PlacementStrategyType["SPREAD"] = "spread";
})(PlacementStrategyType = exports.PlacementStrategyType || (exports.PlacementStrategyType = {}));
var PropagateTags;
(function (PropagateTags) {
    PropagateTags["NONE"] = "NONE";
    PropagateTags["SERVICE"] = "SERVICE";
    PropagateTags["TASK_DEFINITION"] = "TASK_DEFINITION";
})(PropagateTags = exports.PropagateTags || (exports.PropagateTags = {}));
var SchedulingStrategy;
(function (SchedulingStrategy) {
    SchedulingStrategy["DAEMON"] = "DAEMON";
    SchedulingStrategy["REPLICA"] = "REPLICA";
})(SchedulingStrategy = exports.SchedulingStrategy || (exports.SchedulingStrategy = {}));
var LogDriver;
(function (LogDriver) {
    LogDriver["AWSFIRELENS"] = "awsfirelens";
    LogDriver["AWSLOGS"] = "awslogs";
    LogDriver["FLUENTD"] = "fluentd";
    LogDriver["GELF"] = "gelf";
    LogDriver["JOURNALD"] = "journald";
    LogDriver["JSON_FILE"] = "json-file";
    LogDriver["SPLUNK"] = "splunk";
    LogDriver["SYSLOG"] = "syslog";
})(LogDriver = exports.LogDriver || (exports.LogDriver = {}));
var DeploymentRolloutState;
(function (DeploymentRolloutState) {
    DeploymentRolloutState["COMPLETED"] = "COMPLETED";
    DeploymentRolloutState["FAILED"] = "FAILED";
    DeploymentRolloutState["IN_PROGRESS"] = "IN_PROGRESS";
})(DeploymentRolloutState = exports.DeploymentRolloutState || (exports.DeploymentRolloutState = {}));
var ScaleUnit;
(function (ScaleUnit) {
    ScaleUnit["PERCENT"] = "PERCENT";
})(ScaleUnit = exports.ScaleUnit || (exports.ScaleUnit = {}));
var StabilityStatus;
(function (StabilityStatus) {
    StabilityStatus["STABILIZING"] = "STABILIZING";
    StabilityStatus["STEADY_STATE"] = "STEADY_STATE";
})(StabilityStatus = exports.StabilityStatus || (exports.StabilityStatus = {}));
class NamespaceNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "NamespaceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "NamespaceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NamespaceNotFoundException.prototype);
    }
}
exports.NamespaceNotFoundException = NamespaceNotFoundException;
class PlatformTaskDefinitionIncompatibilityException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "PlatformTaskDefinitionIncompatibilityException",
            $fault: "client",
            ...opts,
        });
        this.name = "PlatformTaskDefinitionIncompatibilityException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PlatformTaskDefinitionIncompatibilityException.prototype);
    }
}
exports.PlatformTaskDefinitionIncompatibilityException = PlatformTaskDefinitionIncompatibilityException;
class PlatformUnknownException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "PlatformUnknownException",
            $fault: "client",
            ...opts,
        });
        this.name = "PlatformUnknownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PlatformUnknownException.prototype);
    }
}
exports.PlatformUnknownException = PlatformUnknownException;
class UnsupportedFeatureException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedFeatureException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedFeatureException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedFeatureException.prototype);
    }
}
exports.UnsupportedFeatureException = UnsupportedFeatureException;
class ServiceNotActiveException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ServiceNotActiveException",
            $fault: "client",
            ...opts,
        });
        this.name = "ServiceNotActiveException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ServiceNotActiveException.prototype);
    }
}
exports.ServiceNotActiveException = ServiceNotActiveException;
class ServiceNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ServiceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ServiceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ServiceNotFoundException.prototype);
    }
}
exports.ServiceNotFoundException = ServiceNotFoundException;
var SettingName;
(function (SettingName) {
    SettingName["AWSVPC_TRUNKING"] = "awsvpcTrunking";
    SettingName["CONTAINER_INSIGHTS"] = "containerInsights";
    SettingName["CONTAINER_INSTANCE_LONG_ARN_FORMAT"] = "containerInstanceLongArnFormat";
    SettingName["SERVICE_LONG_ARN_FORMAT"] = "serviceLongArnFormat";
    SettingName["TASK_LONG_ARN_FORMAT"] = "taskLongArnFormat";
})(SettingName = exports.SettingName || (exports.SettingName = {}));
var TargetType;
(function (TargetType) {
    TargetType["CONTAINER_INSTANCE"] = "container-instance";
})(TargetType = exports.TargetType || (exports.TargetType = {}));
class TargetNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "TargetNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "TargetNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TargetNotFoundException.prototype);
    }
}
exports.TargetNotFoundException = TargetNotFoundException;
class ClusterContainsContainerInstancesException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterContainsContainerInstancesException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterContainsContainerInstancesException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterContainsContainerInstancesException.prototype);
    }
}
exports.ClusterContainsContainerInstancesException = ClusterContainsContainerInstancesException;
class ClusterContainsServicesException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterContainsServicesException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterContainsServicesException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterContainsServicesException.prototype);
    }
}
exports.ClusterContainsServicesException = ClusterContainsServicesException;
class ClusterContainsTasksException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ClusterContainsTasksException",
            $fault: "client",
            ...opts,
        });
        this.name = "ClusterContainsTasksException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ClusterContainsTasksException.prototype);
    }
}
exports.ClusterContainsTasksException = ClusterContainsTasksException;
class TaskSetNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "TaskSetNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "TaskSetNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TaskSetNotFoundException.prototype);
    }
}
exports.TaskSetNotFoundException = TaskSetNotFoundException;
var InstanceHealthCheckState;
(function (InstanceHealthCheckState) {
    InstanceHealthCheckState["IMPAIRED"] = "IMPAIRED";
    InstanceHealthCheckState["INITIALIZING"] = "INITIALIZING";
    InstanceHealthCheckState["INSUFFICIENT_DATA"] = "INSUFFICIENT_DATA";
    InstanceHealthCheckState["OK"] = "OK";
})(InstanceHealthCheckState = exports.InstanceHealthCheckState || (exports.InstanceHealthCheckState = {}));
var InstanceHealthCheckType;
(function (InstanceHealthCheckType) {
    InstanceHealthCheckType["CONTAINER_RUNTIME"] = "CONTAINER_RUNTIME";
})(InstanceHealthCheckType = exports.InstanceHealthCheckType || (exports.InstanceHealthCheckType = {}));
var Compatibility;
(function (Compatibility) {
    Compatibility["EC2"] = "EC2";
    Compatibility["EXTERNAL"] = "EXTERNAL";
    Compatibility["FARGATE"] = "FARGATE";
})(Compatibility = exports.Compatibility || (exports.Compatibility = {}));
var ContainerCondition;
(function (ContainerCondition) {
    ContainerCondition["COMPLETE"] = "COMPLETE";
    ContainerCondition["HEALTHY"] = "HEALTHY";
    ContainerCondition["START"] = "START";
    ContainerCondition["SUCCESS"] = "SUCCESS";
})(ContainerCondition = exports.ContainerCondition || (exports.ContainerCondition = {}));
var EnvironmentFileType;
(function (EnvironmentFileType) {
    EnvironmentFileType["S3"] = "s3";
})(EnvironmentFileType = exports.EnvironmentFileType || (exports.EnvironmentFileType = {}));
var FirelensConfigurationType;
(function (FirelensConfigurationType) {
    FirelensConfigurationType["FLUENTBIT"] = "fluentbit";
    FirelensConfigurationType["FLUENTD"] = "fluentd";
})(FirelensConfigurationType = exports.FirelensConfigurationType || (exports.FirelensConfigurationType = {}));
var DeviceCgroupPermission;
(function (DeviceCgroupPermission) {
    DeviceCgroupPermission["MKNOD"] = "mknod";
    DeviceCgroupPermission["READ"] = "read";
    DeviceCgroupPermission["WRITE"] = "write";
})(DeviceCgroupPermission = exports.DeviceCgroupPermission || (exports.DeviceCgroupPermission = {}));
var ApplicationProtocol;
(function (ApplicationProtocol) {
    ApplicationProtocol["GRPC"] = "grpc";
    ApplicationProtocol["HTTP"] = "http";
    ApplicationProtocol["HTTP2"] = "http2";
})(ApplicationProtocol = exports.ApplicationProtocol || (exports.ApplicationProtocol = {}));
var TransportProtocol;
(function (TransportProtocol) {
    TransportProtocol["TCP"] = "tcp";
    TransportProtocol["UDP"] = "udp";
})(TransportProtocol = exports.TransportProtocol || (exports.TransportProtocol = {}));
var ResourceType;
(function (ResourceType) {
    ResourceType["GPU"] = "GPU";
    ResourceType["INFERENCE_ACCELERATOR"] = "InferenceAccelerator";
})(ResourceType = exports.ResourceType || (exports.ResourceType = {}));
var UlimitName;
(function (UlimitName) {
    UlimitName["CORE"] = "core";
    UlimitName["CPU"] = "cpu";
    UlimitName["DATA"] = "data";
    UlimitName["FSIZE"] = "fsize";
    UlimitName["LOCKS"] = "locks";
    UlimitName["MEMLOCK"] = "memlock";
    UlimitName["MSGQUEUE"] = "msgqueue";
    UlimitName["NICE"] = "nice";
    UlimitName["NOFILE"] = "nofile";
    UlimitName["NPROC"] = "nproc";
    UlimitName["RSS"] = "rss";
    UlimitName["RTPRIO"] = "rtprio";
    UlimitName["RTTIME"] = "rttime";
    UlimitName["SIGPENDING"] = "sigpending";
    UlimitName["STACK"] = "stack";
})(UlimitName = exports.UlimitName || (exports.UlimitName = {}));
var IpcMode;
(function (IpcMode) {
    IpcMode["HOST"] = "host";
    IpcMode["NONE"] = "none";
    IpcMode["TASK"] = "task";
})(IpcMode = exports.IpcMode || (exports.IpcMode = {}));
var NetworkMode;
(function (NetworkMode) {
    NetworkMode["AWSVPC"] = "awsvpc";
    NetworkMode["BRIDGE"] = "bridge";
    NetworkMode["HOST"] = "host";
    NetworkMode["NONE"] = "none";
})(NetworkMode = exports.NetworkMode || (exports.NetworkMode = {}));
var PidMode;
(function (PidMode) {
    PidMode["HOST"] = "host";
    PidMode["TASK"] = "task";
})(PidMode = exports.PidMode || (exports.PidMode = {}));
var TaskDefinitionPlacementConstraintType;
(function (TaskDefinitionPlacementConstraintType) {
    TaskDefinitionPlacementConstraintType["MEMBER_OF"] = "memberOf";
})(TaskDefinitionPlacementConstraintType = exports.TaskDefinitionPlacementConstraintType || (exports.TaskDefinitionPlacementConstraintType = {}));
var ProxyConfigurationType;
(function (ProxyConfigurationType) {
    ProxyConfigurationType["APPMESH"] = "APPMESH";
})(ProxyConfigurationType = exports.ProxyConfigurationType || (exports.ProxyConfigurationType = {}));
var CPUArchitecture;
(function (CPUArchitecture) {
    CPUArchitecture["ARM64"] = "ARM64";
    CPUArchitecture["X86_64"] = "X86_64";
})(CPUArchitecture = exports.CPUArchitecture || (exports.CPUArchitecture = {}));
var OSFamily;
(function (OSFamily) {
    OSFamily["LINUX"] = "LINUX";
    OSFamily["WINDOWS_SERVER_2004_CORE"] = "WINDOWS_SERVER_2004_CORE";
    OSFamily["WINDOWS_SERVER_2016_FULL"] = "WINDOWS_SERVER_2016_FULL";
    OSFamily["WINDOWS_SERVER_2019_CORE"] = "WINDOWS_SERVER_2019_CORE";
    OSFamily["WINDOWS_SERVER_2019_FULL"] = "WINDOWS_SERVER_2019_FULL";
    OSFamily["WINDOWS_SERVER_2022_CORE"] = "WINDOWS_SERVER_2022_CORE";
    OSFamily["WINDOWS_SERVER_2022_FULL"] = "WINDOWS_SERVER_2022_FULL";
    OSFamily["WINDOWS_SERVER_20H2_CORE"] = "WINDOWS_SERVER_20H2_CORE";
})(OSFamily = exports.OSFamily || (exports.OSFamily = {}));
var TaskDefinitionStatus;
(function (TaskDefinitionStatus) {
    TaskDefinitionStatus["ACTIVE"] = "ACTIVE";
    TaskDefinitionStatus["INACTIVE"] = "INACTIVE";
})(TaskDefinitionStatus = exports.TaskDefinitionStatus || (exports.TaskDefinitionStatus = {}));
var Scope;
(function (Scope) {
    Scope["SHARED"] = "shared";
    Scope["TASK"] = "task";
})(Scope = exports.Scope || (exports.Scope = {}));
var EFSAuthorizationConfigIAM;
(function (EFSAuthorizationConfigIAM) {
    EFSAuthorizationConfigIAM["DISABLED"] = "DISABLED";
    EFSAuthorizationConfigIAM["ENABLED"] = "ENABLED";
})(EFSAuthorizationConfigIAM = exports.EFSAuthorizationConfigIAM || (exports.EFSAuthorizationConfigIAM = {}));
var EFSTransitEncryption;
(function (EFSTransitEncryption) {
    EFSTransitEncryption["DISABLED"] = "DISABLED";
    EFSTransitEncryption["ENABLED"] = "ENABLED";
})(EFSTransitEncryption = exports.EFSTransitEncryption || (exports.EFSTransitEncryption = {}));
var CapacityProviderField;
(function (CapacityProviderField) {
    CapacityProviderField["TAGS"] = "TAGS";
})(CapacityProviderField = exports.CapacityProviderField || (exports.CapacityProviderField = {}));
var ClusterField;
(function (ClusterField) {
    ClusterField["ATTACHMENTS"] = "ATTACHMENTS";
    ClusterField["CONFIGURATIONS"] = "CONFIGURATIONS";
    ClusterField["SETTINGS"] = "SETTINGS";
    ClusterField["STATISTICS"] = "STATISTICS";
    ClusterField["TAGS"] = "TAGS";
})(ClusterField = exports.ClusterField || (exports.ClusterField = {}));
var ContainerInstanceField;
(function (ContainerInstanceField) {
    ContainerInstanceField["CONTAINER_INSTANCE_HEALTH"] = "CONTAINER_INSTANCE_HEALTH";
    ContainerInstanceField["TAGS"] = "TAGS";
})(ContainerInstanceField = exports.ContainerInstanceField || (exports.ContainerInstanceField = {}));
var ServiceField;
(function (ServiceField) {
    ServiceField["TAGS"] = "TAGS";
})(ServiceField = exports.ServiceField || (exports.ServiceField = {}));
var TaskDefinitionField;
(function (TaskDefinitionField) {
    TaskDefinitionField["TAGS"] = "TAGS";
})(TaskDefinitionField = exports.TaskDefinitionField || (exports.TaskDefinitionField = {}));
var TaskField;
(function (TaskField) {
    TaskField["TAGS"] = "TAGS";
})(TaskField = exports.TaskField || (exports.TaskField = {}));
var Connectivity;
(function (Connectivity) {
    Connectivity["CONNECTED"] = "CONNECTED";
    Connectivity["DISCONNECTED"] = "DISCONNECTED";
})(Connectivity = exports.Connectivity || (exports.Connectivity = {}));
var HealthStatus;
(function (HealthStatus) {
    HealthStatus["HEALTHY"] = "HEALTHY";
    HealthStatus["UNHEALTHY"] = "UNHEALTHY";
    HealthStatus["UNKNOWN"] = "UNKNOWN";
})(HealthStatus = exports.HealthStatus || (exports.HealthStatus = {}));
var ManagedAgentName;
(function (ManagedAgentName) {
    ManagedAgentName["ExecuteCommandAgent"] = "ExecuteCommandAgent";
})(ManagedAgentName = exports.ManagedAgentName || (exports.ManagedAgentName = {}));
var TaskStopCode;
(function (TaskStopCode) {
    TaskStopCode["ESSENTIAL_CONTAINER_EXITED"] = "EssentialContainerExited";
    TaskStopCode["SERVICE_SCHEDULER_INITIATED"] = "ServiceSchedulerInitiated";
    TaskStopCode["SPOT_INTERRUPTION"] = "SpotInterruption";
    TaskStopCode["TASK_FAILED_TO_START"] = "TaskFailedToStart";
    TaskStopCode["TERMINATION_NOTICE"] = "TerminationNotice";
    TaskStopCode["USER_INITIATED"] = "UserInitiated";
})(TaskStopCode = exports.TaskStopCode || (exports.TaskStopCode = {}));
var TaskSetField;
(function (TaskSetField) {
    TaskSetField["TAGS"] = "TAGS";
})(TaskSetField = exports.TaskSetField || (exports.TaskSetField = {}));
class TargetNotConnectedException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "TargetNotConnectedException",
            $fault: "client",
            ...opts,
        });
        this.name = "TargetNotConnectedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TargetNotConnectedException.prototype);
    }
}
exports.TargetNotConnectedException = TargetNotConnectedException;
class ResourceNotFoundException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
var ContainerInstanceStatus;
(function (ContainerInstanceStatus) {
    ContainerInstanceStatus["ACTIVE"] = "ACTIVE";
    ContainerInstanceStatus["DEREGISTERING"] = "DEREGISTERING";
    ContainerInstanceStatus["DRAINING"] = "DRAINING";
    ContainerInstanceStatus["REGISTERING"] = "REGISTERING";
    ContainerInstanceStatus["REGISTRATION_FAILED"] = "REGISTRATION_FAILED";
})(ContainerInstanceStatus = exports.ContainerInstanceStatus || (exports.ContainerInstanceStatus = {}));
var TaskDefinitionFamilyStatus;
(function (TaskDefinitionFamilyStatus) {
    TaskDefinitionFamilyStatus["ACTIVE"] = "ACTIVE";
    TaskDefinitionFamilyStatus["ALL"] = "ALL";
    TaskDefinitionFamilyStatus["INACTIVE"] = "INACTIVE";
})(TaskDefinitionFamilyStatus = exports.TaskDefinitionFamilyStatus || (exports.TaskDefinitionFamilyStatus = {}));
var SortOrder;
(function (SortOrder) {
    SortOrder["ASC"] = "ASC";
    SortOrder["DESC"] = "DESC";
})(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
var DesiredStatus;
(function (DesiredStatus) {
    DesiredStatus["PENDING"] = "PENDING";
    DesiredStatus["RUNNING"] = "RUNNING";
    DesiredStatus["STOPPED"] = "STOPPED";
})(DesiredStatus = exports.DesiredStatus || (exports.DesiredStatus = {}));
class AttributeLimitExceededException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "AttributeLimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "AttributeLimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AttributeLimitExceededException.prototype);
    }
}
exports.AttributeLimitExceededException = AttributeLimitExceededException;
class ResourceInUseException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "ResourceInUseException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceInUseException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceInUseException.prototype);
    }
}
exports.ResourceInUseException = ResourceInUseException;
var PlatformDeviceType;
(function (PlatformDeviceType) {
    PlatformDeviceType["GPU"] = "GPU";
})(PlatformDeviceType = exports.PlatformDeviceType || (exports.PlatformDeviceType = {}));
class BlockedException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "BlockedException",
            $fault: "client",
            ...opts,
        });
        this.name = "BlockedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, BlockedException.prototype);
    }
}
exports.BlockedException = BlockedException;
class MissingVersionException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "MissingVersionException",
            $fault: "client",
            ...opts,
        });
        this.name = "MissingVersionException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MissingVersionException.prototype);
    }
}
exports.MissingVersionException = MissingVersionException;
class NoUpdateAvailableException extends ECSServiceException_1.ECSServiceException {
    constructor(opts) {
        super({
            name: "NoUpdateAvailableException",
            $fault: "client",
            ...opts,
        });
        this.name = "NoUpdateAvailableException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoUpdateAvailableException.prototype);
    }
}
exports.NoUpdateAvailableException = NoUpdateAvailableException;
const ManagedScalingFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ManagedScalingFilterSensitiveLog = ManagedScalingFilterSensitiveLog;
const AutoScalingGroupProviderFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AutoScalingGroupProviderFilterSensitiveLog = AutoScalingGroupProviderFilterSensitiveLog;
const TagFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagFilterSensitiveLog = TagFilterSensitiveLog;
const CreateCapacityProviderRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateCapacityProviderRequestFilterSensitiveLog = CreateCapacityProviderRequestFilterSensitiveLog;
const CapacityProviderFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CapacityProviderFilterSensitiveLog = CapacityProviderFilterSensitiveLog;
const CreateCapacityProviderResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateCapacityProviderResponseFilterSensitiveLog = CreateCapacityProviderResponseFilterSensitiveLog;
const ExecuteCommandLogConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ExecuteCommandLogConfigurationFilterSensitiveLog = ExecuteCommandLogConfigurationFilterSensitiveLog;
const ExecuteCommandConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ExecuteCommandConfigurationFilterSensitiveLog = ExecuteCommandConfigurationFilterSensitiveLog;
const ClusterConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ClusterConfigurationFilterSensitiveLog = ClusterConfigurationFilterSensitiveLog;
const CapacityProviderStrategyItemFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CapacityProviderStrategyItemFilterSensitiveLog = CapacityProviderStrategyItemFilterSensitiveLog;
const ClusterServiceConnectDefaultsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ClusterServiceConnectDefaultsRequestFilterSensitiveLog = ClusterServiceConnectDefaultsRequestFilterSensitiveLog;
const ClusterSettingFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ClusterSettingFilterSensitiveLog = ClusterSettingFilterSensitiveLog;
const CreateClusterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateClusterRequestFilterSensitiveLog = CreateClusterRequestFilterSensitiveLog;
const KeyValuePairFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.KeyValuePairFilterSensitiveLog = KeyValuePairFilterSensitiveLog;
const AttachmentFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AttachmentFilterSensitiveLog = AttachmentFilterSensitiveLog;
const ClusterServiceConnectDefaultsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ClusterServiceConnectDefaultsFilterSensitiveLog = ClusterServiceConnectDefaultsFilterSensitiveLog;
const ClusterFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ClusterFilterSensitiveLog = ClusterFilterSensitiveLog;
const CreateClusterResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateClusterResponseFilterSensitiveLog = CreateClusterResponseFilterSensitiveLog;
const DeploymentAlarmsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentAlarmsFilterSensitiveLog = DeploymentAlarmsFilterSensitiveLog;
const DeploymentCircuitBreakerFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentCircuitBreakerFilterSensitiveLog = DeploymentCircuitBreakerFilterSensitiveLog;
const DeploymentConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentConfigurationFilterSensitiveLog = DeploymentConfigurationFilterSensitiveLog;
const DeploymentControllerFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentControllerFilterSensitiveLog = DeploymentControllerFilterSensitiveLog;
const LoadBalancerFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LoadBalancerFilterSensitiveLog = LoadBalancerFilterSensitiveLog;
const AwsVpcConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AwsVpcConfigurationFilterSensitiveLog = AwsVpcConfigurationFilterSensitiveLog;
const NetworkConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.NetworkConfigurationFilterSensitiveLog = NetworkConfigurationFilterSensitiveLog;
const PlacementConstraintFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PlacementConstraintFilterSensitiveLog = PlacementConstraintFilterSensitiveLog;
const PlacementStrategyFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PlacementStrategyFilterSensitiveLog = PlacementStrategyFilterSensitiveLog;
const SecretFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SecretFilterSensitiveLog = SecretFilterSensitiveLog;
const LogConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LogConfigurationFilterSensitiveLog = LogConfigurationFilterSensitiveLog;
const ServiceConnectClientAliasFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ServiceConnectClientAliasFilterSensitiveLog = ServiceConnectClientAliasFilterSensitiveLog;
const ServiceConnectServiceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ServiceConnectServiceFilterSensitiveLog = ServiceConnectServiceFilterSensitiveLog;
const ServiceConnectConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ServiceConnectConfigurationFilterSensitiveLog = ServiceConnectConfigurationFilterSensitiveLog;
const ServiceRegistryFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ServiceRegistryFilterSensitiveLog = ServiceRegistryFilterSensitiveLog;
const CreateServiceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateServiceRequestFilterSensitiveLog = CreateServiceRequestFilterSensitiveLog;
const ServiceConnectServiceResourceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ServiceConnectServiceResourceFilterSensitiveLog = ServiceConnectServiceResourceFilterSensitiveLog;
const DeploymentFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeploymentFilterSensitiveLog = DeploymentFilterSensitiveLog;
const ServiceEventFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ServiceEventFilterSensitiveLog = ServiceEventFilterSensitiveLog;
const ScaleFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ScaleFilterSensitiveLog = ScaleFilterSensitiveLog;
const TaskSetFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TaskSetFilterSensitiveLog = TaskSetFilterSensitiveLog;
const ServiceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ServiceFilterSensitiveLog = ServiceFilterSensitiveLog;
const CreateServiceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateServiceResponseFilterSensitiveLog = CreateServiceResponseFilterSensitiveLog;
const CreateTaskSetRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateTaskSetRequestFilterSensitiveLog = CreateTaskSetRequestFilterSensitiveLog;
const CreateTaskSetResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateTaskSetResponseFilterSensitiveLog = CreateTaskSetResponseFilterSensitiveLog;
const DeleteAccountSettingRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteAccountSettingRequestFilterSensitiveLog = DeleteAccountSettingRequestFilterSensitiveLog;
const SettingFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SettingFilterSensitiveLog = SettingFilterSensitiveLog;
const DeleteAccountSettingResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteAccountSettingResponseFilterSensitiveLog = DeleteAccountSettingResponseFilterSensitiveLog;
const AttributeFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AttributeFilterSensitiveLog = AttributeFilterSensitiveLog;
const DeleteAttributesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteAttributesRequestFilterSensitiveLog = DeleteAttributesRequestFilterSensitiveLog;
const DeleteAttributesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteAttributesResponseFilterSensitiveLog = DeleteAttributesResponseFilterSensitiveLog;
const DeleteCapacityProviderRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteCapacityProviderRequestFilterSensitiveLog = DeleteCapacityProviderRequestFilterSensitiveLog;
const DeleteCapacityProviderResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteCapacityProviderResponseFilterSensitiveLog = DeleteCapacityProviderResponseFilterSensitiveLog;
const DeleteClusterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteClusterRequestFilterSensitiveLog = DeleteClusterRequestFilterSensitiveLog;
const DeleteClusterResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteClusterResponseFilterSensitiveLog = DeleteClusterResponseFilterSensitiveLog;
const DeleteServiceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteServiceRequestFilterSensitiveLog = DeleteServiceRequestFilterSensitiveLog;
const DeleteServiceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteServiceResponseFilterSensitiveLog = DeleteServiceResponseFilterSensitiveLog;
const DeleteTaskSetRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteTaskSetRequestFilterSensitiveLog = DeleteTaskSetRequestFilterSensitiveLog;
const DeleteTaskSetResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeleteTaskSetResponseFilterSensitiveLog = DeleteTaskSetResponseFilterSensitiveLog;
const DeregisterContainerInstanceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeregisterContainerInstanceRequestFilterSensitiveLog = DeregisterContainerInstanceRequestFilterSensitiveLog;
const InstanceHealthCheckResultFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.InstanceHealthCheckResultFilterSensitiveLog = InstanceHealthCheckResultFilterSensitiveLog;
const ContainerInstanceHealthStatusFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContainerInstanceHealthStatusFilterSensitiveLog = ContainerInstanceHealthStatusFilterSensitiveLog;
const ResourceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ResourceFilterSensitiveLog = ResourceFilterSensitiveLog;
const VersionInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.VersionInfoFilterSensitiveLog = VersionInfoFilterSensitiveLog;
const ContainerInstanceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContainerInstanceFilterSensitiveLog = ContainerInstanceFilterSensitiveLog;
const DeregisterContainerInstanceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeregisterContainerInstanceResponseFilterSensitiveLog = DeregisterContainerInstanceResponseFilterSensitiveLog;
const DeregisterTaskDefinitionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeregisterTaskDefinitionRequestFilterSensitiveLog = DeregisterTaskDefinitionRequestFilterSensitiveLog;
const ContainerDependencyFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContainerDependencyFilterSensitiveLog = ContainerDependencyFilterSensitiveLog;
const EnvironmentFileFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.EnvironmentFileFilterSensitiveLog = EnvironmentFileFilterSensitiveLog;
const HostEntryFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.HostEntryFilterSensitiveLog = HostEntryFilterSensitiveLog;
const FirelensConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FirelensConfigurationFilterSensitiveLog = FirelensConfigurationFilterSensitiveLog;
const HealthCheckFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.HealthCheckFilterSensitiveLog = HealthCheckFilterSensitiveLog;
const KernelCapabilitiesFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.KernelCapabilitiesFilterSensitiveLog = KernelCapabilitiesFilterSensitiveLog;
const DeviceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeviceFilterSensitiveLog = DeviceFilterSensitiveLog;
const TmpfsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TmpfsFilterSensitiveLog = TmpfsFilterSensitiveLog;
const LinuxParametersFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.LinuxParametersFilterSensitiveLog = LinuxParametersFilterSensitiveLog;
const MountPointFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.MountPointFilterSensitiveLog = MountPointFilterSensitiveLog;
const PortMappingFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PortMappingFilterSensitiveLog = PortMappingFilterSensitiveLog;
const RepositoryCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RepositoryCredentialsFilterSensitiveLog = RepositoryCredentialsFilterSensitiveLog;
const ResourceRequirementFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ResourceRequirementFilterSensitiveLog = ResourceRequirementFilterSensitiveLog;
const SystemControlFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SystemControlFilterSensitiveLog = SystemControlFilterSensitiveLog;
const UlimitFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UlimitFilterSensitiveLog = UlimitFilterSensitiveLog;
const VolumeFromFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.VolumeFromFilterSensitiveLog = VolumeFromFilterSensitiveLog;
const ContainerDefinitionFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContainerDefinitionFilterSensitiveLog = ContainerDefinitionFilterSensitiveLog;
const EphemeralStorageFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.EphemeralStorageFilterSensitiveLog = EphemeralStorageFilterSensitiveLog;
const InferenceAcceleratorFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.InferenceAcceleratorFilterSensitiveLog = InferenceAcceleratorFilterSensitiveLog;
const TaskDefinitionPlacementConstraintFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TaskDefinitionPlacementConstraintFilterSensitiveLog = TaskDefinitionPlacementConstraintFilterSensitiveLog;
const ProxyConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ProxyConfigurationFilterSensitiveLog = ProxyConfigurationFilterSensitiveLog;
const RuntimePlatformFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RuntimePlatformFilterSensitiveLog = RuntimePlatformFilterSensitiveLog;
const DockerVolumeConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DockerVolumeConfigurationFilterSensitiveLog = DockerVolumeConfigurationFilterSensitiveLog;
const EFSAuthorizationConfigFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.EFSAuthorizationConfigFilterSensitiveLog = EFSAuthorizationConfigFilterSensitiveLog;
const EFSVolumeConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.EFSVolumeConfigurationFilterSensitiveLog = EFSVolumeConfigurationFilterSensitiveLog;
const FSxWindowsFileServerAuthorizationConfigFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FSxWindowsFileServerAuthorizationConfigFilterSensitiveLog = FSxWindowsFileServerAuthorizationConfigFilterSensitiveLog;
const FSxWindowsFileServerVolumeConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FSxWindowsFileServerVolumeConfigurationFilterSensitiveLog = FSxWindowsFileServerVolumeConfigurationFilterSensitiveLog;
const HostVolumePropertiesFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.HostVolumePropertiesFilterSensitiveLog = HostVolumePropertiesFilterSensitiveLog;
const VolumeFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.VolumeFilterSensitiveLog = VolumeFilterSensitiveLog;
const TaskDefinitionFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TaskDefinitionFilterSensitiveLog = TaskDefinitionFilterSensitiveLog;
const DeregisterTaskDefinitionResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DeregisterTaskDefinitionResponseFilterSensitiveLog = DeregisterTaskDefinitionResponseFilterSensitiveLog;
const DescribeCapacityProvidersRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeCapacityProvidersRequestFilterSensitiveLog = DescribeCapacityProvidersRequestFilterSensitiveLog;
const FailureFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FailureFilterSensitiveLog = FailureFilterSensitiveLog;
const DescribeCapacityProvidersResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeCapacityProvidersResponseFilterSensitiveLog = DescribeCapacityProvidersResponseFilterSensitiveLog;
const DescribeClustersRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeClustersRequestFilterSensitiveLog = DescribeClustersRequestFilterSensitiveLog;
const DescribeClustersResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeClustersResponseFilterSensitiveLog = DescribeClustersResponseFilterSensitiveLog;
const DescribeContainerInstancesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeContainerInstancesRequestFilterSensitiveLog = DescribeContainerInstancesRequestFilterSensitiveLog;
const DescribeContainerInstancesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeContainerInstancesResponseFilterSensitiveLog = DescribeContainerInstancesResponseFilterSensitiveLog;
const DescribeServicesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeServicesRequestFilterSensitiveLog = DescribeServicesRequestFilterSensitiveLog;
const DescribeServicesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeServicesResponseFilterSensitiveLog = DescribeServicesResponseFilterSensitiveLog;
const DescribeTaskDefinitionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeTaskDefinitionRequestFilterSensitiveLog = DescribeTaskDefinitionRequestFilterSensitiveLog;
const DescribeTaskDefinitionResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeTaskDefinitionResponseFilterSensitiveLog = DescribeTaskDefinitionResponseFilterSensitiveLog;
const DescribeTasksRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeTasksRequestFilterSensitiveLog = DescribeTasksRequestFilterSensitiveLog;
const ManagedAgentFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ManagedAgentFilterSensitiveLog = ManagedAgentFilterSensitiveLog;
const NetworkBindingFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.NetworkBindingFilterSensitiveLog = NetworkBindingFilterSensitiveLog;
const NetworkInterfaceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.NetworkInterfaceFilterSensitiveLog = NetworkInterfaceFilterSensitiveLog;
const ContainerFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContainerFilterSensitiveLog = ContainerFilterSensitiveLog;
const ContainerOverrideFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContainerOverrideFilterSensitiveLog = ContainerOverrideFilterSensitiveLog;
const InferenceAcceleratorOverrideFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.InferenceAcceleratorOverrideFilterSensitiveLog = InferenceAcceleratorOverrideFilterSensitiveLog;
const TaskOverrideFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TaskOverrideFilterSensitiveLog = TaskOverrideFilterSensitiveLog;
const TaskFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TaskFilterSensitiveLog = TaskFilterSensitiveLog;
const DescribeTasksResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeTasksResponseFilterSensitiveLog = DescribeTasksResponseFilterSensitiveLog;
const DescribeTaskSetsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeTaskSetsRequestFilterSensitiveLog = DescribeTaskSetsRequestFilterSensitiveLog;
const DescribeTaskSetsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DescribeTaskSetsResponseFilterSensitiveLog = DescribeTaskSetsResponseFilterSensitiveLog;
const DiscoverPollEndpointRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DiscoverPollEndpointRequestFilterSensitiveLog = DiscoverPollEndpointRequestFilterSensitiveLog;
const DiscoverPollEndpointResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DiscoverPollEndpointResponseFilterSensitiveLog = DiscoverPollEndpointResponseFilterSensitiveLog;
const ExecuteCommandRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ExecuteCommandRequestFilterSensitiveLog = ExecuteCommandRequestFilterSensitiveLog;
const SessionFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.tokenValue && { tokenValue: smithy_client_1.SENSITIVE_STRING }),
});
exports.SessionFilterSensitiveLog = SessionFilterSensitiveLog;
const ExecuteCommandResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.session && { session: (0, exports.SessionFilterSensitiveLog)(obj.session) }),
});
exports.ExecuteCommandResponseFilterSensitiveLog = ExecuteCommandResponseFilterSensitiveLog;
const GetTaskProtectionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetTaskProtectionRequestFilterSensitiveLog = GetTaskProtectionRequestFilterSensitiveLog;
const ProtectedTaskFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ProtectedTaskFilterSensitiveLog = ProtectedTaskFilterSensitiveLog;
const GetTaskProtectionResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetTaskProtectionResponseFilterSensitiveLog = GetTaskProtectionResponseFilterSensitiveLog;
const ListAccountSettingsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListAccountSettingsRequestFilterSensitiveLog = ListAccountSettingsRequestFilterSensitiveLog;
const ListAccountSettingsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListAccountSettingsResponseFilterSensitiveLog = ListAccountSettingsResponseFilterSensitiveLog;
const ListAttributesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListAttributesRequestFilterSensitiveLog = ListAttributesRequestFilterSensitiveLog;
const ListAttributesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListAttributesResponseFilterSensitiveLog = ListAttributesResponseFilterSensitiveLog;
const ListClustersRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListClustersRequestFilterSensitiveLog = ListClustersRequestFilterSensitiveLog;
const ListClustersResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListClustersResponseFilterSensitiveLog = ListClustersResponseFilterSensitiveLog;
const ListContainerInstancesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListContainerInstancesRequestFilterSensitiveLog = ListContainerInstancesRequestFilterSensitiveLog;
const ListContainerInstancesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListContainerInstancesResponseFilterSensitiveLog = ListContainerInstancesResponseFilterSensitiveLog;
const ListServicesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListServicesRequestFilterSensitiveLog = ListServicesRequestFilterSensitiveLog;
const ListServicesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListServicesResponseFilterSensitiveLog = ListServicesResponseFilterSensitiveLog;
const ListServicesByNamespaceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListServicesByNamespaceRequestFilterSensitiveLog = ListServicesByNamespaceRequestFilterSensitiveLog;
const ListServicesByNamespaceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListServicesByNamespaceResponseFilterSensitiveLog = ListServicesByNamespaceResponseFilterSensitiveLog;
const ListTagsForResourceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsForResourceRequestFilterSensitiveLog = ListTagsForResourceRequestFilterSensitiveLog;
const ListTagsForResourceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTagsForResourceResponseFilterSensitiveLog = ListTagsForResourceResponseFilterSensitiveLog;
const ListTaskDefinitionFamiliesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTaskDefinitionFamiliesRequestFilterSensitiveLog = ListTaskDefinitionFamiliesRequestFilterSensitiveLog;
const ListTaskDefinitionFamiliesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTaskDefinitionFamiliesResponseFilterSensitiveLog = ListTaskDefinitionFamiliesResponseFilterSensitiveLog;
const ListTaskDefinitionsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTaskDefinitionsRequestFilterSensitiveLog = ListTaskDefinitionsRequestFilterSensitiveLog;
const ListTaskDefinitionsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTaskDefinitionsResponseFilterSensitiveLog = ListTaskDefinitionsResponseFilterSensitiveLog;
const ListTasksRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTasksRequestFilterSensitiveLog = ListTasksRequestFilterSensitiveLog;
const ListTasksResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListTasksResponseFilterSensitiveLog = ListTasksResponseFilterSensitiveLog;
const PutAccountSettingRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutAccountSettingRequestFilterSensitiveLog = PutAccountSettingRequestFilterSensitiveLog;
const PutAccountSettingResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutAccountSettingResponseFilterSensitiveLog = PutAccountSettingResponseFilterSensitiveLog;
const PutAccountSettingDefaultRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutAccountSettingDefaultRequestFilterSensitiveLog = PutAccountSettingDefaultRequestFilterSensitiveLog;
const PutAccountSettingDefaultResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutAccountSettingDefaultResponseFilterSensitiveLog = PutAccountSettingDefaultResponseFilterSensitiveLog;
const PutAttributesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutAttributesRequestFilterSensitiveLog = PutAttributesRequestFilterSensitiveLog;
const PutAttributesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutAttributesResponseFilterSensitiveLog = PutAttributesResponseFilterSensitiveLog;
const PutClusterCapacityProvidersRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutClusterCapacityProvidersRequestFilterSensitiveLog = PutClusterCapacityProvidersRequestFilterSensitiveLog;
const PutClusterCapacityProvidersResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PutClusterCapacityProvidersResponseFilterSensitiveLog = PutClusterCapacityProvidersResponseFilterSensitiveLog;
const PlatformDeviceFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PlatformDeviceFilterSensitiveLog = PlatformDeviceFilterSensitiveLog;
const RegisterContainerInstanceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterContainerInstanceRequestFilterSensitiveLog = RegisterContainerInstanceRequestFilterSensitiveLog;
const RegisterContainerInstanceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterContainerInstanceResponseFilterSensitiveLog = RegisterContainerInstanceResponseFilterSensitiveLog;
const RegisterTaskDefinitionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterTaskDefinitionRequestFilterSensitiveLog = RegisterTaskDefinitionRequestFilterSensitiveLog;
const RegisterTaskDefinitionResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterTaskDefinitionResponseFilterSensitiveLog = RegisterTaskDefinitionResponseFilterSensitiveLog;
const RunTaskRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RunTaskRequestFilterSensitiveLog = RunTaskRequestFilterSensitiveLog;
const RunTaskResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RunTaskResponseFilterSensitiveLog = RunTaskResponseFilterSensitiveLog;
const StartTaskRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StartTaskRequestFilterSensitiveLog = StartTaskRequestFilterSensitiveLog;
const StartTaskResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StartTaskResponseFilterSensitiveLog = StartTaskResponseFilterSensitiveLog;
const StopTaskRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StopTaskRequestFilterSensitiveLog = StopTaskRequestFilterSensitiveLog;
const StopTaskResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StopTaskResponseFilterSensitiveLog = StopTaskResponseFilterSensitiveLog;
const AttachmentStateChangeFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AttachmentStateChangeFilterSensitiveLog = AttachmentStateChangeFilterSensitiveLog;
const SubmitAttachmentStateChangesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SubmitAttachmentStateChangesRequestFilterSensitiveLog = SubmitAttachmentStateChangesRequestFilterSensitiveLog;
const SubmitAttachmentStateChangesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SubmitAttachmentStateChangesResponseFilterSensitiveLog = SubmitAttachmentStateChangesResponseFilterSensitiveLog;
const SubmitContainerStateChangeRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SubmitContainerStateChangeRequestFilterSensitiveLog = SubmitContainerStateChangeRequestFilterSensitiveLog;
const SubmitContainerStateChangeResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SubmitContainerStateChangeResponseFilterSensitiveLog = SubmitContainerStateChangeResponseFilterSensitiveLog;
const ContainerStateChangeFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ContainerStateChangeFilterSensitiveLog = ContainerStateChangeFilterSensitiveLog;
const ManagedAgentStateChangeFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ManagedAgentStateChangeFilterSensitiveLog = ManagedAgentStateChangeFilterSensitiveLog;
const SubmitTaskStateChangeRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SubmitTaskStateChangeRequestFilterSensitiveLog = SubmitTaskStateChangeRequestFilterSensitiveLog;
const SubmitTaskStateChangeResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.SubmitTaskStateChangeResponseFilterSensitiveLog = SubmitTaskStateChangeResponseFilterSensitiveLog;
const TagResourceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagResourceRequestFilterSensitiveLog = TagResourceRequestFilterSensitiveLog;
const TagResourceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagResourceResponseFilterSensitiveLog = TagResourceResponseFilterSensitiveLog;
const UntagResourceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UntagResourceRequestFilterSensitiveLog = UntagResourceRequestFilterSensitiveLog;
const UntagResourceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UntagResourceResponseFilterSensitiveLog = UntagResourceResponseFilterSensitiveLog;
const AutoScalingGroupProviderUpdateFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AutoScalingGroupProviderUpdateFilterSensitiveLog = AutoScalingGroupProviderUpdateFilterSensitiveLog;
const UpdateCapacityProviderRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateCapacityProviderRequestFilterSensitiveLog = UpdateCapacityProviderRequestFilterSensitiveLog;
const UpdateCapacityProviderResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateCapacityProviderResponseFilterSensitiveLog = UpdateCapacityProviderResponseFilterSensitiveLog;
const UpdateClusterRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateClusterRequestFilterSensitiveLog = UpdateClusterRequestFilterSensitiveLog;
const UpdateClusterResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateClusterResponseFilterSensitiveLog = UpdateClusterResponseFilterSensitiveLog;
const UpdateClusterSettingsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateClusterSettingsRequestFilterSensitiveLog = UpdateClusterSettingsRequestFilterSensitiveLog;
const UpdateClusterSettingsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateClusterSettingsResponseFilterSensitiveLog = UpdateClusterSettingsResponseFilterSensitiveLog;
const UpdateContainerAgentRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateContainerAgentRequestFilterSensitiveLog = UpdateContainerAgentRequestFilterSensitiveLog;
const UpdateContainerAgentResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateContainerAgentResponseFilterSensitiveLog = UpdateContainerAgentResponseFilterSensitiveLog;
const UpdateContainerInstancesStateRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateContainerInstancesStateRequestFilterSensitiveLog = UpdateContainerInstancesStateRequestFilterSensitiveLog;
const UpdateContainerInstancesStateResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateContainerInstancesStateResponseFilterSensitiveLog = UpdateContainerInstancesStateResponseFilterSensitiveLog;
const UpdateServiceRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateServiceRequestFilterSensitiveLog = UpdateServiceRequestFilterSensitiveLog;
const UpdateServiceResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateServiceResponseFilterSensitiveLog = UpdateServiceResponseFilterSensitiveLog;
const UpdateServicePrimaryTaskSetRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateServicePrimaryTaskSetRequestFilterSensitiveLog = UpdateServicePrimaryTaskSetRequestFilterSensitiveLog;
const UpdateServicePrimaryTaskSetResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateServicePrimaryTaskSetResponseFilterSensitiveLog = UpdateServicePrimaryTaskSetResponseFilterSensitiveLog;
const UpdateTaskProtectionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateTaskProtectionRequestFilterSensitiveLog = UpdateTaskProtectionRequestFilterSensitiveLog;
const UpdateTaskProtectionResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateTaskProtectionResponseFilterSensitiveLog = UpdateTaskProtectionResponseFilterSensitiveLog;
const UpdateTaskSetRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateTaskSetRequestFilterSensitiveLog = UpdateTaskSetRequestFilterSensitiveLog;
const UpdateTaskSetResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.UpdateTaskSetResponseFilterSensitiveLog = UpdateTaskSetResponseFilterSensitiveLog;


/***/ }),

/***/ 1147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 92183:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccountSettings = void 0;
const ListAccountSettingsCommand_1 = __nccwpck_require__(89726);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAccountSettingsCommand_1.ListAccountSettingsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listAccountSettings(input, ...args);
};
async function* paginateListAccountSettings(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccountSettings = paginateListAccountSettings;


/***/ }),

/***/ 82008:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAttributes = void 0;
const ListAttributesCommand_1 = __nccwpck_require__(51415);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAttributesCommand_1.ListAttributesCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listAttributes(input, ...args);
};
async function* paginateListAttributes(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAttributes = paginateListAttributes;


/***/ }),

/***/ 54484:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListClusters = void 0;
const ListClustersCommand_1 = __nccwpck_require__(92960);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListClustersCommand_1.ListClustersCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listClusters(input, ...args);
};
async function* paginateListClusters(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListClusters = paginateListClusters;


/***/ }),

/***/ 44984:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListContainerInstances = void 0;
const ListContainerInstancesCommand_1 = __nccwpck_require__(85133);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListContainerInstancesCommand_1.ListContainerInstancesCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listContainerInstances(input, ...args);
};
async function* paginateListContainerInstances(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListContainerInstances = paginateListContainerInstances;


/***/ }),

/***/ 72409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListServicesByNamespace = void 0;
const ListServicesByNamespaceCommand_1 = __nccwpck_require__(2796);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListServicesByNamespaceCommand_1.ListServicesByNamespaceCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listServicesByNamespace(input, ...args);
};
async function* paginateListServicesByNamespace(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListServicesByNamespace = paginateListServicesByNamespace;


/***/ }),

/***/ 99383:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListServices = void 0;
const ListServicesCommand_1 = __nccwpck_require__(51752);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListServicesCommand_1.ListServicesCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listServices(input, ...args);
};
async function* paginateListServices(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListServices = paginateListServices;


/***/ }),

/***/ 93812:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListTaskDefinitionFamilies = void 0;
const ListTaskDefinitionFamiliesCommand_1 = __nccwpck_require__(62735);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListTaskDefinitionFamiliesCommand_1.ListTaskDefinitionFamiliesCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listTaskDefinitionFamilies(input, ...args);
};
async function* paginateListTaskDefinitionFamilies(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListTaskDefinitionFamilies = paginateListTaskDefinitionFamilies;


/***/ }),

/***/ 22161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListTaskDefinitions = void 0;
const ListTaskDefinitionsCommand_1 = __nccwpck_require__(27068);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListTaskDefinitionsCommand_1.ListTaskDefinitionsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listTaskDefinitions(input, ...args);
};
async function* paginateListTaskDefinitions(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListTaskDefinitions = paginateListTaskDefinitions;


/***/ }),

/***/ 52648:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListTasks = void 0;
const ListTasksCommand_1 = __nccwpck_require__(67517);
const ECS_1 = __nccwpck_require__(79074);
const ECSClient_1 = __nccwpck_require__(55714);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListTasksCommand_1.ListTasksCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listTasks(input, ...args);
};
async function* paginateListTasks(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof ECS_1.ECS) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof ECSClient_1.ECSClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected ECS | ECSClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListTasks = paginateListTasks;


/***/ }),

/***/ 84488:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(1147), exports);
tslib_1.__exportStar(__nccwpck_require__(92183), exports);
tslib_1.__exportStar(__nccwpck_require__(82008), exports);
tslib_1.__exportStar(__nccwpck_require__(54484), exports);
tslib_1.__exportStar(__nccwpck_require__(44984), exports);
tslib_1.__exportStar(__nccwpck_require__(72409), exports);
tslib_1.__exportStar(__nccwpck_require__(99383), exports);
tslib_1.__exportStar(__nccwpck_require__(93812), exports);
tslib_1.__exportStar(__nccwpck_require__(22161), exports);
tslib_1.__exportStar(__nccwpck_require__(52648), exports);


/***/ }),

/***/ 56556:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeAws_json1_1UpdateContainerAgentCommand = exports.serializeAws_json1_1UpdateClusterSettingsCommand = exports.serializeAws_json1_1UpdateClusterCommand = exports.serializeAws_json1_1UpdateCapacityProviderCommand = exports.serializeAws_json1_1UntagResourceCommand = exports.serializeAws_json1_1TagResourceCommand = exports.serializeAws_json1_1SubmitTaskStateChangeCommand = exports.serializeAws_json1_1SubmitContainerStateChangeCommand = exports.serializeAws_json1_1SubmitAttachmentStateChangesCommand = exports.serializeAws_json1_1StopTaskCommand = exports.serializeAws_json1_1StartTaskCommand = exports.serializeAws_json1_1RunTaskCommand = exports.serializeAws_json1_1RegisterTaskDefinitionCommand = exports.serializeAws_json1_1RegisterContainerInstanceCommand = exports.serializeAws_json1_1PutClusterCapacityProvidersCommand = exports.serializeAws_json1_1PutAttributesCommand = exports.serializeAws_json1_1PutAccountSettingDefaultCommand = exports.serializeAws_json1_1PutAccountSettingCommand = exports.serializeAws_json1_1ListTasksCommand = exports.serializeAws_json1_1ListTaskDefinitionsCommand = exports.serializeAws_json1_1ListTaskDefinitionFamiliesCommand = exports.serializeAws_json1_1ListTagsForResourceCommand = exports.serializeAws_json1_1ListServicesByNamespaceCommand = exports.serializeAws_json1_1ListServicesCommand = exports.serializeAws_json1_1ListContainerInstancesCommand = exports.serializeAws_json1_1ListClustersCommand = exports.serializeAws_json1_1ListAttributesCommand = exports.serializeAws_json1_1ListAccountSettingsCommand = exports.serializeAws_json1_1GetTaskProtectionCommand = exports.serializeAws_json1_1ExecuteCommandCommand = exports.serializeAws_json1_1DiscoverPollEndpointCommand = exports.serializeAws_json1_1DescribeTaskSetsCommand = exports.serializeAws_json1_1DescribeTasksCommand = exports.serializeAws_json1_1DescribeTaskDefinitionCommand = exports.serializeAws_json1_1DescribeServicesCommand = exports.serializeAws_json1_1DescribeContainerInstancesCommand = exports.serializeAws_json1_1DescribeClustersCommand = exports.serializeAws_json1_1DescribeCapacityProvidersCommand = exports.serializeAws_json1_1DeregisterTaskDefinitionCommand = exports.serializeAws_json1_1DeregisterContainerInstanceCommand = exports.serializeAws_json1_1DeleteTaskSetCommand = exports.serializeAws_json1_1DeleteServiceCommand = exports.serializeAws_json1_1DeleteClusterCommand = exports.serializeAws_json1_1DeleteCapacityProviderCommand = exports.serializeAws_json1_1DeleteAttributesCommand = exports.serializeAws_json1_1DeleteAccountSettingCommand = exports.serializeAws_json1_1CreateTaskSetCommand = exports.serializeAws_json1_1CreateServiceCommand = exports.serializeAws_json1_1CreateClusterCommand = exports.serializeAws_json1_1CreateCapacityProviderCommand = void 0;
exports.deserializeAws_json1_1TagResourceCommand = exports.deserializeAws_json1_1SubmitTaskStateChangeCommand = exports.deserializeAws_json1_1SubmitContainerStateChangeCommand = exports.deserializeAws_json1_1SubmitAttachmentStateChangesCommand = exports.deserializeAws_json1_1StopTaskCommand = exports.deserializeAws_json1_1StartTaskCommand = exports.deserializeAws_json1_1RunTaskCommand = exports.deserializeAws_json1_1RegisterTaskDefinitionCommand = exports.deserializeAws_json1_1RegisterContainerInstanceCommand = exports.deserializeAws_json1_1PutClusterCapacityProvidersCommand = exports.deserializeAws_json1_1PutAttributesCommand = exports.deserializeAws_json1_1PutAccountSettingDefaultCommand = exports.deserializeAws_json1_1PutAccountSettingCommand = exports.deserializeAws_json1_1ListTasksCommand = exports.deserializeAws_json1_1ListTaskDefinitionsCommand = exports.deserializeAws_json1_1ListTaskDefinitionFamiliesCommand = exports.deserializeAws_json1_1ListTagsForResourceCommand = exports.deserializeAws_json1_1ListServicesByNamespaceCommand = exports.deserializeAws_json1_1ListServicesCommand = exports.deserializeAws_json1_1ListContainerInstancesCommand = exports.deserializeAws_json1_1ListClustersCommand = exports.deserializeAws_json1_1ListAttributesCommand = exports.deserializeAws_json1_1ListAccountSettingsCommand = exports.deserializeAws_json1_1GetTaskProtectionCommand = exports.deserializeAws_json1_1ExecuteCommandCommand = exports.deserializeAws_json1_1DiscoverPollEndpointCommand = exports.deserializeAws_json1_1DescribeTaskSetsCommand = exports.deserializeAws_json1_1DescribeTasksCommand = exports.deserializeAws_json1_1DescribeTaskDefinitionCommand = exports.deserializeAws_json1_1DescribeServicesCommand = exports.deserializeAws_json1_1DescribeContainerInstancesCommand = exports.deserializeAws_json1_1DescribeClustersCommand = exports.deserializeAws_json1_1DescribeCapacityProvidersCommand = exports.deserializeAws_json1_1DeregisterTaskDefinitionCommand = exports.deserializeAws_json1_1DeregisterContainerInstanceCommand = exports.deserializeAws_json1_1DeleteTaskSetCommand = exports.deserializeAws_json1_1DeleteServiceCommand = exports.deserializeAws_json1_1DeleteClusterCommand = exports.deserializeAws_json1_1DeleteCapacityProviderCommand = exports.deserializeAws_json1_1DeleteAttributesCommand = exports.deserializeAws_json1_1DeleteAccountSettingCommand = exports.deserializeAws_json1_1CreateTaskSetCommand = exports.deserializeAws_json1_1CreateServiceCommand = exports.deserializeAws_json1_1CreateClusterCommand = exports.deserializeAws_json1_1CreateCapacityProviderCommand = exports.serializeAws_json1_1UpdateTaskSetCommand = exports.serializeAws_json1_1UpdateTaskProtectionCommand = exports.serializeAws_json1_1UpdateServicePrimaryTaskSetCommand = exports.serializeAws_json1_1UpdateServiceCommand = exports.serializeAws_json1_1UpdateContainerInstancesStateCommand = void 0;
exports.deserializeAws_json1_1UpdateTaskSetCommand = exports.deserializeAws_json1_1UpdateTaskProtectionCommand = exports.deserializeAws_json1_1UpdateServicePrimaryTaskSetCommand = exports.deserializeAws_json1_1UpdateServiceCommand = exports.deserializeAws_json1_1UpdateContainerInstancesStateCommand = exports.deserializeAws_json1_1UpdateContainerAgentCommand = exports.deserializeAws_json1_1UpdateClusterSettingsCommand = exports.deserializeAws_json1_1UpdateClusterCommand = exports.deserializeAws_json1_1UpdateCapacityProviderCommand = exports.deserializeAws_json1_1UntagResourceCommand = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const smithy_client_1 = __nccwpck_require__(4963);
const ECSServiceException_1 = __nccwpck_require__(47688);
const models_0_1 = __nccwpck_require__(89402);
const serializeAws_json1_1CreateCapacityProviderCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.CreateCapacityProvider",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateCapacityProviderRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateCapacityProviderCommand = serializeAws_json1_1CreateCapacityProviderCommand;
const serializeAws_json1_1CreateClusterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.CreateCluster",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateClusterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateClusterCommand = serializeAws_json1_1CreateClusterCommand;
const serializeAws_json1_1CreateServiceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.CreateService",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateServiceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateServiceCommand = serializeAws_json1_1CreateServiceCommand;
const serializeAws_json1_1CreateTaskSetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.CreateTaskSet",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateTaskSetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1CreateTaskSetCommand = serializeAws_json1_1CreateTaskSetCommand;
const serializeAws_json1_1DeleteAccountSettingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeleteAccountSetting",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteAccountSettingRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteAccountSettingCommand = serializeAws_json1_1DeleteAccountSettingCommand;
const serializeAws_json1_1DeleteAttributesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeleteAttributes",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteAttributesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteAttributesCommand = serializeAws_json1_1DeleteAttributesCommand;
const serializeAws_json1_1DeleteCapacityProviderCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeleteCapacityProvider",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteCapacityProviderRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteCapacityProviderCommand = serializeAws_json1_1DeleteCapacityProviderCommand;
const serializeAws_json1_1DeleteClusterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeleteCluster",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteClusterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteClusterCommand = serializeAws_json1_1DeleteClusterCommand;
const serializeAws_json1_1DeleteServiceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeleteService",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteServiceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteServiceCommand = serializeAws_json1_1DeleteServiceCommand;
const serializeAws_json1_1DeleteTaskSetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeleteTaskSet",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteTaskSetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeleteTaskSetCommand = serializeAws_json1_1DeleteTaskSetCommand;
const serializeAws_json1_1DeregisterContainerInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeregisterContainerInstance",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeregisterContainerInstanceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeregisterContainerInstanceCommand = serializeAws_json1_1DeregisterContainerInstanceCommand;
const serializeAws_json1_1DeregisterTaskDefinitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DeregisterTaskDefinition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeregisterTaskDefinitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DeregisterTaskDefinitionCommand = serializeAws_json1_1DeregisterTaskDefinitionCommand;
const serializeAws_json1_1DescribeCapacityProvidersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DescribeCapacityProviders",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeCapacityProvidersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeCapacityProvidersCommand = serializeAws_json1_1DescribeCapacityProvidersCommand;
const serializeAws_json1_1DescribeClustersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DescribeClusters",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeClustersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeClustersCommand = serializeAws_json1_1DescribeClustersCommand;
const serializeAws_json1_1DescribeContainerInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DescribeContainerInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeContainerInstancesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeContainerInstancesCommand = serializeAws_json1_1DescribeContainerInstancesCommand;
const serializeAws_json1_1DescribeServicesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DescribeServices",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeServicesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeServicesCommand = serializeAws_json1_1DescribeServicesCommand;
const serializeAws_json1_1DescribeTaskDefinitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DescribeTaskDefinition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeTaskDefinitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeTaskDefinitionCommand = serializeAws_json1_1DescribeTaskDefinitionCommand;
const serializeAws_json1_1DescribeTasksCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DescribeTasks",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeTasksRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeTasksCommand = serializeAws_json1_1DescribeTasksCommand;
const serializeAws_json1_1DescribeTaskSetsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DescribeTaskSets",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeTaskSetsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DescribeTaskSetsCommand = serializeAws_json1_1DescribeTaskSetsCommand;
const serializeAws_json1_1DiscoverPollEndpointCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.DiscoverPollEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DiscoverPollEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1DiscoverPollEndpointCommand = serializeAws_json1_1DiscoverPollEndpointCommand;
const serializeAws_json1_1ExecuteCommandCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ExecuteCommand",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ExecuteCommandRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ExecuteCommandCommand = serializeAws_json1_1ExecuteCommandCommand;
const serializeAws_json1_1GetTaskProtectionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.GetTaskProtection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTaskProtectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1GetTaskProtectionCommand = serializeAws_json1_1GetTaskProtectionCommand;
const serializeAws_json1_1ListAccountSettingsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListAccountSettings",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListAccountSettingsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListAccountSettingsCommand = serializeAws_json1_1ListAccountSettingsCommand;
const serializeAws_json1_1ListAttributesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListAttributes",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListAttributesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListAttributesCommand = serializeAws_json1_1ListAttributesCommand;
const serializeAws_json1_1ListClustersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListClusters",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListClustersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListClustersCommand = serializeAws_json1_1ListClustersCommand;
const serializeAws_json1_1ListContainerInstancesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListContainerInstances",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListContainerInstancesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListContainerInstancesCommand = serializeAws_json1_1ListContainerInstancesCommand;
const serializeAws_json1_1ListServicesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListServices",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListServicesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListServicesCommand = serializeAws_json1_1ListServicesCommand;
const serializeAws_json1_1ListServicesByNamespaceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListServicesByNamespace",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListServicesByNamespaceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListServicesByNamespaceCommand = serializeAws_json1_1ListServicesByNamespaceCommand;
const serializeAws_json1_1ListTagsForResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListTagsForResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTagsForResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTagsForResourceCommand = serializeAws_json1_1ListTagsForResourceCommand;
const serializeAws_json1_1ListTaskDefinitionFamiliesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListTaskDefinitionFamilies",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTaskDefinitionFamiliesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTaskDefinitionFamiliesCommand = serializeAws_json1_1ListTaskDefinitionFamiliesCommand;
const serializeAws_json1_1ListTaskDefinitionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListTaskDefinitions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTaskDefinitionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTaskDefinitionsCommand = serializeAws_json1_1ListTaskDefinitionsCommand;
const serializeAws_json1_1ListTasksCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.ListTasks",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTasksRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1ListTasksCommand = serializeAws_json1_1ListTasksCommand;
const serializeAws_json1_1PutAccountSettingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.PutAccountSetting",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutAccountSettingRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutAccountSettingCommand = serializeAws_json1_1PutAccountSettingCommand;
const serializeAws_json1_1PutAccountSettingDefaultCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.PutAccountSettingDefault",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutAccountSettingDefaultRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutAccountSettingDefaultCommand = serializeAws_json1_1PutAccountSettingDefaultCommand;
const serializeAws_json1_1PutAttributesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.PutAttributes",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutAttributesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutAttributesCommand = serializeAws_json1_1PutAttributesCommand;
const serializeAws_json1_1PutClusterCapacityProvidersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.PutClusterCapacityProviders",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutClusterCapacityProvidersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1PutClusterCapacityProvidersCommand = serializeAws_json1_1PutClusterCapacityProvidersCommand;
const serializeAws_json1_1RegisterContainerInstanceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.RegisterContainerInstance",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RegisterContainerInstanceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1RegisterContainerInstanceCommand = serializeAws_json1_1RegisterContainerInstanceCommand;
const serializeAws_json1_1RegisterTaskDefinitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.RegisterTaskDefinition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RegisterTaskDefinitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1RegisterTaskDefinitionCommand = serializeAws_json1_1RegisterTaskDefinitionCommand;
const serializeAws_json1_1RunTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.RunTask",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RunTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1RunTaskCommand = serializeAws_json1_1RunTaskCommand;
const serializeAws_json1_1StartTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.StartTask",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StartTaskCommand = serializeAws_json1_1StartTaskCommand;
const serializeAws_json1_1StopTaskCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.StopTask",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1StopTaskCommand = serializeAws_json1_1StopTaskCommand;
const serializeAws_json1_1SubmitAttachmentStateChangesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.SubmitAttachmentStateChanges",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1SubmitAttachmentStateChangesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1SubmitAttachmentStateChangesCommand = serializeAws_json1_1SubmitAttachmentStateChangesCommand;
const serializeAws_json1_1SubmitContainerStateChangeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.SubmitContainerStateChange",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1SubmitContainerStateChangeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1SubmitContainerStateChangeCommand = serializeAws_json1_1SubmitContainerStateChangeCommand;
const serializeAws_json1_1SubmitTaskStateChangeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.SubmitTaskStateChange",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1SubmitTaskStateChangeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1SubmitTaskStateChangeCommand = serializeAws_json1_1SubmitTaskStateChangeCommand;
const serializeAws_json1_1TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1TagResourceCommand = serializeAws_json1_1TagResourceCommand;
const serializeAws_json1_1UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UntagResourceCommand = serializeAws_json1_1UntagResourceCommand;
const serializeAws_json1_1UpdateCapacityProviderCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateCapacityProvider",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateCapacityProviderRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateCapacityProviderCommand = serializeAws_json1_1UpdateCapacityProviderCommand;
const serializeAws_json1_1UpdateClusterCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateCluster",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateClusterRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateClusterCommand = serializeAws_json1_1UpdateClusterCommand;
const serializeAws_json1_1UpdateClusterSettingsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateClusterSettings",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateClusterSettingsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateClusterSettingsCommand = serializeAws_json1_1UpdateClusterSettingsCommand;
const serializeAws_json1_1UpdateContainerAgentCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateContainerAgent",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateContainerAgentRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateContainerAgentCommand = serializeAws_json1_1UpdateContainerAgentCommand;
const serializeAws_json1_1UpdateContainerInstancesStateCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateContainerInstancesState",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateContainerInstancesStateRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateContainerInstancesStateCommand = serializeAws_json1_1UpdateContainerInstancesStateCommand;
const serializeAws_json1_1UpdateServiceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateService",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateServiceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateServiceCommand = serializeAws_json1_1UpdateServiceCommand;
const serializeAws_json1_1UpdateServicePrimaryTaskSetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateServicePrimaryTaskSet",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateServicePrimaryTaskSetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateServicePrimaryTaskSetCommand = serializeAws_json1_1UpdateServicePrimaryTaskSetCommand;
const serializeAws_json1_1UpdateTaskProtectionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateTaskProtection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateTaskProtectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateTaskProtectionCommand = serializeAws_json1_1UpdateTaskProtectionCommand;
const serializeAws_json1_1UpdateTaskSetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AmazonEC2ContainerServiceV20141113.UpdateTaskSet",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateTaskSetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_json1_1UpdateTaskSetCommand = serializeAws_json1_1UpdateTaskSetCommand;
const deserializeAws_json1_1CreateCapacityProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateCapacityProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateCapacityProviderResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateCapacityProviderCommand = deserializeAws_json1_1CreateCapacityProviderCommand;
const deserializeAws_json1_1CreateCapacityProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.ecs#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UpdateInProgressException":
        case "com.amazonaws.ecs#UpdateInProgressException":
            throw await deserializeAws_json1_1UpdateInProgressExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateClusterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateClusterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateClusterCommand = deserializeAws_json1_1CreateClusterCommand;
const deserializeAws_json1_1CreateClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateServiceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateServiceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateServiceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateServiceCommand = deserializeAws_json1_1CreateServiceCommand;
const deserializeAws_json1_1CreateServiceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "NamespaceNotFoundException":
        case "com.amazonaws.ecs#NamespaceNotFoundException":
            throw await deserializeAws_json1_1NamespaceNotFoundExceptionResponse(parsedOutput, context);
        case "PlatformTaskDefinitionIncompatibilityException":
        case "com.amazonaws.ecs#PlatformTaskDefinitionIncompatibilityException":
            throw await deserializeAws_json1_1PlatformTaskDefinitionIncompatibilityExceptionResponse(parsedOutput, context);
        case "PlatformUnknownException":
        case "com.amazonaws.ecs#PlatformUnknownException":
            throw await deserializeAws_json1_1PlatformUnknownExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1CreateTaskSetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateTaskSetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateTaskSetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1CreateTaskSetCommand = deserializeAws_json1_1CreateTaskSetCommand;
const deserializeAws_json1_1CreateTaskSetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "NamespaceNotFoundException":
        case "com.amazonaws.ecs#NamespaceNotFoundException":
            throw await deserializeAws_json1_1NamespaceNotFoundExceptionResponse(parsedOutput, context);
        case "PlatformTaskDefinitionIncompatibilityException":
        case "com.amazonaws.ecs#PlatformTaskDefinitionIncompatibilityException":
            throw await deserializeAws_json1_1PlatformTaskDefinitionIncompatibilityExceptionResponse(parsedOutput, context);
        case "PlatformUnknownException":
        case "com.amazonaws.ecs#PlatformUnknownException":
            throw await deserializeAws_json1_1PlatformUnknownExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotActiveException":
        case "com.amazonaws.ecs#ServiceNotActiveException":
            throw await deserializeAws_json1_1ServiceNotActiveExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteAccountSettingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteAccountSettingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteAccountSettingResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteAccountSettingCommand = deserializeAws_json1_1DeleteAccountSettingCommand;
const deserializeAws_json1_1DeleteAccountSettingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteAttributesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteAttributesCommand = deserializeAws_json1_1DeleteAttributesCommand;
const deserializeAws_json1_1DeleteAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "TargetNotFoundException":
        case "com.amazonaws.ecs#TargetNotFoundException":
            throw await deserializeAws_json1_1TargetNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteCapacityProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteCapacityProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteCapacityProviderResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteCapacityProviderCommand = deserializeAws_json1_1DeleteCapacityProviderCommand;
const deserializeAws_json1_1DeleteCapacityProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteClusterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteClusterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteClusterCommand = deserializeAws_json1_1DeleteClusterCommand;
const deserializeAws_json1_1DeleteClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterContainsContainerInstancesException":
        case "com.amazonaws.ecs#ClusterContainsContainerInstancesException":
            throw await deserializeAws_json1_1ClusterContainsContainerInstancesExceptionResponse(parsedOutput, context);
        case "ClusterContainsServicesException":
        case "com.amazonaws.ecs#ClusterContainsServicesException":
            throw await deserializeAws_json1_1ClusterContainsServicesExceptionResponse(parsedOutput, context);
        case "ClusterContainsTasksException":
        case "com.amazonaws.ecs#ClusterContainsTasksException":
            throw await deserializeAws_json1_1ClusterContainsTasksExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UpdateInProgressException":
        case "com.amazonaws.ecs#UpdateInProgressException":
            throw await deserializeAws_json1_1UpdateInProgressExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteServiceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteServiceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteServiceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteServiceCommand = deserializeAws_json1_1DeleteServiceCommand;
const deserializeAws_json1_1DeleteServiceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeleteTaskSetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteTaskSetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteTaskSetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeleteTaskSetCommand = deserializeAws_json1_1DeleteTaskSetCommand;
const deserializeAws_json1_1DeleteTaskSetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotActiveException":
        case "com.amazonaws.ecs#ServiceNotActiveException":
            throw await deserializeAws_json1_1ServiceNotActiveExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        case "TaskSetNotFoundException":
        case "com.amazonaws.ecs#TaskSetNotFoundException":
            throw await deserializeAws_json1_1TaskSetNotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeregisterContainerInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeregisterContainerInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeregisterContainerInstanceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeregisterContainerInstanceCommand = deserializeAws_json1_1DeregisterContainerInstanceCommand;
const deserializeAws_json1_1DeregisterContainerInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DeregisterTaskDefinitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeregisterTaskDefinitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeregisterTaskDefinitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DeregisterTaskDefinitionCommand = deserializeAws_json1_1DeregisterTaskDefinitionCommand;
const deserializeAws_json1_1DeregisterTaskDefinitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeCapacityProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeCapacityProvidersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeCapacityProvidersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeCapacityProvidersCommand = deserializeAws_json1_1DescribeCapacityProvidersCommand;
const deserializeAws_json1_1DescribeCapacityProvidersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeClustersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeClustersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeClustersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeClustersCommand = deserializeAws_json1_1DescribeClustersCommand;
const deserializeAws_json1_1DescribeClustersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeContainerInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeContainerInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeContainerInstancesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeContainerInstancesCommand = deserializeAws_json1_1DescribeContainerInstancesCommand;
const deserializeAws_json1_1DescribeContainerInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeServicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeServicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeServicesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeServicesCommand = deserializeAws_json1_1DescribeServicesCommand;
const deserializeAws_json1_1DescribeServicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeTaskDefinitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeTaskDefinitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeTaskDefinitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeTaskDefinitionCommand = deserializeAws_json1_1DescribeTaskDefinitionCommand;
const deserializeAws_json1_1DescribeTaskDefinitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeTasksResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeTasksCommand = deserializeAws_json1_1DescribeTasksCommand;
const deserializeAws_json1_1DescribeTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DescribeTaskSetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeTaskSetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeTaskSetsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DescribeTaskSetsCommand = deserializeAws_json1_1DescribeTaskSetsCommand;
const deserializeAws_json1_1DescribeTaskSetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotActiveException":
        case "com.amazonaws.ecs#ServiceNotActiveException":
            throw await deserializeAws_json1_1ServiceNotActiveExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1DiscoverPollEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DiscoverPollEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DiscoverPollEndpointResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1DiscoverPollEndpointCommand = deserializeAws_json1_1DiscoverPollEndpointCommand;
const deserializeAws_json1_1DiscoverPollEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ExecuteCommandCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ExecuteCommandCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ExecuteCommandResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ExecuteCommandCommand = deserializeAws_json1_1ExecuteCommandCommand;
const deserializeAws_json1_1ExecuteCommandCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "TargetNotConnectedException":
        case "com.amazonaws.ecs#TargetNotConnectedException":
            throw await deserializeAws_json1_1TargetNotConnectedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1GetTaskProtectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTaskProtectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTaskProtectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1GetTaskProtectionCommand = deserializeAws_json1_1GetTaskProtectionCommand;
const deserializeAws_json1_1GetTaskProtectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.ecs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListAccountSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListAccountSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListAccountSettingsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListAccountSettingsCommand = deserializeAws_json1_1ListAccountSettingsCommand;
const deserializeAws_json1_1ListAccountSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListAttributesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListAttributesCommand = deserializeAws_json1_1ListAttributesCommand;
const deserializeAws_json1_1ListAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListClustersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListClustersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListClustersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListClustersCommand = deserializeAws_json1_1ListClustersCommand;
const deserializeAws_json1_1ListClustersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListContainerInstancesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListContainerInstancesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListContainerInstancesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListContainerInstancesCommand = deserializeAws_json1_1ListContainerInstancesCommand;
const deserializeAws_json1_1ListContainerInstancesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListServicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListServicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListServicesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListServicesCommand = deserializeAws_json1_1ListServicesCommand;
const deserializeAws_json1_1ListServicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListServicesByNamespaceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListServicesByNamespaceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListServicesByNamespaceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListServicesByNamespaceCommand = deserializeAws_json1_1ListServicesByNamespaceCommand;
const deserializeAws_json1_1ListServicesByNamespaceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "NamespaceNotFoundException":
        case "com.amazonaws.ecs#NamespaceNotFoundException":
            throw await deserializeAws_json1_1NamespaceNotFoundExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTagsForResourceCommand = deserializeAws_json1_1ListTagsForResourceCommand;
const deserializeAws_json1_1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListTaskDefinitionFamiliesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTaskDefinitionFamiliesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTaskDefinitionFamiliesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTaskDefinitionFamiliesCommand = deserializeAws_json1_1ListTaskDefinitionFamiliesCommand;
const deserializeAws_json1_1ListTaskDefinitionFamiliesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListTaskDefinitionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTaskDefinitionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTaskDefinitionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTaskDefinitionsCommand = deserializeAws_json1_1ListTaskDefinitionsCommand;
const deserializeAws_json1_1ListTaskDefinitionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1ListTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTasksCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTasksResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1ListTasksCommand = deserializeAws_json1_1ListTasksCommand;
const deserializeAws_json1_1ListTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutAccountSettingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutAccountSettingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutAccountSettingResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutAccountSettingCommand = deserializeAws_json1_1PutAccountSettingCommand;
const deserializeAws_json1_1PutAccountSettingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutAccountSettingDefaultCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutAccountSettingDefaultCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutAccountSettingDefaultResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutAccountSettingDefaultCommand = deserializeAws_json1_1PutAccountSettingDefaultCommand;
const deserializeAws_json1_1PutAccountSettingDefaultCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutAttributesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutAttributesCommand = deserializeAws_json1_1PutAttributesCommand;
const deserializeAws_json1_1PutAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AttributeLimitExceededException":
        case "com.amazonaws.ecs#AttributeLimitExceededException":
            throw await deserializeAws_json1_1AttributeLimitExceededExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "TargetNotFoundException":
        case "com.amazonaws.ecs#TargetNotFoundException":
            throw await deserializeAws_json1_1TargetNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1PutClusterCapacityProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutClusterCapacityProvidersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutClusterCapacityProvidersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1PutClusterCapacityProvidersCommand = deserializeAws_json1_1PutClusterCapacityProvidersCommand;
const deserializeAws_json1_1PutClusterCapacityProvidersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceInUseException":
        case "com.amazonaws.ecs#ResourceInUseException":
            throw await deserializeAws_json1_1ResourceInUseExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UpdateInProgressException":
        case "com.amazonaws.ecs#UpdateInProgressException":
            throw await deserializeAws_json1_1UpdateInProgressExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1RegisterContainerInstanceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RegisterContainerInstanceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1RegisterContainerInstanceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1RegisterContainerInstanceCommand = deserializeAws_json1_1RegisterContainerInstanceCommand;
const deserializeAws_json1_1RegisterContainerInstanceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1RegisterTaskDefinitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RegisterTaskDefinitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1RegisterTaskDefinitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1RegisterTaskDefinitionCommand = deserializeAws_json1_1RegisterTaskDefinitionCommand;
const deserializeAws_json1_1RegisterTaskDefinitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1RunTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RunTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1RunTaskResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1RunTaskCommand = deserializeAws_json1_1RunTaskCommand;
const deserializeAws_json1_1RunTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "BlockedException":
        case "com.amazonaws.ecs#BlockedException":
            throw await deserializeAws_json1_1BlockedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "PlatformTaskDefinitionIncompatibilityException":
        case "com.amazonaws.ecs#PlatformTaskDefinitionIncompatibilityException":
            throw await deserializeAws_json1_1PlatformTaskDefinitionIncompatibilityExceptionResponse(parsedOutput, context);
        case "PlatformUnknownException":
        case "com.amazonaws.ecs#PlatformUnknownException":
            throw await deserializeAws_json1_1PlatformUnknownExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1StartTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartTaskResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StartTaskCommand = deserializeAws_json1_1StartTaskCommand;
const deserializeAws_json1_1StartTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1StopTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopTaskCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopTaskResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1StopTaskCommand = deserializeAws_json1_1StopTaskCommand;
const deserializeAws_json1_1StopTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1SubmitAttachmentStateChangesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1SubmitAttachmentStateChangesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1SubmitAttachmentStateChangesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1SubmitAttachmentStateChangesCommand = deserializeAws_json1_1SubmitAttachmentStateChangesCommand;
const deserializeAws_json1_1SubmitAttachmentStateChangesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1SubmitContainerStateChangeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1SubmitContainerStateChangeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1SubmitContainerStateChangeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1SubmitContainerStateChangeCommand = deserializeAws_json1_1SubmitContainerStateChangeCommand;
const deserializeAws_json1_1SubmitContainerStateChangeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1SubmitTaskStateChangeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1SubmitTaskStateChangeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1SubmitTaskStateChangeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1SubmitTaskStateChangeCommand = deserializeAws_json1_1SubmitTaskStateChangeCommand;
const deserializeAws_json1_1SubmitTaskStateChangeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1TagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1TagResourceCommand = deserializeAws_json1_1TagResourceCommand;
const deserializeAws_json1_1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.ecs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UntagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UntagResourceCommand = deserializeAws_json1_1UntagResourceCommand;
const deserializeAws_json1_1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.ecs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateCapacityProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateCapacityProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateCapacityProviderResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateCapacityProviderCommand = deserializeAws_json1_1UpdateCapacityProviderCommand;
const deserializeAws_json1_1UpdateCapacityProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateClusterCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateClusterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateClusterCommand = deserializeAws_json1_1UpdateClusterCommand;
const deserializeAws_json1_1UpdateClusterCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateClusterSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateClusterSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateClusterSettingsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateClusterSettingsCommand = deserializeAws_json1_1UpdateClusterSettingsCommand;
const deserializeAws_json1_1UpdateClusterSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateContainerAgentCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateContainerAgentCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateContainerAgentResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateContainerAgentCommand = deserializeAws_json1_1UpdateContainerAgentCommand;
const deserializeAws_json1_1UpdateContainerAgentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "MissingVersionException":
        case "com.amazonaws.ecs#MissingVersionException":
            throw await deserializeAws_json1_1MissingVersionExceptionResponse(parsedOutput, context);
        case "NoUpdateAvailableException":
        case "com.amazonaws.ecs#NoUpdateAvailableException":
            throw await deserializeAws_json1_1NoUpdateAvailableExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UpdateInProgressException":
        case "com.amazonaws.ecs#UpdateInProgressException":
            throw await deserializeAws_json1_1UpdateInProgressExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateContainerInstancesStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateContainerInstancesStateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateContainerInstancesStateResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateContainerInstancesStateCommand = deserializeAws_json1_1UpdateContainerInstancesStateCommand;
const deserializeAws_json1_1UpdateContainerInstancesStateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateServiceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateServiceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateServiceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateServiceCommand = deserializeAws_json1_1UpdateServiceCommand;
const deserializeAws_json1_1UpdateServiceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "NamespaceNotFoundException":
        case "com.amazonaws.ecs#NamespaceNotFoundException":
            throw await deserializeAws_json1_1NamespaceNotFoundExceptionResponse(parsedOutput, context);
        case "PlatformTaskDefinitionIncompatibilityException":
        case "com.amazonaws.ecs#PlatformTaskDefinitionIncompatibilityException":
            throw await deserializeAws_json1_1PlatformTaskDefinitionIncompatibilityExceptionResponse(parsedOutput, context);
        case "PlatformUnknownException":
        case "com.amazonaws.ecs#PlatformUnknownException":
            throw await deserializeAws_json1_1PlatformUnknownExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotActiveException":
        case "com.amazonaws.ecs#ServiceNotActiveException":
            throw await deserializeAws_json1_1ServiceNotActiveExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateServicePrimaryTaskSetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateServicePrimaryTaskSetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateServicePrimaryTaskSetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateServicePrimaryTaskSetCommand = deserializeAws_json1_1UpdateServicePrimaryTaskSetCommand;
const deserializeAws_json1_1UpdateServicePrimaryTaskSetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotActiveException":
        case "com.amazonaws.ecs#ServiceNotActiveException":
            throw await deserializeAws_json1_1ServiceNotActiveExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        case "TaskSetNotFoundException":
        case "com.amazonaws.ecs#TaskSetNotFoundException":
            throw await deserializeAws_json1_1TaskSetNotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateTaskProtectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateTaskProtectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateTaskProtectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateTaskProtectionCommand = deserializeAws_json1_1UpdateTaskProtectionCommand;
const deserializeAws_json1_1UpdateTaskProtectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.ecs#ResourceNotFoundException":
            throw await deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1UpdateTaskSetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateTaskSetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateTaskSetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_json1_1UpdateTaskSetCommand = deserializeAws_json1_1UpdateTaskSetCommand;
const deserializeAws_json1_1UpdateTaskSetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ecs#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ClientException":
        case "com.amazonaws.ecs#ClientException":
            throw await deserializeAws_json1_1ClientExceptionResponse(parsedOutput, context);
        case "ClusterNotFoundException":
        case "com.amazonaws.ecs#ClusterNotFoundException":
            throw await deserializeAws_json1_1ClusterNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.ecs#InvalidParameterException":
            throw await deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput, context);
        case "ServerException":
        case "com.amazonaws.ecs#ServerException":
            throw await deserializeAws_json1_1ServerExceptionResponse(parsedOutput, context);
        case "ServiceNotActiveException":
        case "com.amazonaws.ecs#ServiceNotActiveException":
            throw await deserializeAws_json1_1ServiceNotActiveExceptionResponse(parsedOutput, context);
        case "ServiceNotFoundException":
        case "com.amazonaws.ecs#ServiceNotFoundException":
            throw await deserializeAws_json1_1ServiceNotFoundExceptionResponse(parsedOutput, context);
        case "TaskSetNotFoundException":
        case "com.amazonaws.ecs#TaskSetNotFoundException":
            throw await deserializeAws_json1_1TaskSetNotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedFeatureException":
        case "com.amazonaws.ecs#UnsupportedFeatureException":
            throw await deserializeAws_json1_1UnsupportedFeatureExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: ECSServiceException_1.ECSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1AccessDeniedException(body, context);
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1AttributeLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1AttributeLimitExceededException(body, context);
    const exception = new models_0_1.AttributeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1BlockedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1BlockedException(body, context);
    const exception = new models_0_1.BlockedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ClientExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ClientException(body, context);
    const exception = new models_0_1.ClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ClusterContainsContainerInstancesExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ClusterContainsContainerInstancesException(body, context);
    const exception = new models_0_1.ClusterContainsContainerInstancesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ClusterContainsServicesExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ClusterContainsServicesException(body, context);
    const exception = new models_0_1.ClusterContainsServicesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ClusterContainsTasksExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ClusterContainsTasksException(body, context);
    const exception = new models_0_1.ClusterContainsTasksException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ClusterNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ClusterNotFoundException(body, context);
    const exception = new models_0_1.ClusterNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1InvalidParameterExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidParameterException(body, context);
    const exception = new models_0_1.InvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1MissingVersionExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1MissingVersionException(body, context);
    const exception = new models_0_1.MissingVersionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1NamespaceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1NamespaceNotFoundException(body, context);
    const exception = new models_0_1.NamespaceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1NoUpdateAvailableExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1NoUpdateAvailableException(body, context);
    const exception = new models_0_1.NoUpdateAvailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1PlatformTaskDefinitionIncompatibilityExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1PlatformTaskDefinitionIncompatibilityException(body, context);
    const exception = new models_0_1.PlatformTaskDefinitionIncompatibilityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1PlatformUnknownExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1PlatformUnknownException(body, context);
    const exception = new models_0_1.PlatformUnknownException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ResourceInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceInUseException(body, context);
    const exception = new models_0_1.ResourceInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceNotFoundException(body, context);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ServerExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ServerException(body, context);
    const exception = new models_0_1.ServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ServiceNotActiveExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ServiceNotActiveException(body, context);
    const exception = new models_0_1.ServiceNotActiveException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1ServiceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ServiceNotFoundException(body, context);
    const exception = new models_0_1.ServiceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TargetNotConnectedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TargetNotConnectedException(body, context);
    const exception = new models_0_1.TargetNotConnectedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TargetNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TargetNotFoundException(body, context);
    const exception = new models_0_1.TargetNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1TaskSetNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TaskSetNotFoundException(body, context);
    const exception = new models_0_1.TaskSetNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1UnsupportedFeatureExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UnsupportedFeatureException(body, context);
    const exception = new models_0_1.UnsupportedFeatureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_json1_1UpdateInProgressExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UpdateInProgressException(body, context);
    const exception = new models_0_1.UpdateInProgressException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const serializeAws_json1_1AttachmentStateChange = (input, context) => {
    return {
        ...(input.attachmentArn != null && { attachmentArn: input.attachmentArn }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1AttachmentStateChanges = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1AttachmentStateChange(entry, context);
    });
};
const serializeAws_json1_1Attribute = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.targetId != null && { targetId: input.targetId }),
        ...(input.targetType != null && { targetType: input.targetType }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1Attributes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Attribute(entry, context);
    });
};
const serializeAws_json1_1AutoScalingGroupProvider = (input, context) => {
    return {
        ...(input.autoScalingGroupArn != null && { autoScalingGroupArn: input.autoScalingGroupArn }),
        ...(input.managedScaling != null && {
            managedScaling: serializeAws_json1_1ManagedScaling(input.managedScaling, context),
        }),
        ...(input.managedTerminationProtection != null && {
            managedTerminationProtection: input.managedTerminationProtection,
        }),
    };
};
const serializeAws_json1_1AutoScalingGroupProviderUpdate = (input, context) => {
    return {
        ...(input.managedScaling != null && {
            managedScaling: serializeAws_json1_1ManagedScaling(input.managedScaling, context),
        }),
        ...(input.managedTerminationProtection != null && {
            managedTerminationProtection: input.managedTerminationProtection,
        }),
    };
};
const serializeAws_json1_1AwsVpcConfiguration = (input, context) => {
    return {
        ...(input.assignPublicIp != null && { assignPublicIp: input.assignPublicIp }),
        ...(input.securityGroups != null && {
            securityGroups: serializeAws_json1_1StringList(input.securityGroups, context),
        }),
        ...(input.subnets != null && { subnets: serializeAws_json1_1StringList(input.subnets, context) }),
    };
};
const serializeAws_json1_1CapacityProviderFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CapacityProviderStrategy = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1CapacityProviderStrategyItem(entry, context);
    });
};
const serializeAws_json1_1CapacityProviderStrategyItem = (input, context) => {
    return {
        ...(input.base != null && { base: input.base }),
        ...(input.capacityProvider != null && { capacityProvider: input.capacityProvider }),
        ...(input.weight != null && { weight: input.weight }),
    };
};
const serializeAws_json1_1ClusterConfiguration = (input, context) => {
    return {
        ...(input.executeCommandConfiguration != null && {
            executeCommandConfiguration: serializeAws_json1_1ExecuteCommandConfiguration(input.executeCommandConfiguration, context),
        }),
    };
};
const serializeAws_json1_1ClusterFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ClusterServiceConnectDefaultsRequest = (input, context) => {
    return {
        ...(input.namespace != null && { namespace: input.namespace }),
    };
};
const serializeAws_json1_1ClusterSetting = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1ClusterSettings = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ClusterSetting(entry, context);
    });
};
const serializeAws_json1_1CompatibilityList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ContainerDefinition = (input, context) => {
    return {
        ...(input.command != null && { command: serializeAws_json1_1StringList(input.command, context) }),
        ...(input.cpu != null && { cpu: input.cpu }),
        ...(input.dependsOn != null && { dependsOn: serializeAws_json1_1ContainerDependencies(input.dependsOn, context) }),
        ...(input.disableNetworking != null && { disableNetworking: input.disableNetworking }),
        ...(input.dnsSearchDomains != null && {
            dnsSearchDomains: serializeAws_json1_1StringList(input.dnsSearchDomains, context),
        }),
        ...(input.dnsServers != null && { dnsServers: serializeAws_json1_1StringList(input.dnsServers, context) }),
        ...(input.dockerLabels != null && {
            dockerLabels: serializeAws_json1_1DockerLabelsMap(input.dockerLabels, context),
        }),
        ...(input.dockerSecurityOptions != null && {
            dockerSecurityOptions: serializeAws_json1_1StringList(input.dockerSecurityOptions, context),
        }),
        ...(input.entryPoint != null && { entryPoint: serializeAws_json1_1StringList(input.entryPoint, context) }),
        ...(input.environment != null && {
            environment: serializeAws_json1_1EnvironmentVariables(input.environment, context),
        }),
        ...(input.environmentFiles != null && {
            environmentFiles: serializeAws_json1_1EnvironmentFiles(input.environmentFiles, context),
        }),
        ...(input.essential != null && { essential: input.essential }),
        ...(input.extraHosts != null && { extraHosts: serializeAws_json1_1HostEntryList(input.extraHosts, context) }),
        ...(input.firelensConfiguration != null && {
            firelensConfiguration: serializeAws_json1_1FirelensConfiguration(input.firelensConfiguration, context),
        }),
        ...(input.healthCheck != null && { healthCheck: serializeAws_json1_1HealthCheck(input.healthCheck, context) }),
        ...(input.hostname != null && { hostname: input.hostname }),
        ...(input.image != null && { image: input.image }),
        ...(input.interactive != null && { interactive: input.interactive }),
        ...(input.links != null && { links: serializeAws_json1_1StringList(input.links, context) }),
        ...(input.linuxParameters != null && {
            linuxParameters: serializeAws_json1_1LinuxParameters(input.linuxParameters, context),
        }),
        ...(input.logConfiguration != null && {
            logConfiguration: serializeAws_json1_1LogConfiguration(input.logConfiguration, context),
        }),
        ...(input.memory != null && { memory: input.memory }),
        ...(input.memoryReservation != null && { memoryReservation: input.memoryReservation }),
        ...(input.mountPoints != null && { mountPoints: serializeAws_json1_1MountPointList(input.mountPoints, context) }),
        ...(input.name != null && { name: input.name }),
        ...(input.portMappings != null && {
            portMappings: serializeAws_json1_1PortMappingList(input.portMappings, context),
        }),
        ...(input.privileged != null && { privileged: input.privileged }),
        ...(input.pseudoTerminal != null && { pseudoTerminal: input.pseudoTerminal }),
        ...(input.readonlyRootFilesystem != null && { readonlyRootFilesystem: input.readonlyRootFilesystem }),
        ...(input.repositoryCredentials != null && {
            repositoryCredentials: serializeAws_json1_1RepositoryCredentials(input.repositoryCredentials, context),
        }),
        ...(input.resourceRequirements != null && {
            resourceRequirements: serializeAws_json1_1ResourceRequirements(input.resourceRequirements, context),
        }),
        ...(input.secrets != null && { secrets: serializeAws_json1_1SecretList(input.secrets, context) }),
        ...(input.startTimeout != null && { startTimeout: input.startTimeout }),
        ...(input.stopTimeout != null && { stopTimeout: input.stopTimeout }),
        ...(input.systemControls != null && {
            systemControls: serializeAws_json1_1SystemControls(input.systemControls, context),
        }),
        ...(input.ulimits != null && { ulimits: serializeAws_json1_1UlimitList(input.ulimits, context) }),
        ...(input.user != null && { user: input.user }),
        ...(input.volumesFrom != null && { volumesFrom: serializeAws_json1_1VolumeFromList(input.volumesFrom, context) }),
        ...(input.workingDirectory != null && { workingDirectory: input.workingDirectory }),
    };
};
const serializeAws_json1_1ContainerDefinitions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ContainerDefinition(entry, context);
    });
};
const serializeAws_json1_1ContainerDependencies = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ContainerDependency(entry, context);
    });
};
const serializeAws_json1_1ContainerDependency = (input, context) => {
    return {
        ...(input.condition != null && { condition: input.condition }),
        ...(input.containerName != null && { containerName: input.containerName }),
    };
};
const serializeAws_json1_1ContainerInstanceFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ContainerOverride = (input, context) => {
    return {
        ...(input.command != null && { command: serializeAws_json1_1StringList(input.command, context) }),
        ...(input.cpu != null && { cpu: input.cpu }),
        ...(input.environment != null && {
            environment: serializeAws_json1_1EnvironmentVariables(input.environment, context),
        }),
        ...(input.environmentFiles != null && {
            environmentFiles: serializeAws_json1_1EnvironmentFiles(input.environmentFiles, context),
        }),
        ...(input.memory != null && { memory: input.memory }),
        ...(input.memoryReservation != null && { memoryReservation: input.memoryReservation }),
        ...(input.name != null && { name: input.name }),
        ...(input.resourceRequirements != null && {
            resourceRequirements: serializeAws_json1_1ResourceRequirements(input.resourceRequirements, context),
        }),
    };
};
const serializeAws_json1_1ContainerOverrides = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ContainerOverride(entry, context);
    });
};
const serializeAws_json1_1ContainerStateChange = (input, context) => {
    return {
        ...(input.containerName != null && { containerName: input.containerName }),
        ...(input.exitCode != null && { exitCode: input.exitCode }),
        ...(input.imageDigest != null && { imageDigest: input.imageDigest }),
        ...(input.networkBindings != null && {
            networkBindings: serializeAws_json1_1NetworkBindings(input.networkBindings, context),
        }),
        ...(input.reason != null && { reason: input.reason }),
        ...(input.runtimeId != null && { runtimeId: input.runtimeId }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1ContainerStateChanges = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ContainerStateChange(entry, context);
    });
};
const serializeAws_json1_1CreateCapacityProviderRequest = (input, context) => {
    return {
        ...(input.autoScalingGroupProvider != null && {
            autoScalingGroupProvider: serializeAws_json1_1AutoScalingGroupProvider(input.autoScalingGroupProvider, context),
        }),
        ...(input.name != null && { name: input.name }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
    };
};
const serializeAws_json1_1CreateClusterRequest = (input, context) => {
    return {
        ...(input.capacityProviders != null && {
            capacityProviders: serializeAws_json1_1StringList(input.capacityProviders, context),
        }),
        ...(input.clusterName != null && { clusterName: input.clusterName }),
        ...(input.configuration != null && {
            configuration: serializeAws_json1_1ClusterConfiguration(input.configuration, context),
        }),
        ...(input.defaultCapacityProviderStrategy != null && {
            defaultCapacityProviderStrategy: serializeAws_json1_1CapacityProviderStrategy(input.defaultCapacityProviderStrategy, context),
        }),
        ...(input.serviceConnectDefaults != null && {
            serviceConnectDefaults: serializeAws_json1_1ClusterServiceConnectDefaultsRequest(input.serviceConnectDefaults, context),
        }),
        ...(input.settings != null && { settings: serializeAws_json1_1ClusterSettings(input.settings, context) }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
    };
};
const serializeAws_json1_1CreateServiceRequest = (input, context) => {
    return {
        ...(input.capacityProviderStrategy != null && {
            capacityProviderStrategy: serializeAws_json1_1CapacityProviderStrategy(input.capacityProviderStrategy, context),
        }),
        ...(input.clientToken != null && { clientToken: input.clientToken }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.deploymentConfiguration != null && {
            deploymentConfiguration: serializeAws_json1_1DeploymentConfiguration(input.deploymentConfiguration, context),
        }),
        ...(input.deploymentController != null && {
            deploymentController: serializeAws_json1_1DeploymentController(input.deploymentController, context),
        }),
        ...(input.desiredCount != null && { desiredCount: input.desiredCount }),
        ...(input.enableECSManagedTags != null && { enableECSManagedTags: input.enableECSManagedTags }),
        ...(input.enableExecuteCommand != null && { enableExecuteCommand: input.enableExecuteCommand }),
        ...(input.healthCheckGracePeriodSeconds != null && {
            healthCheckGracePeriodSeconds: input.healthCheckGracePeriodSeconds,
        }),
        ...(input.launchType != null && { launchType: input.launchType }),
        ...(input.loadBalancers != null && {
            loadBalancers: serializeAws_json1_1LoadBalancers(input.loadBalancers, context),
        }),
        ...(input.networkConfiguration != null && {
            networkConfiguration: serializeAws_json1_1NetworkConfiguration(input.networkConfiguration, context),
        }),
        ...(input.placementConstraints != null && {
            placementConstraints: serializeAws_json1_1PlacementConstraints(input.placementConstraints, context),
        }),
        ...(input.placementStrategy != null && {
            placementStrategy: serializeAws_json1_1PlacementStrategies(input.placementStrategy, context),
        }),
        ...(input.platformVersion != null && { platformVersion: input.platformVersion }),
        ...(input.propagateTags != null && { propagateTags: input.propagateTags }),
        ...(input.role != null && { role: input.role }),
        ...(input.schedulingStrategy != null && { schedulingStrategy: input.schedulingStrategy }),
        ...(input.serviceConnectConfiguration != null && {
            serviceConnectConfiguration: serializeAws_json1_1ServiceConnectConfiguration(input.serviceConnectConfiguration, context),
        }),
        ...(input.serviceName != null && { serviceName: input.serviceName }),
        ...(input.serviceRegistries != null && {
            serviceRegistries: serializeAws_json1_1ServiceRegistries(input.serviceRegistries, context),
        }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
        ...(input.taskDefinition != null && { taskDefinition: input.taskDefinition }),
    };
};
const serializeAws_json1_1CreateTaskSetRequest = (input, context) => {
    return {
        ...(input.capacityProviderStrategy != null && {
            capacityProviderStrategy: serializeAws_json1_1CapacityProviderStrategy(input.capacityProviderStrategy, context),
        }),
        ...(input.clientToken != null && { clientToken: input.clientToken }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.externalId != null && { externalId: input.externalId }),
        ...(input.launchType != null && { launchType: input.launchType }),
        ...(input.loadBalancers != null && {
            loadBalancers: serializeAws_json1_1LoadBalancers(input.loadBalancers, context),
        }),
        ...(input.networkConfiguration != null && {
            networkConfiguration: serializeAws_json1_1NetworkConfiguration(input.networkConfiguration, context),
        }),
        ...(input.platformVersion != null && { platformVersion: input.platformVersion }),
        ...(input.scale != null && { scale: serializeAws_json1_1Scale(input.scale, context) }),
        ...(input.service != null && { service: input.service }),
        ...(input.serviceRegistries != null && {
            serviceRegistries: serializeAws_json1_1ServiceRegistries(input.serviceRegistries, context),
        }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
        ...(input.taskDefinition != null && { taskDefinition: input.taskDefinition }),
    };
};
const serializeAws_json1_1DeleteAccountSettingRequest = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.principalArn != null && { principalArn: input.principalArn }),
    };
};
const serializeAws_json1_1DeleteAttributesRequest = (input, context) => {
    return {
        ...(input.attributes != null && { attributes: serializeAws_json1_1Attributes(input.attributes, context) }),
        ...(input.cluster != null && { cluster: input.cluster }),
    };
};
const serializeAws_json1_1DeleteCapacityProviderRequest = (input, context) => {
    return {
        ...(input.capacityProvider != null && { capacityProvider: input.capacityProvider }),
    };
};
const serializeAws_json1_1DeleteClusterRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
    };
};
const serializeAws_json1_1DeleteServiceRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.force != null && { force: input.force }),
        ...(input.service != null && { service: input.service }),
    };
};
const serializeAws_json1_1DeleteTaskSetRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.force != null && { force: input.force }),
        ...(input.service != null && { service: input.service }),
        ...(input.taskSet != null && { taskSet: input.taskSet }),
    };
};
const serializeAws_json1_1DeploymentAlarms = (input, context) => {
    return {
        ...(input.alarmNames != null && { alarmNames: serializeAws_json1_1StringList(input.alarmNames, context) }),
        ...(input.enable != null && { enable: input.enable }),
        ...(input.rollback != null && { rollback: input.rollback }),
    };
};
const serializeAws_json1_1DeploymentCircuitBreaker = (input, context) => {
    return {
        ...(input.enable != null && { enable: input.enable }),
        ...(input.rollback != null && { rollback: input.rollback }),
    };
};
const serializeAws_json1_1DeploymentConfiguration = (input, context) => {
    return {
        ...(input.alarms != null && { alarms: serializeAws_json1_1DeploymentAlarms(input.alarms, context) }),
        ...(input.deploymentCircuitBreaker != null && {
            deploymentCircuitBreaker: serializeAws_json1_1DeploymentCircuitBreaker(input.deploymentCircuitBreaker, context),
        }),
        ...(input.maximumPercent != null && { maximumPercent: input.maximumPercent }),
        ...(input.minimumHealthyPercent != null && { minimumHealthyPercent: input.minimumHealthyPercent }),
    };
};
const serializeAws_json1_1DeploymentController = (input, context) => {
    return {
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1DeregisterContainerInstanceRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstance != null && { containerInstance: input.containerInstance }),
        ...(input.force != null && { force: input.force }),
    };
};
const serializeAws_json1_1DeregisterTaskDefinitionRequest = (input, context) => {
    return {
        ...(input.taskDefinition != null && { taskDefinition: input.taskDefinition }),
    };
};
const serializeAws_json1_1DescribeCapacityProvidersRequest = (input, context) => {
    return {
        ...(input.capacityProviders != null && {
            capacityProviders: serializeAws_json1_1StringList(input.capacityProviders, context),
        }),
        ...(input.include != null && { include: serializeAws_json1_1CapacityProviderFieldList(input.include, context) }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1DescribeClustersRequest = (input, context) => {
    return {
        ...(input.clusters != null && { clusters: serializeAws_json1_1StringList(input.clusters, context) }),
        ...(input.include != null && { include: serializeAws_json1_1ClusterFieldList(input.include, context) }),
    };
};
const serializeAws_json1_1DescribeContainerInstancesRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstances != null && {
            containerInstances: serializeAws_json1_1StringList(input.containerInstances, context),
        }),
        ...(input.include != null && { include: serializeAws_json1_1ContainerInstanceFieldList(input.include, context) }),
    };
};
const serializeAws_json1_1DescribeServicesRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.include != null && { include: serializeAws_json1_1ServiceFieldList(input.include, context) }),
        ...(input.services != null && { services: serializeAws_json1_1StringList(input.services, context) }),
    };
};
const serializeAws_json1_1DescribeTaskDefinitionRequest = (input, context) => {
    return {
        ...(input.include != null && { include: serializeAws_json1_1TaskDefinitionFieldList(input.include, context) }),
        ...(input.taskDefinition != null && { taskDefinition: input.taskDefinition }),
    };
};
const serializeAws_json1_1DescribeTaskSetsRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.include != null && { include: serializeAws_json1_1TaskSetFieldList(input.include, context) }),
        ...(input.service != null && { service: input.service }),
        ...(input.taskSets != null && { taskSets: serializeAws_json1_1StringList(input.taskSets, context) }),
    };
};
const serializeAws_json1_1DescribeTasksRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.include != null && { include: serializeAws_json1_1TaskFieldList(input.include, context) }),
        ...(input.tasks != null && { tasks: serializeAws_json1_1StringList(input.tasks, context) }),
    };
};
const serializeAws_json1_1Device = (input, context) => {
    return {
        ...(input.containerPath != null && { containerPath: input.containerPath }),
        ...(input.hostPath != null && { hostPath: input.hostPath }),
        ...(input.permissions != null && {
            permissions: serializeAws_json1_1DeviceCgroupPermissions(input.permissions, context),
        }),
    };
};
const serializeAws_json1_1DeviceCgroupPermissions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DevicesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Device(entry, context);
    });
};
const serializeAws_json1_1DiscoverPollEndpointRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstance != null && { containerInstance: input.containerInstance }),
    };
};
const serializeAws_json1_1DockerLabelsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1DockerVolumeConfiguration = (input, context) => {
    return {
        ...(input.autoprovision != null && { autoprovision: input.autoprovision }),
        ...(input.driver != null && { driver: input.driver }),
        ...(input.driverOpts != null && { driverOpts: serializeAws_json1_1StringMap(input.driverOpts, context) }),
        ...(input.labels != null && { labels: serializeAws_json1_1StringMap(input.labels, context) }),
        ...(input.scope != null && { scope: input.scope }),
    };
};
const serializeAws_json1_1EFSAuthorizationConfig = (input, context) => {
    return {
        ...(input.accessPointId != null && { accessPointId: input.accessPointId }),
        ...(input.iam != null && { iam: input.iam }),
    };
};
const serializeAws_json1_1EFSVolumeConfiguration = (input, context) => {
    return {
        ...(input.authorizationConfig != null && {
            authorizationConfig: serializeAws_json1_1EFSAuthorizationConfig(input.authorizationConfig, context),
        }),
        ...(input.fileSystemId != null && { fileSystemId: input.fileSystemId }),
        ...(input.rootDirectory != null && { rootDirectory: input.rootDirectory }),
        ...(input.transitEncryption != null && { transitEncryption: input.transitEncryption }),
        ...(input.transitEncryptionPort != null && { transitEncryptionPort: input.transitEncryptionPort }),
    };
};
const serializeAws_json1_1EnvironmentFile = (input, context) => {
    return {
        ...(input.type != null && { type: input.type }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1EnvironmentFiles = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1EnvironmentFile(entry, context);
    });
};
const serializeAws_json1_1EnvironmentVariables = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1KeyValuePair(entry, context);
    });
};
const serializeAws_json1_1EphemeralStorage = (input, context) => {
    return {
        ...(input.sizeInGiB != null && { sizeInGiB: input.sizeInGiB }),
    };
};
const serializeAws_json1_1ExecuteCommandConfiguration = (input, context) => {
    return {
        ...(input.kmsKeyId != null && { kmsKeyId: input.kmsKeyId }),
        ...(input.logConfiguration != null && {
            logConfiguration: serializeAws_json1_1ExecuteCommandLogConfiguration(input.logConfiguration, context),
        }),
        ...(input.logging != null && { logging: input.logging }),
    };
};
const serializeAws_json1_1ExecuteCommandLogConfiguration = (input, context) => {
    return {
        ...(input.cloudWatchEncryptionEnabled != null && {
            cloudWatchEncryptionEnabled: input.cloudWatchEncryptionEnabled,
        }),
        ...(input.cloudWatchLogGroupName != null && { cloudWatchLogGroupName: input.cloudWatchLogGroupName }),
        ...(input.s3BucketName != null && { s3BucketName: input.s3BucketName }),
        ...(input.s3EncryptionEnabled != null && { s3EncryptionEnabled: input.s3EncryptionEnabled }),
        ...(input.s3KeyPrefix != null && { s3KeyPrefix: input.s3KeyPrefix }),
    };
};
const serializeAws_json1_1ExecuteCommandRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.command != null && { command: input.command }),
        ...(input.container != null && { container: input.container }),
        ...(input.interactive != null && { interactive: input.interactive }),
        ...(input.task != null && { task: input.task }),
    };
};
const serializeAws_json1_1FirelensConfiguration = (input, context) => {
    return {
        ...(input.options != null && {
            options: serializeAws_json1_1FirelensConfigurationOptionsMap(input.options, context),
        }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1FirelensConfigurationOptionsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1FSxWindowsFileServerAuthorizationConfig = (input, context) => {
    return {
        ...(input.credentialsParameter != null && { credentialsParameter: input.credentialsParameter }),
        ...(input.domain != null && { domain: input.domain }),
    };
};
const serializeAws_json1_1FSxWindowsFileServerVolumeConfiguration = (input, context) => {
    return {
        ...(input.authorizationConfig != null && {
            authorizationConfig: serializeAws_json1_1FSxWindowsFileServerAuthorizationConfig(input.authorizationConfig, context),
        }),
        ...(input.fileSystemId != null && { fileSystemId: input.fileSystemId }),
        ...(input.rootDirectory != null && { rootDirectory: input.rootDirectory }),
    };
};
const serializeAws_json1_1GetTaskProtectionRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.tasks != null && { tasks: serializeAws_json1_1StringList(input.tasks, context) }),
    };
};
const serializeAws_json1_1HealthCheck = (input, context) => {
    return {
        ...(input.command != null && { command: serializeAws_json1_1StringList(input.command, context) }),
        ...(input.interval != null && { interval: input.interval }),
        ...(input.retries != null && { retries: input.retries }),
        ...(input.startPeriod != null && { startPeriod: input.startPeriod }),
        ...(input.timeout != null && { timeout: input.timeout }),
    };
};
const serializeAws_json1_1HostEntry = (input, context) => {
    return {
        ...(input.hostname != null && { hostname: input.hostname }),
        ...(input.ipAddress != null && { ipAddress: input.ipAddress }),
    };
};
const serializeAws_json1_1HostEntryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1HostEntry(entry, context);
    });
};
const serializeAws_json1_1HostVolumeProperties = (input, context) => {
    return {
        ...(input.sourcePath != null && { sourcePath: input.sourcePath }),
    };
};
const serializeAws_json1_1InferenceAccelerator = (input, context) => {
    return {
        ...(input.deviceName != null && { deviceName: input.deviceName }),
        ...(input.deviceType != null && { deviceType: input.deviceType }),
    };
};
const serializeAws_json1_1InferenceAcceleratorOverride = (input, context) => {
    return {
        ...(input.deviceName != null && { deviceName: input.deviceName }),
        ...(input.deviceType != null && { deviceType: input.deviceType }),
    };
};
const serializeAws_json1_1InferenceAcceleratorOverrides = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1InferenceAcceleratorOverride(entry, context);
    });
};
const serializeAws_json1_1InferenceAccelerators = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1InferenceAccelerator(entry, context);
    });
};
const serializeAws_json1_1KernelCapabilities = (input, context) => {
    return {
        ...(input.add != null && { add: serializeAws_json1_1StringList(input.add, context) }),
        ...(input.drop != null && { drop: serializeAws_json1_1StringList(input.drop, context) }),
    };
};
const serializeAws_json1_1KeyValuePair = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1LinuxParameters = (input, context) => {
    return {
        ...(input.capabilities != null && {
            capabilities: serializeAws_json1_1KernelCapabilities(input.capabilities, context),
        }),
        ...(input.devices != null && { devices: serializeAws_json1_1DevicesList(input.devices, context) }),
        ...(input.initProcessEnabled != null && { initProcessEnabled: input.initProcessEnabled }),
        ...(input.maxSwap != null && { maxSwap: input.maxSwap }),
        ...(input.sharedMemorySize != null && { sharedMemorySize: input.sharedMemorySize }),
        ...(input.swappiness != null && { swappiness: input.swappiness }),
        ...(input.tmpfs != null && { tmpfs: serializeAws_json1_1TmpfsList(input.tmpfs, context) }),
    };
};
const serializeAws_json1_1ListAccountSettingsRequest = (input, context) => {
    return {
        ...(input.effectiveSettings != null && { effectiveSettings: input.effectiveSettings }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.name != null && { name: input.name }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.principalArn != null && { principalArn: input.principalArn }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1ListAttributesRequest = (input, context) => {
    return {
        ...(input.attributeName != null && { attributeName: input.attributeName }),
        ...(input.attributeValue != null && { attributeValue: input.attributeValue }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.targetType != null && { targetType: input.targetType }),
    };
};
const serializeAws_json1_1ListClustersRequest = (input, context) => {
    return {
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListContainerInstancesRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.filter != null && { filter: input.filter }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1ListServicesByNamespaceRequest = (input, context) => {
    return {
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.namespace != null && { namespace: input.namespace }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    };
};
const serializeAws_json1_1ListServicesRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.launchType != null && { launchType: input.launchType }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.schedulingStrategy != null && { schedulingStrategy: input.schedulingStrategy }),
    };
};
const serializeAws_json1_1ListTagsForResourceRequest = (input, context) => {
    return {
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
    };
};
const serializeAws_json1_1ListTaskDefinitionFamiliesRequest = (input, context) => {
    return {
        ...(input.familyPrefix != null && { familyPrefix: input.familyPrefix }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1ListTaskDefinitionsRequest = (input, context) => {
    return {
        ...(input.familyPrefix != null && { familyPrefix: input.familyPrefix }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.sort != null && { sort: input.sort }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1ListTasksRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstance != null && { containerInstance: input.containerInstance }),
        ...(input.desiredStatus != null && { desiredStatus: input.desiredStatus }),
        ...(input.family != null && { family: input.family }),
        ...(input.launchType != null && { launchType: input.launchType }),
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
        ...(input.serviceName != null && { serviceName: input.serviceName }),
        ...(input.startedBy != null && { startedBy: input.startedBy }),
    };
};
const serializeAws_json1_1LoadBalancer = (input, context) => {
    return {
        ...(input.containerName != null && { containerName: input.containerName }),
        ...(input.containerPort != null && { containerPort: input.containerPort }),
        ...(input.loadBalancerName != null && { loadBalancerName: input.loadBalancerName }),
        ...(input.targetGroupArn != null && { targetGroupArn: input.targetGroupArn }),
    };
};
const serializeAws_json1_1LoadBalancers = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1LoadBalancer(entry, context);
    });
};
const serializeAws_json1_1LogConfiguration = (input, context) => {
    return {
        ...(input.logDriver != null && { logDriver: input.logDriver }),
        ...(input.options != null && { options: serializeAws_json1_1LogConfigurationOptionsMap(input.options, context) }),
        ...(input.secretOptions != null && { secretOptions: serializeAws_json1_1SecretList(input.secretOptions, context) }),
    };
};
const serializeAws_json1_1LogConfigurationOptionsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1ManagedAgentStateChange = (input, context) => {
    return {
        ...(input.containerName != null && { containerName: input.containerName }),
        ...(input.managedAgentName != null && { managedAgentName: input.managedAgentName }),
        ...(input.reason != null && { reason: input.reason }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1ManagedAgentStateChanges = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ManagedAgentStateChange(entry, context);
    });
};
const serializeAws_json1_1ManagedScaling = (input, context) => {
    return {
        ...(input.instanceWarmupPeriod != null && { instanceWarmupPeriod: input.instanceWarmupPeriod }),
        ...(input.maximumScalingStepSize != null && { maximumScalingStepSize: input.maximumScalingStepSize }),
        ...(input.minimumScalingStepSize != null && { minimumScalingStepSize: input.minimumScalingStepSize }),
        ...(input.status != null && { status: input.status }),
        ...(input.targetCapacity != null && { targetCapacity: input.targetCapacity }),
    };
};
const serializeAws_json1_1MountPoint = (input, context) => {
    return {
        ...(input.containerPath != null && { containerPath: input.containerPath }),
        ...(input.readOnly != null && { readOnly: input.readOnly }),
        ...(input.sourceVolume != null && { sourceVolume: input.sourceVolume }),
    };
};
const serializeAws_json1_1MountPointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1MountPoint(entry, context);
    });
};
const serializeAws_json1_1NetworkBinding = (input, context) => {
    return {
        ...(input.bindIP != null && { bindIP: input.bindIP }),
        ...(input.containerPort != null && { containerPort: input.containerPort }),
        ...(input.containerPortRange != null && { containerPortRange: input.containerPortRange }),
        ...(input.hostPort != null && { hostPort: input.hostPort }),
        ...(input.hostPortRange != null && { hostPortRange: input.hostPortRange }),
        ...(input.protocol != null && { protocol: input.protocol }),
    };
};
const serializeAws_json1_1NetworkBindings = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1NetworkBinding(entry, context);
    });
};
const serializeAws_json1_1NetworkConfiguration = (input, context) => {
    return {
        ...(input.awsvpcConfiguration != null && {
            awsvpcConfiguration: serializeAws_json1_1AwsVpcConfiguration(input.awsvpcConfiguration, context),
        }),
    };
};
const serializeAws_json1_1PlacementConstraint = (input, context) => {
    return {
        ...(input.expression != null && { expression: input.expression }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1PlacementConstraints = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PlacementConstraint(entry, context);
    });
};
const serializeAws_json1_1PlacementStrategies = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PlacementStrategy(entry, context);
    });
};
const serializeAws_json1_1PlacementStrategy = (input, context) => {
    return {
        ...(input.field != null && { field: input.field }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1PlatformDevice = (input, context) => {
    return {
        ...(input.id != null && { id: input.id }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1PlatformDevices = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PlatformDevice(entry, context);
    });
};
const serializeAws_json1_1PortMapping = (input, context) => {
    return {
        ...(input.appProtocol != null && { appProtocol: input.appProtocol }),
        ...(input.containerPort != null && { containerPort: input.containerPort }),
        ...(input.containerPortRange != null && { containerPortRange: input.containerPortRange }),
        ...(input.hostPort != null && { hostPort: input.hostPort }),
        ...(input.name != null && { name: input.name }),
        ...(input.protocol != null && { protocol: input.protocol }),
    };
};
const serializeAws_json1_1PortMappingList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PortMapping(entry, context);
    });
};
const serializeAws_json1_1ProxyConfiguration = (input, context) => {
    return {
        ...(input.containerName != null && { containerName: input.containerName }),
        ...(input.properties != null && {
            properties: serializeAws_json1_1ProxyConfigurationProperties(input.properties, context),
        }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1ProxyConfigurationProperties = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1KeyValuePair(entry, context);
    });
};
const serializeAws_json1_1PutAccountSettingDefaultRequest = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1PutAccountSettingRequest = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.principalArn != null && { principalArn: input.principalArn }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1PutAttributesRequest = (input, context) => {
    return {
        ...(input.attributes != null && { attributes: serializeAws_json1_1Attributes(input.attributes, context) }),
        ...(input.cluster != null && { cluster: input.cluster }),
    };
};
const serializeAws_json1_1PutClusterCapacityProvidersRequest = (input, context) => {
    return {
        ...(input.capacityProviders != null && {
            capacityProviders: serializeAws_json1_1StringList(input.capacityProviders, context),
        }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.defaultCapacityProviderStrategy != null && {
            defaultCapacityProviderStrategy: serializeAws_json1_1CapacityProviderStrategy(input.defaultCapacityProviderStrategy, context),
        }),
    };
};
const serializeAws_json1_1RegisterContainerInstanceRequest = (input, context) => {
    return {
        ...(input.attributes != null && { attributes: serializeAws_json1_1Attributes(input.attributes, context) }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstanceArn != null && { containerInstanceArn: input.containerInstanceArn }),
        ...(input.instanceIdentityDocument != null && { instanceIdentityDocument: input.instanceIdentityDocument }),
        ...(input.instanceIdentityDocumentSignature != null && {
            instanceIdentityDocumentSignature: input.instanceIdentityDocumentSignature,
        }),
        ...(input.platformDevices != null && {
            platformDevices: serializeAws_json1_1PlatformDevices(input.platformDevices, context),
        }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
        ...(input.totalResources != null && {
            totalResources: serializeAws_json1_1Resources(input.totalResources, context),
        }),
        ...(input.versionInfo != null && { versionInfo: serializeAws_json1_1VersionInfo(input.versionInfo, context) }),
    };
};
const serializeAws_json1_1RegisterTaskDefinitionRequest = (input, context) => {
    return {
        ...(input.containerDefinitions != null && {
            containerDefinitions: serializeAws_json1_1ContainerDefinitions(input.containerDefinitions, context),
        }),
        ...(input.cpu != null && { cpu: input.cpu }),
        ...(input.ephemeralStorage != null && {
            ephemeralStorage: serializeAws_json1_1EphemeralStorage(input.ephemeralStorage, context),
        }),
        ...(input.executionRoleArn != null && { executionRoleArn: input.executionRoleArn }),
        ...(input.family != null && { family: input.family }),
        ...(input.inferenceAccelerators != null && {
            inferenceAccelerators: serializeAws_json1_1InferenceAccelerators(input.inferenceAccelerators, context),
        }),
        ...(input.ipcMode != null && { ipcMode: input.ipcMode }),
        ...(input.memory != null && { memory: input.memory }),
        ...(input.networkMode != null && { networkMode: input.networkMode }),
        ...(input.pidMode != null && { pidMode: input.pidMode }),
        ...(input.placementConstraints != null && {
            placementConstraints: serializeAws_json1_1TaskDefinitionPlacementConstraints(input.placementConstraints, context),
        }),
        ...(input.proxyConfiguration != null && {
            proxyConfiguration: serializeAws_json1_1ProxyConfiguration(input.proxyConfiguration, context),
        }),
        ...(input.requiresCompatibilities != null && {
            requiresCompatibilities: serializeAws_json1_1CompatibilityList(input.requiresCompatibilities, context),
        }),
        ...(input.runtimePlatform != null && {
            runtimePlatform: serializeAws_json1_1RuntimePlatform(input.runtimePlatform, context),
        }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
        ...(input.taskRoleArn != null && { taskRoleArn: input.taskRoleArn }),
        ...(input.volumes != null && { volumes: serializeAws_json1_1VolumeList(input.volumes, context) }),
    };
};
const serializeAws_json1_1RepositoryCredentials = (input, context) => {
    return {
        ...(input.credentialsParameter != null && { credentialsParameter: input.credentialsParameter }),
    };
};
const serializeAws_json1_1Resource = (input, context) => {
    return {
        ...(input.doubleValue != null && { doubleValue: (0, smithy_client_1.serializeFloat)(input.doubleValue) }),
        ...(input.integerValue != null && { integerValue: input.integerValue }),
        ...(input.longValue != null && { longValue: input.longValue }),
        ...(input.name != null && { name: input.name }),
        ...(input.stringSetValue != null && {
            stringSetValue: serializeAws_json1_1StringList(input.stringSetValue, context),
        }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1ResourceRequirement = (input, context) => {
    return {
        ...(input.type != null && { type: input.type }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1ResourceRequirements = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ResourceRequirement(entry, context);
    });
};
const serializeAws_json1_1Resources = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Resource(entry, context);
    });
};
const serializeAws_json1_1RunTaskRequest = (input, context) => {
    return {
        ...(input.capacityProviderStrategy != null && {
            capacityProviderStrategy: serializeAws_json1_1CapacityProviderStrategy(input.capacityProviderStrategy, context),
        }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.count != null && { count: input.count }),
        ...(input.enableECSManagedTags != null && { enableECSManagedTags: input.enableECSManagedTags }),
        ...(input.enableExecuteCommand != null && { enableExecuteCommand: input.enableExecuteCommand }),
        ...(input.group != null && { group: input.group }),
        ...(input.launchType != null && { launchType: input.launchType }),
        ...(input.networkConfiguration != null && {
            networkConfiguration: serializeAws_json1_1NetworkConfiguration(input.networkConfiguration, context),
        }),
        ...(input.overrides != null && { overrides: serializeAws_json1_1TaskOverride(input.overrides, context) }),
        ...(input.placementConstraints != null && {
            placementConstraints: serializeAws_json1_1PlacementConstraints(input.placementConstraints, context),
        }),
        ...(input.placementStrategy != null && {
            placementStrategy: serializeAws_json1_1PlacementStrategies(input.placementStrategy, context),
        }),
        ...(input.platformVersion != null && { platformVersion: input.platformVersion }),
        ...(input.propagateTags != null && { propagateTags: input.propagateTags }),
        ...(input.referenceId != null && { referenceId: input.referenceId }),
        ...(input.startedBy != null && { startedBy: input.startedBy }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
        ...(input.taskDefinition != null && { taskDefinition: input.taskDefinition }),
    };
};
const serializeAws_json1_1RuntimePlatform = (input, context) => {
    return {
        ...(input.cpuArchitecture != null && { cpuArchitecture: input.cpuArchitecture }),
        ...(input.operatingSystemFamily != null && { operatingSystemFamily: input.operatingSystemFamily }),
    };
};
const serializeAws_json1_1Scale = (input, context) => {
    return {
        ...(input.unit != null && { unit: input.unit }),
        ...(input.value != null && { value: (0, smithy_client_1.serializeFloat)(input.value) }),
    };
};
const serializeAws_json1_1Secret = (input, context) => {
    return {
        ...(input.name != null && { name: input.name }),
        ...(input.valueFrom != null && { valueFrom: input.valueFrom }),
    };
};
const serializeAws_json1_1SecretList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Secret(entry, context);
    });
};
const serializeAws_json1_1ServiceConnectClientAlias = (input, context) => {
    return {
        ...(input.dnsName != null && { dnsName: input.dnsName }),
        ...(input.port != null && { port: input.port }),
    };
};
const serializeAws_json1_1ServiceConnectClientAliasList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ServiceConnectClientAlias(entry, context);
    });
};
const serializeAws_json1_1ServiceConnectConfiguration = (input, context) => {
    return {
        ...(input.enabled != null && { enabled: input.enabled }),
        ...(input.logConfiguration != null && {
            logConfiguration: serializeAws_json1_1LogConfiguration(input.logConfiguration, context),
        }),
        ...(input.namespace != null && { namespace: input.namespace }),
        ...(input.services != null && { services: serializeAws_json1_1ServiceConnectServiceList(input.services, context) }),
    };
};
const serializeAws_json1_1ServiceConnectService = (input, context) => {
    return {
        ...(input.clientAliases != null && {
            clientAliases: serializeAws_json1_1ServiceConnectClientAliasList(input.clientAliases, context),
        }),
        ...(input.discoveryName != null && { discoveryName: input.discoveryName }),
        ...(input.ingressPortOverride != null && { ingressPortOverride: input.ingressPortOverride }),
        ...(input.portName != null && { portName: input.portName }),
    };
};
const serializeAws_json1_1ServiceConnectServiceList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ServiceConnectService(entry, context);
    });
};
const serializeAws_json1_1ServiceFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ServiceRegistries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ServiceRegistry(entry, context);
    });
};
const serializeAws_json1_1ServiceRegistry = (input, context) => {
    return {
        ...(input.containerName != null && { containerName: input.containerName }),
        ...(input.containerPort != null && { containerPort: input.containerPort }),
        ...(input.port != null && { port: input.port }),
        ...(input.registryArn != null && { registryArn: input.registryArn }),
    };
};
const serializeAws_json1_1StartTaskRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstances != null && {
            containerInstances: serializeAws_json1_1StringList(input.containerInstances, context),
        }),
        ...(input.enableECSManagedTags != null && { enableECSManagedTags: input.enableECSManagedTags }),
        ...(input.enableExecuteCommand != null && { enableExecuteCommand: input.enableExecuteCommand }),
        ...(input.group != null && { group: input.group }),
        ...(input.networkConfiguration != null && {
            networkConfiguration: serializeAws_json1_1NetworkConfiguration(input.networkConfiguration, context),
        }),
        ...(input.overrides != null && { overrides: serializeAws_json1_1TaskOverride(input.overrides, context) }),
        ...(input.propagateTags != null && { propagateTags: input.propagateTags }),
        ...(input.referenceId != null && { referenceId: input.referenceId }),
        ...(input.startedBy != null && { startedBy: input.startedBy }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
        ...(input.taskDefinition != null && { taskDefinition: input.taskDefinition }),
    };
};
const serializeAws_json1_1StopTaskRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.reason != null && { reason: input.reason }),
        ...(input.task != null && { task: input.task }),
    };
};
const serializeAws_json1_1StringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1StringMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1SubmitAttachmentStateChangesRequest = (input, context) => {
    return {
        ...(input.attachments != null && {
            attachments: serializeAws_json1_1AttachmentStateChanges(input.attachments, context),
        }),
        ...(input.cluster != null && { cluster: input.cluster }),
    };
};
const serializeAws_json1_1SubmitContainerStateChangeRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerName != null && { containerName: input.containerName }),
        ...(input.exitCode != null && { exitCode: input.exitCode }),
        ...(input.networkBindings != null && {
            networkBindings: serializeAws_json1_1NetworkBindings(input.networkBindings, context),
        }),
        ...(input.reason != null && { reason: input.reason }),
        ...(input.runtimeId != null && { runtimeId: input.runtimeId }),
        ...(input.status != null && { status: input.status }),
        ...(input.task != null && { task: input.task }),
    };
};
const serializeAws_json1_1SubmitTaskStateChangeRequest = (input, context) => {
    return {
        ...(input.attachments != null && {
            attachments: serializeAws_json1_1AttachmentStateChanges(input.attachments, context),
        }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containers != null && {
            containers: serializeAws_json1_1ContainerStateChanges(input.containers, context),
        }),
        ...(input.executionStoppedAt != null && {
            executionStoppedAt: Math.round(input.executionStoppedAt.getTime() / 1000),
        }),
        ...(input.managedAgents != null && {
            managedAgents: serializeAws_json1_1ManagedAgentStateChanges(input.managedAgents, context),
        }),
        ...(input.pullStartedAt != null && { pullStartedAt: Math.round(input.pullStartedAt.getTime() / 1000) }),
        ...(input.pullStoppedAt != null && { pullStoppedAt: Math.round(input.pullStoppedAt.getTime() / 1000) }),
        ...(input.reason != null && { reason: input.reason }),
        ...(input.status != null && { status: input.status }),
        ...(input.task != null && { task: input.task }),
    };
};
const serializeAws_json1_1SystemControl = (input, context) => {
    return {
        ...(input.namespace != null && { namespace: input.namespace }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1SystemControls = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1SystemControl(entry, context);
    });
};
const serializeAws_json1_1Tag = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_json1_1TagKeys = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TagResourceRequest = (input, context) => {
    return {
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
        ...(input.tags != null && { tags: serializeAws_json1_1Tags(input.tags, context) }),
    };
};
const serializeAws_json1_1Tags = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Tag(entry, context);
    });
};
const serializeAws_json1_1TaskDefinitionFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TaskDefinitionPlacementConstraint = (input, context) => {
    return {
        ...(input.expression != null && { expression: input.expression }),
        ...(input.type != null && { type: input.type }),
    };
};
const serializeAws_json1_1TaskDefinitionPlacementConstraints = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1TaskDefinitionPlacementConstraint(entry, context);
    });
};
const serializeAws_json1_1TaskFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TaskOverride = (input, context) => {
    return {
        ...(input.containerOverrides != null && {
            containerOverrides: serializeAws_json1_1ContainerOverrides(input.containerOverrides, context),
        }),
        ...(input.cpu != null && { cpu: input.cpu }),
        ...(input.ephemeralStorage != null && {
            ephemeralStorage: serializeAws_json1_1EphemeralStorage(input.ephemeralStorage, context),
        }),
        ...(input.executionRoleArn != null && { executionRoleArn: input.executionRoleArn }),
        ...(input.inferenceAcceleratorOverrides != null && {
            inferenceAcceleratorOverrides: serializeAws_json1_1InferenceAcceleratorOverrides(input.inferenceAcceleratorOverrides, context),
        }),
        ...(input.memory != null && { memory: input.memory }),
        ...(input.taskRoleArn != null && { taskRoleArn: input.taskRoleArn }),
    };
};
const serializeAws_json1_1TaskSetFieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1Tmpfs = (input, context) => {
    return {
        ...(input.containerPath != null && { containerPath: input.containerPath }),
        ...(input.mountOptions != null && { mountOptions: serializeAws_json1_1StringList(input.mountOptions, context) }),
        ...(input.size != null && { size: input.size }),
    };
};
const serializeAws_json1_1TmpfsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Tmpfs(entry, context);
    });
};
const serializeAws_json1_1Ulimit = (input, context) => {
    return {
        ...(input.hardLimit != null && { hardLimit: input.hardLimit }),
        ...(input.name != null && { name: input.name }),
        ...(input.softLimit != null && { softLimit: input.softLimit }),
    };
};
const serializeAws_json1_1UlimitList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Ulimit(entry, context);
    });
};
const serializeAws_json1_1UntagResourceRequest = (input, context) => {
    return {
        ...(input.resourceArn != null && { resourceArn: input.resourceArn }),
        ...(input.tagKeys != null && { tagKeys: serializeAws_json1_1TagKeys(input.tagKeys, context) }),
    };
};
const serializeAws_json1_1UpdateCapacityProviderRequest = (input, context) => {
    return {
        ...(input.autoScalingGroupProvider != null && {
            autoScalingGroupProvider: serializeAws_json1_1AutoScalingGroupProviderUpdate(input.autoScalingGroupProvider, context),
        }),
        ...(input.name != null && { name: input.name }),
    };
};
const serializeAws_json1_1UpdateClusterRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.configuration != null && {
            configuration: serializeAws_json1_1ClusterConfiguration(input.configuration, context),
        }),
        ...(input.serviceConnectDefaults != null && {
            serviceConnectDefaults: serializeAws_json1_1ClusterServiceConnectDefaultsRequest(input.serviceConnectDefaults, context),
        }),
        ...(input.settings != null && { settings: serializeAws_json1_1ClusterSettings(input.settings, context) }),
    };
};
const serializeAws_json1_1UpdateClusterSettingsRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.settings != null && { settings: serializeAws_json1_1ClusterSettings(input.settings, context) }),
    };
};
const serializeAws_json1_1UpdateContainerAgentRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstance != null && { containerInstance: input.containerInstance }),
    };
};
const serializeAws_json1_1UpdateContainerInstancesStateRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.containerInstances != null && {
            containerInstances: serializeAws_json1_1StringList(input.containerInstances, context),
        }),
        ...(input.status != null && { status: input.status }),
    };
};
const serializeAws_json1_1UpdateServicePrimaryTaskSetRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.primaryTaskSet != null && { primaryTaskSet: input.primaryTaskSet }),
        ...(input.service != null && { service: input.service }),
    };
};
const serializeAws_json1_1UpdateServiceRequest = (input, context) => {
    return {
        ...(input.capacityProviderStrategy != null && {
            capacityProviderStrategy: serializeAws_json1_1CapacityProviderStrategy(input.capacityProviderStrategy, context),
        }),
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.deploymentConfiguration != null && {
            deploymentConfiguration: serializeAws_json1_1DeploymentConfiguration(input.deploymentConfiguration, context),
        }),
        ...(input.desiredCount != null && { desiredCount: input.desiredCount }),
        ...(input.enableECSManagedTags != null && { enableECSManagedTags: input.enableECSManagedTags }),
        ...(input.enableExecuteCommand != null && { enableExecuteCommand: input.enableExecuteCommand }),
        ...(input.forceNewDeployment != null && { forceNewDeployment: input.forceNewDeployment }),
        ...(input.healthCheckGracePeriodSeconds != null && {
            healthCheckGracePeriodSeconds: input.healthCheckGracePeriodSeconds,
        }),
        ...(input.loadBalancers != null && {
            loadBalancers: serializeAws_json1_1LoadBalancers(input.loadBalancers, context),
        }),
        ...(input.networkConfiguration != null && {
            networkConfiguration: serializeAws_json1_1NetworkConfiguration(input.networkConfiguration, context),
        }),
        ...(input.placementConstraints != null && {
            placementConstraints: serializeAws_json1_1PlacementConstraints(input.placementConstraints, context),
        }),
        ...(input.placementStrategy != null && {
            placementStrategy: serializeAws_json1_1PlacementStrategies(input.placementStrategy, context),
        }),
        ...(input.platformVersion != null && { platformVersion: input.platformVersion }),
        ...(input.propagateTags != null && { propagateTags: input.propagateTags }),
        ...(input.service != null && { service: input.service }),
        ...(input.serviceConnectConfiguration != null && {
            serviceConnectConfiguration: serializeAws_json1_1ServiceConnectConfiguration(input.serviceConnectConfiguration, context),
        }),
        ...(input.serviceRegistries != null && {
            serviceRegistries: serializeAws_json1_1ServiceRegistries(input.serviceRegistries, context),
        }),
        ...(input.taskDefinition != null && { taskDefinition: input.taskDefinition }),
    };
};
const serializeAws_json1_1UpdateTaskProtectionRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.expiresInMinutes != null && { expiresInMinutes: input.expiresInMinutes }),
        ...(input.protectionEnabled != null && { protectionEnabled: input.protectionEnabled }),
        ...(input.tasks != null && { tasks: serializeAws_json1_1StringList(input.tasks, context) }),
    };
};
const serializeAws_json1_1UpdateTaskSetRequest = (input, context) => {
    return {
        ...(input.cluster != null && { cluster: input.cluster }),
        ...(input.scale != null && { scale: serializeAws_json1_1Scale(input.scale, context) }),
        ...(input.service != null && { service: input.service }),
        ...(input.taskSet != null && { taskSet: input.taskSet }),
    };
};
const serializeAws_json1_1VersionInfo = (input, context) => {
    return {
        ...(input.agentHash != null && { agentHash: input.agentHash }),
        ...(input.agentVersion != null && { agentVersion: input.agentVersion }),
        ...(input.dockerVersion != null && { dockerVersion: input.dockerVersion }),
    };
};
const serializeAws_json1_1Volume = (input, context) => {
    return {
        ...(input.dockerVolumeConfiguration != null && {
            dockerVolumeConfiguration: serializeAws_json1_1DockerVolumeConfiguration(input.dockerVolumeConfiguration, context),
        }),
        ...(input.efsVolumeConfiguration != null && {
            efsVolumeConfiguration: serializeAws_json1_1EFSVolumeConfiguration(input.efsVolumeConfiguration, context),
        }),
        ...(input.fsxWindowsFileServerVolumeConfiguration != null && {
            fsxWindowsFileServerVolumeConfiguration: serializeAws_json1_1FSxWindowsFileServerVolumeConfiguration(input.fsxWindowsFileServerVolumeConfiguration, context),
        }),
        ...(input.host != null && { host: serializeAws_json1_1HostVolumeProperties(input.host, context) }),
        ...(input.name != null && { name: input.name }),
    };
};
const serializeAws_json1_1VolumeFrom = (input, context) => {
    return {
        ...(input.readOnly != null && { readOnly: input.readOnly }),
        ...(input.sourceContainer != null && { sourceContainer: input.sourceContainer }),
    };
};
const serializeAws_json1_1VolumeFromList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1VolumeFrom(entry, context);
    });
};
const serializeAws_json1_1VolumeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Volume(entry, context);
    });
};
const deserializeAws_json1_1AccessDeniedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1Attachment = (output, context) => {
    return {
        details: output.details != null ? deserializeAws_json1_1AttachmentDetails(output.details, context) : undefined,
        id: (0, smithy_client_1.expectString)(output.id),
        status: (0, smithy_client_1.expectString)(output.status),
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1AttachmentDetails = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1KeyValuePair(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Attachments = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Attachment(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Attribute = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
        targetId: (0, smithy_client_1.expectString)(output.targetId),
        targetType: (0, smithy_client_1.expectString)(output.targetType),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1AttributeLimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1Attributes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Attribute(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1AutoScalingGroupProvider = (output, context) => {
    return {
        autoScalingGroupArn: (0, smithy_client_1.expectString)(output.autoScalingGroupArn),
        managedScaling: output.managedScaling != null ? deserializeAws_json1_1ManagedScaling(output.managedScaling, context) : undefined,
        managedTerminationProtection: (0, smithy_client_1.expectString)(output.managedTerminationProtection),
    };
};
const deserializeAws_json1_1AwsVpcConfiguration = (output, context) => {
    return {
        assignPublicIp: (0, smithy_client_1.expectString)(output.assignPublicIp),
        securityGroups: output.securityGroups != null ? deserializeAws_json1_1StringList(output.securityGroups, context) : undefined,
        subnets: output.subnets != null ? deserializeAws_json1_1StringList(output.subnets, context) : undefined,
    };
};
const deserializeAws_json1_1BlockedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1CapacityProvider = (output, context) => {
    return {
        autoScalingGroupProvider: output.autoScalingGroupProvider != null
            ? deserializeAws_json1_1AutoScalingGroupProvider(output.autoScalingGroupProvider, context)
            : undefined,
        capacityProviderArn: (0, smithy_client_1.expectString)(output.capacityProviderArn),
        name: (0, smithy_client_1.expectString)(output.name),
        status: (0, smithy_client_1.expectString)(output.status),
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
        updateStatus: (0, smithy_client_1.expectString)(output.updateStatus),
        updateStatusReason: (0, smithy_client_1.expectString)(output.updateStatusReason),
    };
};
const deserializeAws_json1_1CapacityProviders = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CapacityProvider(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CapacityProviderStrategy = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CapacityProviderStrategyItem(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CapacityProviderStrategyItem = (output, context) => {
    return {
        base: (0, smithy_client_1.expectInt32)(output.base),
        capacityProvider: (0, smithy_client_1.expectString)(output.capacityProvider),
        weight: (0, smithy_client_1.expectInt32)(output.weight),
    };
};
const deserializeAws_json1_1ClientException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1Cluster = (output, context) => {
    return {
        activeServicesCount: (0, smithy_client_1.expectInt32)(output.activeServicesCount),
        attachments: output.attachments != null ? deserializeAws_json1_1Attachments(output.attachments, context) : undefined,
        attachmentsStatus: (0, smithy_client_1.expectString)(output.attachmentsStatus),
        capacityProviders: output.capacityProviders != null
            ? deserializeAws_json1_1StringList(output.capacityProviders, context)
            : undefined,
        clusterArn: (0, smithy_client_1.expectString)(output.clusterArn),
        clusterName: (0, smithy_client_1.expectString)(output.clusterName),
        configuration: output.configuration != null
            ? deserializeAws_json1_1ClusterConfiguration(output.configuration, context)
            : undefined,
        defaultCapacityProviderStrategy: output.defaultCapacityProviderStrategy != null
            ? deserializeAws_json1_1CapacityProviderStrategy(output.defaultCapacityProviderStrategy, context)
            : undefined,
        pendingTasksCount: (0, smithy_client_1.expectInt32)(output.pendingTasksCount),
        registeredContainerInstancesCount: (0, smithy_client_1.expectInt32)(output.registeredContainerInstancesCount),
        runningTasksCount: (0, smithy_client_1.expectInt32)(output.runningTasksCount),
        serviceConnectDefaults: output.serviceConnectDefaults != null
            ? deserializeAws_json1_1ClusterServiceConnectDefaults(output.serviceConnectDefaults, context)
            : undefined,
        settings: output.settings != null ? deserializeAws_json1_1ClusterSettings(output.settings, context) : undefined,
        statistics: output.statistics != null ? deserializeAws_json1_1Statistics(output.statistics, context) : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
    };
};
const deserializeAws_json1_1ClusterConfiguration = (output, context) => {
    return {
        executeCommandConfiguration: output.executeCommandConfiguration != null
            ? deserializeAws_json1_1ExecuteCommandConfiguration(output.executeCommandConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_1ClusterContainsContainerInstancesException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ClusterContainsServicesException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ClusterContainsTasksException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ClusterNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1Clusters = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Cluster(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ClusterServiceConnectDefaults = (output, context) => {
    return {
        namespace: (0, smithy_client_1.expectString)(output.namespace),
    };
};
const deserializeAws_json1_1ClusterSetting = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1ClusterSettings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ClusterSetting(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CompatibilityList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1Container = (output, context) => {
    return {
        containerArn: (0, smithy_client_1.expectString)(output.containerArn),
        cpu: (0, smithy_client_1.expectString)(output.cpu),
        exitCode: (0, smithy_client_1.expectInt32)(output.exitCode),
        gpuIds: output.gpuIds != null ? deserializeAws_json1_1GpuIds(output.gpuIds, context) : undefined,
        healthStatus: (0, smithy_client_1.expectString)(output.healthStatus),
        image: (0, smithy_client_1.expectString)(output.image),
        imageDigest: (0, smithy_client_1.expectString)(output.imageDigest),
        lastStatus: (0, smithy_client_1.expectString)(output.lastStatus),
        managedAgents: output.managedAgents != null ? deserializeAws_json1_1ManagedAgents(output.managedAgents, context) : undefined,
        memory: (0, smithy_client_1.expectString)(output.memory),
        memoryReservation: (0, smithy_client_1.expectString)(output.memoryReservation),
        name: (0, smithy_client_1.expectString)(output.name),
        networkBindings: output.networkBindings != null
            ? deserializeAws_json1_1NetworkBindings(output.networkBindings, context)
            : undefined,
        networkInterfaces: output.networkInterfaces != null
            ? deserializeAws_json1_1NetworkInterfaces(output.networkInterfaces, context)
            : undefined,
        reason: (0, smithy_client_1.expectString)(output.reason),
        runtimeId: (0, smithy_client_1.expectString)(output.runtimeId),
        taskArn: (0, smithy_client_1.expectString)(output.taskArn),
    };
};
const deserializeAws_json1_1ContainerDefinition = (output, context) => {
    return {
        command: output.command != null ? deserializeAws_json1_1StringList(output.command, context) : undefined,
        cpu: (0, smithy_client_1.expectInt32)(output.cpu),
        dependsOn: output.dependsOn != null ? deserializeAws_json1_1ContainerDependencies(output.dependsOn, context) : undefined,
        disableNetworking: (0, smithy_client_1.expectBoolean)(output.disableNetworking),
        dnsSearchDomains: output.dnsSearchDomains != null ? deserializeAws_json1_1StringList(output.dnsSearchDomains, context) : undefined,
        dnsServers: output.dnsServers != null ? deserializeAws_json1_1StringList(output.dnsServers, context) : undefined,
        dockerLabels: output.dockerLabels != null ? deserializeAws_json1_1DockerLabelsMap(output.dockerLabels, context) : undefined,
        dockerSecurityOptions: output.dockerSecurityOptions != null
            ? deserializeAws_json1_1StringList(output.dockerSecurityOptions, context)
            : undefined,
        entryPoint: output.entryPoint != null ? deserializeAws_json1_1StringList(output.entryPoint, context) : undefined,
        environment: output.environment != null ? deserializeAws_json1_1EnvironmentVariables(output.environment, context) : undefined,
        environmentFiles: output.environmentFiles != null
            ? deserializeAws_json1_1EnvironmentFiles(output.environmentFiles, context)
            : undefined,
        essential: (0, smithy_client_1.expectBoolean)(output.essential),
        extraHosts: output.extraHosts != null ? deserializeAws_json1_1HostEntryList(output.extraHosts, context) : undefined,
        firelensConfiguration: output.firelensConfiguration != null
            ? deserializeAws_json1_1FirelensConfiguration(output.firelensConfiguration, context)
            : undefined,
        healthCheck: output.healthCheck != null ? deserializeAws_json1_1HealthCheck(output.healthCheck, context) : undefined,
        hostname: (0, smithy_client_1.expectString)(output.hostname),
        image: (0, smithy_client_1.expectString)(output.image),
        interactive: (0, smithy_client_1.expectBoolean)(output.interactive),
        links: output.links != null ? deserializeAws_json1_1StringList(output.links, context) : undefined,
        linuxParameters: output.linuxParameters != null
            ? deserializeAws_json1_1LinuxParameters(output.linuxParameters, context)
            : undefined,
        logConfiguration: output.logConfiguration != null
            ? deserializeAws_json1_1LogConfiguration(output.logConfiguration, context)
            : undefined,
        memory: (0, smithy_client_1.expectInt32)(output.memory),
        memoryReservation: (0, smithy_client_1.expectInt32)(output.memoryReservation),
        mountPoints: output.mountPoints != null ? deserializeAws_json1_1MountPointList(output.mountPoints, context) : undefined,
        name: (0, smithy_client_1.expectString)(output.name),
        portMappings: output.portMappings != null ? deserializeAws_json1_1PortMappingList(output.portMappings, context) : undefined,
        privileged: (0, smithy_client_1.expectBoolean)(output.privileged),
        pseudoTerminal: (0, smithy_client_1.expectBoolean)(output.pseudoTerminal),
        readonlyRootFilesystem: (0, smithy_client_1.expectBoolean)(output.readonlyRootFilesystem),
        repositoryCredentials: output.repositoryCredentials != null
            ? deserializeAws_json1_1RepositoryCredentials(output.repositoryCredentials, context)
            : undefined,
        resourceRequirements: output.resourceRequirements != null
            ? deserializeAws_json1_1ResourceRequirements(output.resourceRequirements, context)
            : undefined,
        secrets: output.secrets != null ? deserializeAws_json1_1SecretList(output.secrets, context) : undefined,
        startTimeout: (0, smithy_client_1.expectInt32)(output.startTimeout),
        stopTimeout: (0, smithy_client_1.expectInt32)(output.stopTimeout),
        systemControls: output.systemControls != null ? deserializeAws_json1_1SystemControls(output.systemControls, context) : undefined,
        ulimits: output.ulimits != null ? deserializeAws_json1_1UlimitList(output.ulimits, context) : undefined,
        user: (0, smithy_client_1.expectString)(output.user),
        volumesFrom: output.volumesFrom != null ? deserializeAws_json1_1VolumeFromList(output.volumesFrom, context) : undefined,
        workingDirectory: (0, smithy_client_1.expectString)(output.workingDirectory),
    };
};
const deserializeAws_json1_1ContainerDefinitions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ContainerDefinition(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ContainerDependencies = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ContainerDependency(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ContainerDependency = (output, context) => {
    return {
        condition: (0, smithy_client_1.expectString)(output.condition),
        containerName: (0, smithy_client_1.expectString)(output.containerName),
    };
};
const deserializeAws_json1_1ContainerInstance = (output, context) => {
    return {
        agentConnected: (0, smithy_client_1.expectBoolean)(output.agentConnected),
        agentUpdateStatus: (0, smithy_client_1.expectString)(output.agentUpdateStatus),
        attachments: output.attachments != null ? deserializeAws_json1_1Attachments(output.attachments, context) : undefined,
        attributes: output.attributes != null ? deserializeAws_json1_1Attributes(output.attributes, context) : undefined,
        capacityProviderName: (0, smithy_client_1.expectString)(output.capacityProviderName),
        containerInstanceArn: (0, smithy_client_1.expectString)(output.containerInstanceArn),
        ec2InstanceId: (0, smithy_client_1.expectString)(output.ec2InstanceId),
        healthStatus: output.healthStatus != null
            ? deserializeAws_json1_1ContainerInstanceHealthStatus(output.healthStatus, context)
            : undefined,
        pendingTasksCount: (0, smithy_client_1.expectInt32)(output.pendingTasksCount),
        registeredAt: output.registeredAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.registeredAt)))
            : undefined,
        registeredResources: output.registeredResources != null
            ? deserializeAws_json1_1Resources(output.registeredResources, context)
            : undefined,
        remainingResources: output.remainingResources != null
            ? deserializeAws_json1_1Resources(output.remainingResources, context)
            : undefined,
        runningTasksCount: (0, smithy_client_1.expectInt32)(output.runningTasksCount),
        status: (0, smithy_client_1.expectString)(output.status),
        statusReason: (0, smithy_client_1.expectString)(output.statusReason),
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
        version: (0, smithy_client_1.expectLong)(output.version),
        versionInfo: output.versionInfo != null ? deserializeAws_json1_1VersionInfo(output.versionInfo, context) : undefined,
    };
};
const deserializeAws_json1_1ContainerInstanceHealthStatus = (output, context) => {
    return {
        details: output.details != null ? deserializeAws_json1_1InstanceHealthCheckResultList(output.details, context) : undefined,
        overallStatus: (0, smithy_client_1.expectString)(output.overallStatus),
    };
};
const deserializeAws_json1_1ContainerInstances = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ContainerInstance(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ContainerOverride = (output, context) => {
    return {
        command: output.command != null ? deserializeAws_json1_1StringList(output.command, context) : undefined,
        cpu: (0, smithy_client_1.expectInt32)(output.cpu),
        environment: output.environment != null ? deserializeAws_json1_1EnvironmentVariables(output.environment, context) : undefined,
        environmentFiles: output.environmentFiles != null
            ? deserializeAws_json1_1EnvironmentFiles(output.environmentFiles, context)
            : undefined,
        memory: (0, smithy_client_1.expectInt32)(output.memory),
        memoryReservation: (0, smithy_client_1.expectInt32)(output.memoryReservation),
        name: (0, smithy_client_1.expectString)(output.name),
        resourceRequirements: output.resourceRequirements != null
            ? deserializeAws_json1_1ResourceRequirements(output.resourceRequirements, context)
            : undefined,
    };
};
const deserializeAws_json1_1ContainerOverrides = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ContainerOverride(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Containers = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Container(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CreateCapacityProviderResponse = (output, context) => {
    return {
        capacityProvider: output.capacityProvider != null
            ? deserializeAws_json1_1CapacityProvider(output.capacityProvider, context)
            : undefined,
    };
};
const deserializeAws_json1_1CreateClusterResponse = (output, context) => {
    return {
        cluster: output.cluster != null ? deserializeAws_json1_1Cluster(output.cluster, context) : undefined,
    };
};
const deserializeAws_json1_1CreateServiceResponse = (output, context) => {
    return {
        service: output.service != null ? deserializeAws_json1_1Service(output.service, context) : undefined,
    };
};
const deserializeAws_json1_1CreateTaskSetResponse = (output, context) => {
    return {
        taskSet: output.taskSet != null ? deserializeAws_json1_1TaskSet(output.taskSet, context) : undefined,
    };
};
const deserializeAws_json1_1DeleteAccountSettingResponse = (output, context) => {
    return {
        setting: output.setting != null ? deserializeAws_json1_1Setting(output.setting, context) : undefined,
    };
};
const deserializeAws_json1_1DeleteAttributesResponse = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_json1_1Attributes(output.attributes, context) : undefined,
    };
};
const deserializeAws_json1_1DeleteCapacityProviderResponse = (output, context) => {
    return {
        capacityProvider: output.capacityProvider != null
            ? deserializeAws_json1_1CapacityProvider(output.capacityProvider, context)
            : undefined,
    };
};
const deserializeAws_json1_1DeleteClusterResponse = (output, context) => {
    return {
        cluster: output.cluster != null ? deserializeAws_json1_1Cluster(output.cluster, context) : undefined,
    };
};
const deserializeAws_json1_1DeleteServiceResponse = (output, context) => {
    return {
        service: output.service != null ? deserializeAws_json1_1Service(output.service, context) : undefined,
    };
};
const deserializeAws_json1_1DeleteTaskSetResponse = (output, context) => {
    return {
        taskSet: output.taskSet != null ? deserializeAws_json1_1TaskSet(output.taskSet, context) : undefined,
    };
};
const deserializeAws_json1_1Deployment = (output, context) => {
    return {
        capacityProviderStrategy: output.capacityProviderStrategy != null
            ? deserializeAws_json1_1CapacityProviderStrategy(output.capacityProviderStrategy, context)
            : undefined,
        createdAt: output.createdAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createdAt))) : undefined,
        desiredCount: (0, smithy_client_1.expectInt32)(output.desiredCount),
        failedTasks: (0, smithy_client_1.expectInt32)(output.failedTasks),
        id: (0, smithy_client_1.expectString)(output.id),
        launchType: (0, smithy_client_1.expectString)(output.launchType),
        networkConfiguration: output.networkConfiguration != null
            ? deserializeAws_json1_1NetworkConfiguration(output.networkConfiguration, context)
            : undefined,
        pendingCount: (0, smithy_client_1.expectInt32)(output.pendingCount),
        platformFamily: (0, smithy_client_1.expectString)(output.platformFamily),
        platformVersion: (0, smithy_client_1.expectString)(output.platformVersion),
        rolloutState: (0, smithy_client_1.expectString)(output.rolloutState),
        rolloutStateReason: (0, smithy_client_1.expectString)(output.rolloutStateReason),
        runningCount: (0, smithy_client_1.expectInt32)(output.runningCount),
        serviceConnectConfiguration: output.serviceConnectConfiguration != null
            ? deserializeAws_json1_1ServiceConnectConfiguration(output.serviceConnectConfiguration, context)
            : undefined,
        serviceConnectResources: output.serviceConnectResources != null
            ? deserializeAws_json1_1ServiceConnectServiceResourceList(output.serviceConnectResources, context)
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        taskDefinition: (0, smithy_client_1.expectString)(output.taskDefinition),
        updatedAt: output.updatedAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.updatedAt))) : undefined,
    };
};
const deserializeAws_json1_1DeploymentAlarms = (output, context) => {
    return {
        alarmNames: output.alarmNames != null ? deserializeAws_json1_1StringList(output.alarmNames, context) : undefined,
        enable: (0, smithy_client_1.expectBoolean)(output.enable),
        rollback: (0, smithy_client_1.expectBoolean)(output.rollback),
    };
};
const deserializeAws_json1_1DeploymentCircuitBreaker = (output, context) => {
    return {
        enable: (0, smithy_client_1.expectBoolean)(output.enable),
        rollback: (0, smithy_client_1.expectBoolean)(output.rollback),
    };
};
const deserializeAws_json1_1DeploymentConfiguration = (output, context) => {
    return {
        alarms: output.alarms != null ? deserializeAws_json1_1DeploymentAlarms(output.alarms, context) : undefined,
        deploymentCircuitBreaker: output.deploymentCircuitBreaker != null
            ? deserializeAws_json1_1DeploymentCircuitBreaker(output.deploymentCircuitBreaker, context)
            : undefined,
        maximumPercent: (0, smithy_client_1.expectInt32)(output.maximumPercent),
        minimumHealthyPercent: (0, smithy_client_1.expectInt32)(output.minimumHealthyPercent),
    };
};
const deserializeAws_json1_1DeploymentController = (output, context) => {
    return {
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1Deployments = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Deployment(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DeregisterContainerInstanceResponse = (output, context) => {
    return {
        containerInstance: output.containerInstance != null
            ? deserializeAws_json1_1ContainerInstance(output.containerInstance, context)
            : undefined,
    };
};
const deserializeAws_json1_1DeregisterTaskDefinitionResponse = (output, context) => {
    return {
        taskDefinition: output.taskDefinition != null ? deserializeAws_json1_1TaskDefinition(output.taskDefinition, context) : undefined,
    };
};
const deserializeAws_json1_1DescribeCapacityProvidersResponse = (output, context) => {
    return {
        capacityProviders: output.capacityProviders != null
            ? deserializeAws_json1_1CapacityProviders(output.capacityProviders, context)
            : undefined,
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1DescribeClustersResponse = (output, context) => {
    return {
        clusters: output.clusters != null ? deserializeAws_json1_1Clusters(output.clusters, context) : undefined,
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
    };
};
const deserializeAws_json1_1DescribeContainerInstancesResponse = (output, context) => {
    return {
        containerInstances: output.containerInstances != null
            ? deserializeAws_json1_1ContainerInstances(output.containerInstances, context)
            : undefined,
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
    };
};
const deserializeAws_json1_1DescribeServicesResponse = (output, context) => {
    return {
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        services: output.services != null ? deserializeAws_json1_1Services(output.services, context) : undefined,
    };
};
const deserializeAws_json1_1DescribeTaskDefinitionResponse = (output, context) => {
    return {
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
        taskDefinition: output.taskDefinition != null ? deserializeAws_json1_1TaskDefinition(output.taskDefinition, context) : undefined,
    };
};
const deserializeAws_json1_1DescribeTaskSetsResponse = (output, context) => {
    return {
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        taskSets: output.taskSets != null ? deserializeAws_json1_1TaskSets(output.taskSets, context) : undefined,
    };
};
const deserializeAws_json1_1DescribeTasksResponse = (output, context) => {
    return {
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        tasks: output.tasks != null ? deserializeAws_json1_1Tasks(output.tasks, context) : undefined,
    };
};
const deserializeAws_json1_1Device = (output, context) => {
    return {
        containerPath: (0, smithy_client_1.expectString)(output.containerPath),
        hostPath: (0, smithy_client_1.expectString)(output.hostPath),
        permissions: output.permissions != null
            ? deserializeAws_json1_1DeviceCgroupPermissions(output.permissions, context)
            : undefined,
    };
};
const deserializeAws_json1_1DeviceCgroupPermissions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DevicesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Device(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DiscoverPollEndpointResponse = (output, context) => {
    return {
        endpoint: (0, smithy_client_1.expectString)(output.endpoint),
        serviceConnectEndpoint: (0, smithy_client_1.expectString)(output.serviceConnectEndpoint),
        telemetryEndpoint: (0, smithy_client_1.expectString)(output.telemetryEndpoint),
    };
};
const deserializeAws_json1_1DockerLabelsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1DockerVolumeConfiguration = (output, context) => {
    return {
        autoprovision: (0, smithy_client_1.expectBoolean)(output.autoprovision),
        driver: (0, smithy_client_1.expectString)(output.driver),
        driverOpts: output.driverOpts != null ? deserializeAws_json1_1StringMap(output.driverOpts, context) : undefined,
        labels: output.labels != null ? deserializeAws_json1_1StringMap(output.labels, context) : undefined,
        scope: (0, smithy_client_1.expectString)(output.scope),
    };
};
const deserializeAws_json1_1EFSAuthorizationConfig = (output, context) => {
    return {
        accessPointId: (0, smithy_client_1.expectString)(output.accessPointId),
        iam: (0, smithy_client_1.expectString)(output.iam),
    };
};
const deserializeAws_json1_1EFSVolumeConfiguration = (output, context) => {
    return {
        authorizationConfig: output.authorizationConfig != null
            ? deserializeAws_json1_1EFSAuthorizationConfig(output.authorizationConfig, context)
            : undefined,
        fileSystemId: (0, smithy_client_1.expectString)(output.fileSystemId),
        rootDirectory: (0, smithy_client_1.expectString)(output.rootDirectory),
        transitEncryption: (0, smithy_client_1.expectString)(output.transitEncryption),
        transitEncryptionPort: (0, smithy_client_1.expectInt32)(output.transitEncryptionPort),
    };
};
const deserializeAws_json1_1EnvironmentFile = (output, context) => {
    return {
        type: (0, smithy_client_1.expectString)(output.type),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1EnvironmentFiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1EnvironmentFile(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1EnvironmentVariables = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1KeyValuePair(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1EphemeralStorage = (output, context) => {
    return {
        sizeInGiB: (0, smithy_client_1.expectInt32)(output.sizeInGiB),
    };
};
const deserializeAws_json1_1ExecuteCommandConfiguration = (output, context) => {
    return {
        kmsKeyId: (0, smithy_client_1.expectString)(output.kmsKeyId),
        logConfiguration: output.logConfiguration != null
            ? deserializeAws_json1_1ExecuteCommandLogConfiguration(output.logConfiguration, context)
            : undefined,
        logging: (0, smithy_client_1.expectString)(output.logging),
    };
};
const deserializeAws_json1_1ExecuteCommandLogConfiguration = (output, context) => {
    return {
        cloudWatchEncryptionEnabled: (0, smithy_client_1.expectBoolean)(output.cloudWatchEncryptionEnabled),
        cloudWatchLogGroupName: (0, smithy_client_1.expectString)(output.cloudWatchLogGroupName),
        s3BucketName: (0, smithy_client_1.expectString)(output.s3BucketName),
        s3EncryptionEnabled: (0, smithy_client_1.expectBoolean)(output.s3EncryptionEnabled),
        s3KeyPrefix: (0, smithy_client_1.expectString)(output.s3KeyPrefix),
    };
};
const deserializeAws_json1_1ExecuteCommandResponse = (output, context) => {
    return {
        clusterArn: (0, smithy_client_1.expectString)(output.clusterArn),
        containerArn: (0, smithy_client_1.expectString)(output.containerArn),
        containerName: (0, smithy_client_1.expectString)(output.containerName),
        interactive: (0, smithy_client_1.expectBoolean)(output.interactive),
        session: output.session != null ? deserializeAws_json1_1Session(output.session, context) : undefined,
        taskArn: (0, smithy_client_1.expectString)(output.taskArn),
    };
};
const deserializeAws_json1_1Failure = (output, context) => {
    return {
        arn: (0, smithy_client_1.expectString)(output.arn),
        detail: (0, smithy_client_1.expectString)(output.detail),
        reason: (0, smithy_client_1.expectString)(output.reason),
    };
};
const deserializeAws_json1_1Failures = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Failure(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1FirelensConfiguration = (output, context) => {
    return {
        options: output.options != null
            ? deserializeAws_json1_1FirelensConfigurationOptionsMap(output.options, context)
            : undefined,
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1FirelensConfigurationOptionsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1FSxWindowsFileServerAuthorizationConfig = (output, context) => {
    return {
        credentialsParameter: (0, smithy_client_1.expectString)(output.credentialsParameter),
        domain: (0, smithy_client_1.expectString)(output.domain),
    };
};
const deserializeAws_json1_1FSxWindowsFileServerVolumeConfiguration = (output, context) => {
    return {
        authorizationConfig: output.authorizationConfig != null
            ? deserializeAws_json1_1FSxWindowsFileServerAuthorizationConfig(output.authorizationConfig, context)
            : undefined,
        fileSystemId: (0, smithy_client_1.expectString)(output.fileSystemId),
        rootDirectory: (0, smithy_client_1.expectString)(output.rootDirectory),
    };
};
const deserializeAws_json1_1GetTaskProtectionResponse = (output, context) => {
    return {
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        protectedTasks: output.protectedTasks != null ? deserializeAws_json1_1ProtectedTasks(output.protectedTasks, context) : undefined,
    };
};
const deserializeAws_json1_1GpuIds = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1HealthCheck = (output, context) => {
    return {
        command: output.command != null ? deserializeAws_json1_1StringList(output.command, context) : undefined,
        interval: (0, smithy_client_1.expectInt32)(output.interval),
        retries: (0, smithy_client_1.expectInt32)(output.retries),
        startPeriod: (0, smithy_client_1.expectInt32)(output.startPeriod),
        timeout: (0, smithy_client_1.expectInt32)(output.timeout),
    };
};
const deserializeAws_json1_1HostEntry = (output, context) => {
    return {
        hostname: (0, smithy_client_1.expectString)(output.hostname),
        ipAddress: (0, smithy_client_1.expectString)(output.ipAddress),
    };
};
const deserializeAws_json1_1HostEntryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1HostEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1HostVolumeProperties = (output, context) => {
    return {
        sourcePath: (0, smithy_client_1.expectString)(output.sourcePath),
    };
};
const deserializeAws_json1_1InferenceAccelerator = (output, context) => {
    return {
        deviceName: (0, smithy_client_1.expectString)(output.deviceName),
        deviceType: (0, smithy_client_1.expectString)(output.deviceType),
    };
};
const deserializeAws_json1_1InferenceAcceleratorOverride = (output, context) => {
    return {
        deviceName: (0, smithy_client_1.expectString)(output.deviceName),
        deviceType: (0, smithy_client_1.expectString)(output.deviceType),
    };
};
const deserializeAws_json1_1InferenceAcceleratorOverrides = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1InferenceAcceleratorOverride(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1InferenceAccelerators = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1InferenceAccelerator(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1InstanceHealthCheckResult = (output, context) => {
    return {
        lastStatusChange: output.lastStatusChange != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastStatusChange)))
            : undefined,
        lastUpdated: output.lastUpdated != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastUpdated)))
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1InstanceHealthCheckResultList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1InstanceHealthCheckResult(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1InvalidParameterException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1KernelCapabilities = (output, context) => {
    return {
        add: output.add != null ? deserializeAws_json1_1StringList(output.add, context) : undefined,
        drop: output.drop != null ? deserializeAws_json1_1StringList(output.drop, context) : undefined,
    };
};
const deserializeAws_json1_1KeyValuePair = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1LimitExceededException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1LinuxParameters = (output, context) => {
    return {
        capabilities: output.capabilities != null ? deserializeAws_json1_1KernelCapabilities(output.capabilities, context) : undefined,
        devices: output.devices != null ? deserializeAws_json1_1DevicesList(output.devices, context) : undefined,
        initProcessEnabled: (0, smithy_client_1.expectBoolean)(output.initProcessEnabled),
        maxSwap: (0, smithy_client_1.expectInt32)(output.maxSwap),
        sharedMemorySize: (0, smithy_client_1.expectInt32)(output.sharedMemorySize),
        swappiness: (0, smithy_client_1.expectInt32)(output.swappiness),
        tmpfs: output.tmpfs != null ? deserializeAws_json1_1TmpfsList(output.tmpfs, context) : undefined,
    };
};
const deserializeAws_json1_1ListAccountSettingsResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        settings: output.settings != null ? deserializeAws_json1_1Settings(output.settings, context) : undefined,
    };
};
const deserializeAws_json1_1ListAttributesResponse = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_json1_1Attributes(output.attributes, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListClustersResponse = (output, context) => {
    return {
        clusterArns: output.clusterArns != null ? deserializeAws_json1_1StringList(output.clusterArns, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListContainerInstancesResponse = (output, context) => {
    return {
        containerInstanceArns: output.containerInstanceArns != null
            ? deserializeAws_json1_1StringList(output.containerInstanceArns, context)
            : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListServicesByNamespaceResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        serviceArns: output.serviceArns != null ? deserializeAws_json1_1StringList(output.serviceArns, context) : undefined,
    };
};
const deserializeAws_json1_1ListServicesResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        serviceArns: output.serviceArns != null ? deserializeAws_json1_1StringList(output.serviceArns, context) : undefined,
    };
};
const deserializeAws_json1_1ListTagsForResourceResponse = (output, context) => {
    return {
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
    };
};
const deserializeAws_json1_1ListTaskDefinitionFamiliesResponse = (output, context) => {
    return {
        families: output.families != null ? deserializeAws_json1_1StringList(output.families, context) : undefined,
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
    };
};
const deserializeAws_json1_1ListTaskDefinitionsResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        taskDefinitionArns: output.taskDefinitionArns != null
            ? deserializeAws_json1_1StringList(output.taskDefinitionArns, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListTasksResponse = (output, context) => {
    return {
        nextToken: (0, smithy_client_1.expectString)(output.nextToken),
        taskArns: output.taskArns != null ? deserializeAws_json1_1StringList(output.taskArns, context) : undefined,
    };
};
const deserializeAws_json1_1LoadBalancer = (output, context) => {
    return {
        containerName: (0, smithy_client_1.expectString)(output.containerName),
        containerPort: (0, smithy_client_1.expectInt32)(output.containerPort),
        loadBalancerName: (0, smithy_client_1.expectString)(output.loadBalancerName),
        targetGroupArn: (0, smithy_client_1.expectString)(output.targetGroupArn),
    };
};
const deserializeAws_json1_1LoadBalancers = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1LoadBalancer(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1LogConfiguration = (output, context) => {
    return {
        logDriver: (0, smithy_client_1.expectString)(output.logDriver),
        options: output.options != null ? deserializeAws_json1_1LogConfigurationOptionsMap(output.options, context) : undefined,
        secretOptions: output.secretOptions != null ? deserializeAws_json1_1SecretList(output.secretOptions, context) : undefined,
    };
};
const deserializeAws_json1_1LogConfigurationOptionsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1ManagedAgent = (output, context) => {
    return {
        lastStartedAt: output.lastStartedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.lastStartedAt)))
            : undefined,
        lastStatus: (0, smithy_client_1.expectString)(output.lastStatus),
        name: (0, smithy_client_1.expectString)(output.name),
        reason: (0, smithy_client_1.expectString)(output.reason),
    };
};
const deserializeAws_json1_1ManagedAgents = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ManagedAgent(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ManagedScaling = (output, context) => {
    return {
        instanceWarmupPeriod: (0, smithy_client_1.expectInt32)(output.instanceWarmupPeriod),
        maximumScalingStepSize: (0, smithy_client_1.expectInt32)(output.maximumScalingStepSize),
        minimumScalingStepSize: (0, smithy_client_1.expectInt32)(output.minimumScalingStepSize),
        status: (0, smithy_client_1.expectString)(output.status),
        targetCapacity: (0, smithy_client_1.expectInt32)(output.targetCapacity),
    };
};
const deserializeAws_json1_1MissingVersionException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1MountPoint = (output, context) => {
    return {
        containerPath: (0, smithy_client_1.expectString)(output.containerPath),
        readOnly: (0, smithy_client_1.expectBoolean)(output.readOnly),
        sourceVolume: (0, smithy_client_1.expectString)(output.sourceVolume),
    };
};
const deserializeAws_json1_1MountPointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MountPoint(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1NamespaceNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1NetworkBinding = (output, context) => {
    return {
        bindIP: (0, smithy_client_1.expectString)(output.bindIP),
        containerPort: (0, smithy_client_1.expectInt32)(output.containerPort),
        containerPortRange: (0, smithy_client_1.expectString)(output.containerPortRange),
        hostPort: (0, smithy_client_1.expectInt32)(output.hostPort),
        hostPortRange: (0, smithy_client_1.expectString)(output.hostPortRange),
        protocol: (0, smithy_client_1.expectString)(output.protocol),
    };
};
const deserializeAws_json1_1NetworkBindings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1NetworkBinding(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1NetworkConfiguration = (output, context) => {
    return {
        awsvpcConfiguration: output.awsvpcConfiguration != null
            ? deserializeAws_json1_1AwsVpcConfiguration(output.awsvpcConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_1NetworkInterface = (output, context) => {
    return {
        attachmentId: (0, smithy_client_1.expectString)(output.attachmentId),
        ipv6Address: (0, smithy_client_1.expectString)(output.ipv6Address),
        privateIpv4Address: (0, smithy_client_1.expectString)(output.privateIpv4Address),
    };
};
const deserializeAws_json1_1NetworkInterfaces = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1NetworkInterface(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1NoUpdateAvailableException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1PlacementConstraint = (output, context) => {
    return {
        expression: (0, smithy_client_1.expectString)(output.expression),
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1PlacementConstraints = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PlacementConstraint(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PlacementStrategies = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PlacementStrategy(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PlacementStrategy = (output, context) => {
    return {
        field: (0, smithy_client_1.expectString)(output.field),
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1PlatformTaskDefinitionIncompatibilityException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1PlatformUnknownException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1PortMapping = (output, context) => {
    return {
        appProtocol: (0, smithy_client_1.expectString)(output.appProtocol),
        containerPort: (0, smithy_client_1.expectInt32)(output.containerPort),
        containerPortRange: (0, smithy_client_1.expectString)(output.containerPortRange),
        hostPort: (0, smithy_client_1.expectInt32)(output.hostPort),
        name: (0, smithy_client_1.expectString)(output.name),
        protocol: (0, smithy_client_1.expectString)(output.protocol),
    };
};
const deserializeAws_json1_1PortMappingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PortMapping(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ProtectedTask = (output, context) => {
    return {
        expirationDate: output.expirationDate != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.expirationDate)))
            : undefined,
        protectionEnabled: (0, smithy_client_1.expectBoolean)(output.protectionEnabled),
        taskArn: (0, smithy_client_1.expectString)(output.taskArn),
    };
};
const deserializeAws_json1_1ProtectedTasks = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ProtectedTask(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ProxyConfiguration = (output, context) => {
    return {
        containerName: (0, smithy_client_1.expectString)(output.containerName),
        properties: output.properties != null
            ? deserializeAws_json1_1ProxyConfigurationProperties(output.properties, context)
            : undefined,
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1ProxyConfigurationProperties = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1KeyValuePair(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PutAccountSettingDefaultResponse = (output, context) => {
    return {
        setting: output.setting != null ? deserializeAws_json1_1Setting(output.setting, context) : undefined,
    };
};
const deserializeAws_json1_1PutAccountSettingResponse = (output, context) => {
    return {
        setting: output.setting != null ? deserializeAws_json1_1Setting(output.setting, context) : undefined,
    };
};
const deserializeAws_json1_1PutAttributesResponse = (output, context) => {
    return {
        attributes: output.attributes != null ? deserializeAws_json1_1Attributes(output.attributes, context) : undefined,
    };
};
const deserializeAws_json1_1PutClusterCapacityProvidersResponse = (output, context) => {
    return {
        cluster: output.cluster != null ? deserializeAws_json1_1Cluster(output.cluster, context) : undefined,
    };
};
const deserializeAws_json1_1RegisterContainerInstanceResponse = (output, context) => {
    return {
        containerInstance: output.containerInstance != null
            ? deserializeAws_json1_1ContainerInstance(output.containerInstance, context)
            : undefined,
    };
};
const deserializeAws_json1_1RegisterTaskDefinitionResponse = (output, context) => {
    return {
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
        taskDefinition: output.taskDefinition != null ? deserializeAws_json1_1TaskDefinition(output.taskDefinition, context) : undefined,
    };
};
const deserializeAws_json1_1RepositoryCredentials = (output, context) => {
    return {
        credentialsParameter: (0, smithy_client_1.expectString)(output.credentialsParameter),
    };
};
const deserializeAws_json1_1RequiresAttributes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Attribute(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Resource = (output, context) => {
    return {
        doubleValue: (0, smithy_client_1.limitedParseDouble)(output.doubleValue),
        integerValue: (0, smithy_client_1.expectInt32)(output.integerValue),
        longValue: (0, smithy_client_1.expectLong)(output.longValue),
        name: (0, smithy_client_1.expectString)(output.name),
        stringSetValue: output.stringSetValue != null ? deserializeAws_json1_1StringList(output.stringSetValue, context) : undefined,
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1ResourceInUseException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ResourceNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ResourceRequirement = (output, context) => {
    return {
        type: (0, smithy_client_1.expectString)(output.type),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1ResourceRequirements = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ResourceRequirement(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Resources = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Resource(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1RunTaskResponse = (output, context) => {
    return {
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        tasks: output.tasks != null ? deserializeAws_json1_1Tasks(output.tasks, context) : undefined,
    };
};
const deserializeAws_json1_1RuntimePlatform = (output, context) => {
    return {
        cpuArchitecture: (0, smithy_client_1.expectString)(output.cpuArchitecture),
        operatingSystemFamily: (0, smithy_client_1.expectString)(output.operatingSystemFamily),
    };
};
const deserializeAws_json1_1Scale = (output, context) => {
    return {
        unit: (0, smithy_client_1.expectString)(output.unit),
        value: (0, smithy_client_1.limitedParseDouble)(output.value),
    };
};
const deserializeAws_json1_1Secret = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
        valueFrom: (0, smithy_client_1.expectString)(output.valueFrom),
    };
};
const deserializeAws_json1_1SecretList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Secret(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ServerException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1Service = (output, context) => {
    return {
        capacityProviderStrategy: output.capacityProviderStrategy != null
            ? deserializeAws_json1_1CapacityProviderStrategy(output.capacityProviderStrategy, context)
            : undefined,
        clusterArn: (0, smithy_client_1.expectString)(output.clusterArn),
        createdAt: output.createdAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createdAt))) : undefined,
        createdBy: (0, smithy_client_1.expectString)(output.createdBy),
        deploymentConfiguration: output.deploymentConfiguration != null
            ? deserializeAws_json1_1DeploymentConfiguration(output.deploymentConfiguration, context)
            : undefined,
        deploymentController: output.deploymentController != null
            ? deserializeAws_json1_1DeploymentController(output.deploymentController, context)
            : undefined,
        deployments: output.deployments != null ? deserializeAws_json1_1Deployments(output.deployments, context) : undefined,
        desiredCount: (0, smithy_client_1.expectInt32)(output.desiredCount),
        enableECSManagedTags: (0, smithy_client_1.expectBoolean)(output.enableECSManagedTags),
        enableExecuteCommand: (0, smithy_client_1.expectBoolean)(output.enableExecuteCommand),
        events: output.events != null ? deserializeAws_json1_1ServiceEvents(output.events, context) : undefined,
        healthCheckGracePeriodSeconds: (0, smithy_client_1.expectInt32)(output.healthCheckGracePeriodSeconds),
        launchType: (0, smithy_client_1.expectString)(output.launchType),
        loadBalancers: output.loadBalancers != null ? deserializeAws_json1_1LoadBalancers(output.loadBalancers, context) : undefined,
        networkConfiguration: output.networkConfiguration != null
            ? deserializeAws_json1_1NetworkConfiguration(output.networkConfiguration, context)
            : undefined,
        pendingCount: (0, smithy_client_1.expectInt32)(output.pendingCount),
        placementConstraints: output.placementConstraints != null
            ? deserializeAws_json1_1PlacementConstraints(output.placementConstraints, context)
            : undefined,
        placementStrategy: output.placementStrategy != null
            ? deserializeAws_json1_1PlacementStrategies(output.placementStrategy, context)
            : undefined,
        platformFamily: (0, smithy_client_1.expectString)(output.platformFamily),
        platformVersion: (0, smithy_client_1.expectString)(output.platformVersion),
        propagateTags: (0, smithy_client_1.expectString)(output.propagateTags),
        roleArn: (0, smithy_client_1.expectString)(output.roleArn),
        runningCount: (0, smithy_client_1.expectInt32)(output.runningCount),
        schedulingStrategy: (0, smithy_client_1.expectString)(output.schedulingStrategy),
        serviceArn: (0, smithy_client_1.expectString)(output.serviceArn),
        serviceName: (0, smithy_client_1.expectString)(output.serviceName),
        serviceRegistries: output.serviceRegistries != null
            ? deserializeAws_json1_1ServiceRegistries(output.serviceRegistries, context)
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
        taskDefinition: (0, smithy_client_1.expectString)(output.taskDefinition),
        taskSets: output.taskSets != null ? deserializeAws_json1_1TaskSets(output.taskSets, context) : undefined,
    };
};
const deserializeAws_json1_1ServiceConnectClientAlias = (output, context) => {
    return {
        dnsName: (0, smithy_client_1.expectString)(output.dnsName),
        port: (0, smithy_client_1.expectInt32)(output.port),
    };
};
const deserializeAws_json1_1ServiceConnectClientAliasList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ServiceConnectClientAlias(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ServiceConnectConfiguration = (output, context) => {
    return {
        enabled: (0, smithy_client_1.expectBoolean)(output.enabled),
        logConfiguration: output.logConfiguration != null
            ? deserializeAws_json1_1LogConfiguration(output.logConfiguration, context)
            : undefined,
        namespace: (0, smithy_client_1.expectString)(output.namespace),
        services: output.services != null ? deserializeAws_json1_1ServiceConnectServiceList(output.services, context) : undefined,
    };
};
const deserializeAws_json1_1ServiceConnectService = (output, context) => {
    return {
        clientAliases: output.clientAliases != null
            ? deserializeAws_json1_1ServiceConnectClientAliasList(output.clientAliases, context)
            : undefined,
        discoveryName: (0, smithy_client_1.expectString)(output.discoveryName),
        ingressPortOverride: (0, smithy_client_1.expectInt32)(output.ingressPortOverride),
        portName: (0, smithy_client_1.expectString)(output.portName),
    };
};
const deserializeAws_json1_1ServiceConnectServiceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ServiceConnectService(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ServiceConnectServiceResource = (output, context) => {
    return {
        discoveryArn: (0, smithy_client_1.expectString)(output.discoveryArn),
        discoveryName: (0, smithy_client_1.expectString)(output.discoveryName),
    };
};
const deserializeAws_json1_1ServiceConnectServiceResourceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ServiceConnectServiceResource(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ServiceEvent = (output, context) => {
    return {
        createdAt: output.createdAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createdAt))) : undefined,
        id: (0, smithy_client_1.expectString)(output.id),
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ServiceEvents = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ServiceEvent(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ServiceNotActiveException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ServiceNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1ServiceRegistries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ServiceRegistry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ServiceRegistry = (output, context) => {
    return {
        containerName: (0, smithy_client_1.expectString)(output.containerName),
        containerPort: (0, smithy_client_1.expectInt32)(output.containerPort),
        port: (0, smithy_client_1.expectInt32)(output.port),
        registryArn: (0, smithy_client_1.expectString)(output.registryArn),
    };
};
const deserializeAws_json1_1Services = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Service(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Session = (output, context) => {
    return {
        sessionId: (0, smithy_client_1.expectString)(output.sessionId),
        streamUrl: (0, smithy_client_1.expectString)(output.streamUrl),
        tokenValue: (0, smithy_client_1.expectString)(output.tokenValue),
    };
};
const deserializeAws_json1_1Setting = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
        principalArn: (0, smithy_client_1.expectString)(output.principalArn),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1Settings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Setting(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1StartTaskResponse = (output, context) => {
    return {
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        tasks: output.tasks != null ? deserializeAws_json1_1Tasks(output.tasks, context) : undefined,
    };
};
const deserializeAws_json1_1Statistics = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1KeyValuePair(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1StopTaskResponse = (output, context) => {
    return {
        task: output.task != null ? deserializeAws_json1_1Task(output.task, context) : undefined,
    };
};
const deserializeAws_json1_1StringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return (0, smithy_client_1.expectString)(entry);
    });
    return retVal;
};
const deserializeAws_json1_1StringMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = (0, smithy_client_1.expectString)(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1SubmitAttachmentStateChangesResponse = (output, context) => {
    return {
        acknowledgment: (0, smithy_client_1.expectString)(output.acknowledgment),
    };
};
const deserializeAws_json1_1SubmitContainerStateChangeResponse = (output, context) => {
    return {
        acknowledgment: (0, smithy_client_1.expectString)(output.acknowledgment),
    };
};
const deserializeAws_json1_1SubmitTaskStateChangeResponse = (output, context) => {
    return {
        acknowledgment: (0, smithy_client_1.expectString)(output.acknowledgment),
    };
};
const deserializeAws_json1_1SystemControl = (output, context) => {
    return {
        namespace: (0, smithy_client_1.expectString)(output.namespace),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1SystemControls = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SystemControl(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Tag = (output, context) => {
    return {
        key: (0, smithy_client_1.expectString)(output.key),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_json1_1TagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1Tags = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Tag(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TargetNotConnectedException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1TargetNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1Task = (output, context) => {
    return {
        attachments: output.attachments != null ? deserializeAws_json1_1Attachments(output.attachments, context) : undefined,
        attributes: output.attributes != null ? deserializeAws_json1_1Attributes(output.attributes, context) : undefined,
        availabilityZone: (0, smithy_client_1.expectString)(output.availabilityZone),
        capacityProviderName: (0, smithy_client_1.expectString)(output.capacityProviderName),
        clusterArn: (0, smithy_client_1.expectString)(output.clusterArn),
        connectivity: (0, smithy_client_1.expectString)(output.connectivity),
        connectivityAt: output.connectivityAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.connectivityAt)))
            : undefined,
        containerInstanceArn: (0, smithy_client_1.expectString)(output.containerInstanceArn),
        containers: output.containers != null ? deserializeAws_json1_1Containers(output.containers, context) : undefined,
        cpu: (0, smithy_client_1.expectString)(output.cpu),
        createdAt: output.createdAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createdAt))) : undefined,
        desiredStatus: (0, smithy_client_1.expectString)(output.desiredStatus),
        enableExecuteCommand: (0, smithy_client_1.expectBoolean)(output.enableExecuteCommand),
        ephemeralStorage: output.ephemeralStorage != null
            ? deserializeAws_json1_1EphemeralStorage(output.ephemeralStorage, context)
            : undefined,
        executionStoppedAt: output.executionStoppedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.executionStoppedAt)))
            : undefined,
        group: (0, smithy_client_1.expectString)(output.group),
        healthStatus: (0, smithy_client_1.expectString)(output.healthStatus),
        inferenceAccelerators: output.inferenceAccelerators != null
            ? deserializeAws_json1_1InferenceAccelerators(output.inferenceAccelerators, context)
            : undefined,
        lastStatus: (0, smithy_client_1.expectString)(output.lastStatus),
        launchType: (0, smithy_client_1.expectString)(output.launchType),
        memory: (0, smithy_client_1.expectString)(output.memory),
        overrides: output.overrides != null ? deserializeAws_json1_1TaskOverride(output.overrides, context) : undefined,
        platformFamily: (0, smithy_client_1.expectString)(output.platformFamily),
        platformVersion: (0, smithy_client_1.expectString)(output.platformVersion),
        pullStartedAt: output.pullStartedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.pullStartedAt)))
            : undefined,
        pullStoppedAt: output.pullStoppedAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.pullStoppedAt)))
            : undefined,
        startedAt: output.startedAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.startedAt))) : undefined,
        startedBy: (0, smithy_client_1.expectString)(output.startedBy),
        stopCode: (0, smithy_client_1.expectString)(output.stopCode),
        stoppedAt: output.stoppedAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.stoppedAt))) : undefined,
        stoppedReason: (0, smithy_client_1.expectString)(output.stoppedReason),
        stoppingAt: output.stoppingAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.stoppingAt))) : undefined,
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
        taskArn: (0, smithy_client_1.expectString)(output.taskArn),
        taskDefinitionArn: (0, smithy_client_1.expectString)(output.taskDefinitionArn),
        version: (0, smithy_client_1.expectLong)(output.version),
    };
};
const deserializeAws_json1_1TaskDefinition = (output, context) => {
    return {
        compatibilities: output.compatibilities != null
            ? deserializeAws_json1_1CompatibilityList(output.compatibilities, context)
            : undefined,
        containerDefinitions: output.containerDefinitions != null
            ? deserializeAws_json1_1ContainerDefinitions(output.containerDefinitions, context)
            : undefined,
        cpu: (0, smithy_client_1.expectString)(output.cpu),
        deregisteredAt: output.deregisteredAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.deregisteredAt)))
            : undefined,
        ephemeralStorage: output.ephemeralStorage != null
            ? deserializeAws_json1_1EphemeralStorage(output.ephemeralStorage, context)
            : undefined,
        executionRoleArn: (0, smithy_client_1.expectString)(output.executionRoleArn),
        family: (0, smithy_client_1.expectString)(output.family),
        inferenceAccelerators: output.inferenceAccelerators != null
            ? deserializeAws_json1_1InferenceAccelerators(output.inferenceAccelerators, context)
            : undefined,
        ipcMode: (0, smithy_client_1.expectString)(output.ipcMode),
        memory: (0, smithy_client_1.expectString)(output.memory),
        networkMode: (0, smithy_client_1.expectString)(output.networkMode),
        pidMode: (0, smithy_client_1.expectString)(output.pidMode),
        placementConstraints: output.placementConstraints != null
            ? deserializeAws_json1_1TaskDefinitionPlacementConstraints(output.placementConstraints, context)
            : undefined,
        proxyConfiguration: output.proxyConfiguration != null
            ? deserializeAws_json1_1ProxyConfiguration(output.proxyConfiguration, context)
            : undefined,
        registeredAt: output.registeredAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.registeredAt)))
            : undefined,
        registeredBy: (0, smithy_client_1.expectString)(output.registeredBy),
        requiresAttributes: output.requiresAttributes != null
            ? deserializeAws_json1_1RequiresAttributes(output.requiresAttributes, context)
            : undefined,
        requiresCompatibilities: output.requiresCompatibilities != null
            ? deserializeAws_json1_1CompatibilityList(output.requiresCompatibilities, context)
            : undefined,
        revision: (0, smithy_client_1.expectInt32)(output.revision),
        runtimePlatform: output.runtimePlatform != null
            ? deserializeAws_json1_1RuntimePlatform(output.runtimePlatform, context)
            : undefined,
        status: (0, smithy_client_1.expectString)(output.status),
        taskDefinitionArn: (0, smithy_client_1.expectString)(output.taskDefinitionArn),
        taskRoleArn: (0, smithy_client_1.expectString)(output.taskRoleArn),
        volumes: output.volumes != null ? deserializeAws_json1_1VolumeList(output.volumes, context) : undefined,
    };
};
const deserializeAws_json1_1TaskDefinitionPlacementConstraint = (output, context) => {
    return {
        expression: (0, smithy_client_1.expectString)(output.expression),
        type: (0, smithy_client_1.expectString)(output.type),
    };
};
const deserializeAws_json1_1TaskDefinitionPlacementConstraints = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TaskDefinitionPlacementConstraint(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TaskOverride = (output, context) => {
    return {
        containerOverrides: output.containerOverrides != null
            ? deserializeAws_json1_1ContainerOverrides(output.containerOverrides, context)
            : undefined,
        cpu: (0, smithy_client_1.expectString)(output.cpu),
        ephemeralStorage: output.ephemeralStorage != null
            ? deserializeAws_json1_1EphemeralStorage(output.ephemeralStorage, context)
            : undefined,
        executionRoleArn: (0, smithy_client_1.expectString)(output.executionRoleArn),
        inferenceAcceleratorOverrides: output.inferenceAcceleratorOverrides != null
            ? deserializeAws_json1_1InferenceAcceleratorOverrides(output.inferenceAcceleratorOverrides, context)
            : undefined,
        memory: (0, smithy_client_1.expectString)(output.memory),
        taskRoleArn: (0, smithy_client_1.expectString)(output.taskRoleArn),
    };
};
const deserializeAws_json1_1Tasks = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Task(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TaskSet = (output, context) => {
    return {
        capacityProviderStrategy: output.capacityProviderStrategy != null
            ? deserializeAws_json1_1CapacityProviderStrategy(output.capacityProviderStrategy, context)
            : undefined,
        clusterArn: (0, smithy_client_1.expectString)(output.clusterArn),
        computedDesiredCount: (0, smithy_client_1.expectInt32)(output.computedDesiredCount),
        createdAt: output.createdAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createdAt))) : undefined,
        externalId: (0, smithy_client_1.expectString)(output.externalId),
        id: (0, smithy_client_1.expectString)(output.id),
        launchType: (0, smithy_client_1.expectString)(output.launchType),
        loadBalancers: output.loadBalancers != null ? deserializeAws_json1_1LoadBalancers(output.loadBalancers, context) : undefined,
        networkConfiguration: output.networkConfiguration != null
            ? deserializeAws_json1_1NetworkConfiguration(output.networkConfiguration, context)
            : undefined,
        pendingCount: (0, smithy_client_1.expectInt32)(output.pendingCount),
        platformFamily: (0, smithy_client_1.expectString)(output.platformFamily),
        platformVersion: (0, smithy_client_1.expectString)(output.platformVersion),
        runningCount: (0, smithy_client_1.expectInt32)(output.runningCount),
        scale: output.scale != null ? deserializeAws_json1_1Scale(output.scale, context) : undefined,
        serviceArn: (0, smithy_client_1.expectString)(output.serviceArn),
        serviceRegistries: output.serviceRegistries != null
            ? deserializeAws_json1_1ServiceRegistries(output.serviceRegistries, context)
            : undefined,
        stabilityStatus: (0, smithy_client_1.expectString)(output.stabilityStatus),
        stabilityStatusAt: output.stabilityStatusAt != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.stabilityStatusAt)))
            : undefined,
        startedBy: (0, smithy_client_1.expectString)(output.startedBy),
        status: (0, smithy_client_1.expectString)(output.status),
        tags: output.tags != null ? deserializeAws_json1_1Tags(output.tags, context) : undefined,
        taskDefinition: (0, smithy_client_1.expectString)(output.taskDefinition),
        taskSetArn: (0, smithy_client_1.expectString)(output.taskSetArn),
        updatedAt: output.updatedAt != null ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.updatedAt))) : undefined,
    };
};
const deserializeAws_json1_1TaskSetNotFoundException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1TaskSets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TaskSet(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Tmpfs = (output, context) => {
    return {
        containerPath: (0, smithy_client_1.expectString)(output.containerPath),
        mountOptions: output.mountOptions != null ? deserializeAws_json1_1StringList(output.mountOptions, context) : undefined,
        size: (0, smithy_client_1.expectInt32)(output.size),
    };
};
const deserializeAws_json1_1TmpfsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Tmpfs(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Ulimit = (output, context) => {
    return {
        hardLimit: (0, smithy_client_1.expectInt32)(output.hardLimit),
        name: (0, smithy_client_1.expectString)(output.name),
        softLimit: (0, smithy_client_1.expectInt32)(output.softLimit),
    };
};
const deserializeAws_json1_1UlimitList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Ulimit(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1UnsupportedFeatureException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1UntagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateCapacityProviderResponse = (output, context) => {
    return {
        capacityProvider: output.capacityProvider != null
            ? deserializeAws_json1_1CapacityProvider(output.capacityProvider, context)
            : undefined,
    };
};
const deserializeAws_json1_1UpdateClusterResponse = (output, context) => {
    return {
        cluster: output.cluster != null ? deserializeAws_json1_1Cluster(output.cluster, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateClusterSettingsResponse = (output, context) => {
    return {
        cluster: output.cluster != null ? deserializeAws_json1_1Cluster(output.cluster, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateContainerAgentResponse = (output, context) => {
    return {
        containerInstance: output.containerInstance != null
            ? deserializeAws_json1_1ContainerInstance(output.containerInstance, context)
            : undefined,
    };
};
const deserializeAws_json1_1UpdateContainerInstancesStateResponse = (output, context) => {
    return {
        containerInstances: output.containerInstances != null
            ? deserializeAws_json1_1ContainerInstances(output.containerInstances, context)
            : undefined,
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateInProgressException = (output, context) => {
    return {
        message: (0, smithy_client_1.expectString)(output.message),
    };
};
const deserializeAws_json1_1UpdateServicePrimaryTaskSetResponse = (output, context) => {
    return {
        taskSet: output.taskSet != null ? deserializeAws_json1_1TaskSet(output.taskSet, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateServiceResponse = (output, context) => {
    return {
        service: output.service != null ? deserializeAws_json1_1Service(output.service, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateTaskProtectionResponse = (output, context) => {
    return {
        failures: output.failures != null ? deserializeAws_json1_1Failures(output.failures, context) : undefined,
        protectedTasks: output.protectedTasks != null ? deserializeAws_json1_1ProtectedTasks(output.protectedTasks, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateTaskSetResponse = (output, context) => {
    return {
        taskSet: output.taskSet != null ? deserializeAws_json1_1TaskSet(output.taskSet, context) : undefined,
    };
};
const deserializeAws_json1_1VersionInfo = (output, context) => {
    return {
        agentHash: (0, smithy_client_1.expectString)(output.agentHash),
        agentVersion: (0, smithy_client_1.expectString)(output.agentVersion),
        dockerVersion: (0, smithy_client_1.expectString)(output.dockerVersion),
    };
};
const deserializeAws_json1_1Volume = (output, context) => {
    return {
        dockerVolumeConfiguration: output.dockerVolumeConfiguration != null
            ? deserializeAws_json1_1DockerVolumeConfiguration(output.dockerVolumeConfiguration, context)
            : undefined,
        efsVolumeConfiguration: output.efsVolumeConfiguration != null
            ? deserializeAws_json1_1EFSVolumeConfiguration(output.efsVolumeConfiguration, context)
            : undefined,
        fsxWindowsFileServerVolumeConfiguration: output.fsxWindowsFileServerVolumeConfiguration != null
            ? deserializeAws_json1_1FSxWindowsFileServerVolumeConfiguration(output.fsxWindowsFileServerVolumeConfiguration, context)
            : undefined,
        host: output.host != null ? deserializeAws_json1_1HostVolumeProperties(output.host, context) : undefined,
        name: (0, smithy_client_1.expectString)(output.name),
    };
};
const deserializeAws_json1_1VolumeFrom = (output, context) => {
    return {
        readOnly: (0, smithy_client_1.expectBoolean)(output.readOnly),
        sourceContainer: (0, smithy_client_1.expectString)(output.sourceContainer),
    };
};
const deserializeAws_json1_1VolumeFromList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1VolumeFrom(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1VolumeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Volume(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 47246:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(95223));
const client_sts_1 = __nccwpck_require__(52209);
const config_resolver_1 = __nccwpck_require__(56153);
const credential_provider_node_1 = __nccwpck_require__(75531);
const hash_node_1 = __nccwpck_require__(97442);
const middleware_retry_1 = __nccwpck_require__(96064);
const node_config_provider_1 = __nccwpck_require__(87684);
const node_http_handler_1 = __nccwpck_require__(68805);
const util_body_length_node_1 = __nccwpck_require__(74147);
const util_retry_1 = __nccwpck_require__(99395);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const util_utf8_node_1 = __nccwpck_require__(66278);
const runtimeConfig_shared_1 = __nccwpck_require__(94516);
const smithy_client_1 = __nccwpck_require__(4963);
const util_defaults_mode_node_1 = __nccwpck_require__(74243);
const smithy_client_2 = __nccwpck_require__(4963);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        utf8Decoder: config?.utf8Decoder ?? util_utf8_node_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_node_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 94516:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const url_parser_1 = __nccwpck_require__(2992);
const util_base64_1 = __nccwpck_require__(97727);
const endpointResolver_1 = __nccwpck_require__(55021);
const getRuntimeConfig = (config) => ({
    apiVersion: "2014-11-13",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "ECS",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 64379:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(95853), exports);
tslib_1.__exportStar(__nccwpck_require__(39606), exports);
tslib_1.__exportStar(__nccwpck_require__(43464), exports);
tslib_1.__exportStar(__nccwpck_require__(41497), exports);


/***/ }),

/***/ 95853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilServicesInactive = exports.waitForServicesInactive = void 0;
const util_waiter_1 = __nccwpck_require__(21627);
const DescribeServicesCommand_1 = __nccwpck_require__(1000);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new DescribeServicesCommand_1.DescribeServicesCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.failures);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.reason;
                });
                return projection_3;
            };
            for (const anyStringEq_4 of returnComparator()) {
                if (anyStringEq_4 == "MISSING") {
                    return { state: util_waiter_1.WaiterState.FAILURE, reason };
                }
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.services);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.status;
                });
                return projection_3;
            };
            for (const anyStringEq_4 of returnComparator()) {
                if (anyStringEq_4 == "INACTIVE") {
                    return { state: util_waiter_1.WaiterState.SUCCESS, reason };
                }
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForServicesInactive = async (params, input) => {
    const serviceDefaults = { minDelay: 15, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForServicesInactive = waitForServicesInactive;
const waitUntilServicesInactive = async (params, input) => {
    const serviceDefaults = { minDelay: 15, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilServicesInactive = waitUntilServicesInactive;


/***/ }),

/***/ 39606:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilServicesStable = exports.waitForServicesStable = void 0;
const util_waiter_1 = __nccwpck_require__(21627);
const DescribeServicesCommand_1 = __nccwpck_require__(1000);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new DescribeServicesCommand_1.DescribeServicesCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.failures);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.reason;
                });
                return projection_3;
            };
            for (const anyStringEq_4 of returnComparator()) {
                if (anyStringEq_4 == "MISSING") {
                    return { state: util_waiter_1.WaiterState.FAILURE, reason };
                }
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.services);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.status;
                });
                return projection_3;
            };
            for (const anyStringEq_4 of returnComparator()) {
                if (anyStringEq_4 == "DRAINING") {
                    return { state: util_waiter_1.WaiterState.FAILURE, reason };
                }
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.services);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.status;
                });
                return projection_3;
            };
            for (const anyStringEq_4 of returnComparator()) {
                if (anyStringEq_4 == "INACTIVE") {
                    return { state: util_waiter_1.WaiterState.FAILURE, reason };
                }
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                const filterRes_2 = result.services.filter((element_1) => {
                    return !(element_1.deployments.length == 1.0 && element_1.runningCount == element_1.desiredCount);
                });
                return filterRes_2.length == 0.0;
            };
            if (returnComparator() == true) {
                return { state: util_waiter_1.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForServicesStable = async (params, input) => {
    const serviceDefaults = { minDelay: 15, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForServicesStable = waitForServicesStable;
const waitUntilServicesStable = async (params, input) => {
    const serviceDefaults = { minDelay: 15, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilServicesStable = waitUntilServicesStable;


/***/ }),

/***/ 43464:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilTasksRunning = exports.waitForTasksRunning = void 0;
const util_waiter_1 = __nccwpck_require__(21627);
const DescribeTasksCommand_1 = __nccwpck_require__(59793);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new DescribeTasksCommand_1.DescribeTasksCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.tasks);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.lastStatus;
                });
                return projection_3;
            };
            for (const anyStringEq_4 of returnComparator()) {
                if (anyStringEq_4 == "STOPPED") {
                    return { state: util_waiter_1.WaiterState.FAILURE, reason };
                }
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.failures);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.reason;
                });
                return projection_3;
            };
            for (const anyStringEq_4 of returnComparator()) {
                if (anyStringEq_4 == "MISSING") {
                    return { state: util_waiter_1.WaiterState.FAILURE, reason };
                }
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.tasks);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.lastStatus;
                });
                return projection_3;
            };
            let allStringEq_5 = returnComparator().length > 0;
            for (const element_4 of returnComparator()) {
                allStringEq_5 = allStringEq_5 && element_4 == "RUNNING";
            }
            if (allStringEq_5) {
                return { state: util_waiter_1.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForTasksRunning = async (params, input) => {
    const serviceDefaults = { minDelay: 6, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForTasksRunning = waitForTasksRunning;
const waitUntilTasksRunning = async (params, input) => {
    const serviceDefaults = { minDelay: 6, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilTasksRunning = waitUntilTasksRunning;


/***/ }),

/***/ 41497:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilTasksStopped = exports.waitForTasksStopped = void 0;
const util_waiter_1 = __nccwpck_require__(21627);
const DescribeTasksCommand_1 = __nccwpck_require__(59793);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new DescribeTasksCommand_1.DescribeTasksCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                const flat_1 = [].concat(...result.tasks);
                const projection_3 = flat_1.map((element_2) => {
                    return element_2.lastStatus;
                });
                return projection_3;
            };
            let allStringEq_5 = returnComparator().length > 0;
            for (const element_4 of returnComparator()) {
                allStringEq_5 = allStringEq_5 && element_4 == "STOPPED";
            }
            if (allStringEq_5) {
                return { state: util_waiter_1.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForTasksStopped = async (params, input) => {
    const serviceDefaults = { minDelay: 6, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForTasksStopped = waitForTasksStopped;
const waitUntilTasksStopped = async (params, input) => {
    const serviceDefaults = { minDelay: 6, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilTasksStopped = waitUntilTasksStopped;


/***/ }),

/***/ 17124:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDC = void 0;
const CreateTokenCommand_1 = __nccwpck_require__(62853);
const RegisterClientCommand_1 = __nccwpck_require__(36677);
const StartDeviceAuthorizationCommand_1 = __nccwpck_require__(38359);
const SSOOIDCClient_1 = __nccwpck_require__(70139);
class SSOOIDC extends SSOOIDCClient_1.SSOOIDCClient {
    createToken(args, optionsOrCb, cb) {
        const command = new CreateTokenCommand_1.CreateTokenCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    registerClient(args, optionsOrCb, cb) {
        const command = new RegisterClientCommand_1.RegisterClientCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    startDeviceAuthorization(args, optionsOrCb, cb) {
        const command = new StartDeviceAuthorizationCommand_1.StartDeviceAuthorizationCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
}
exports.SSOOIDC = SSOOIDC;


/***/ }),

/***/ 70139:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDCClient = void 0;
const config_resolver_1 = __nccwpck_require__(56153);
const middleware_content_length_1 = __nccwpck_require__(42245);
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_retry_1 = __nccwpck_require__(96064);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const smithy_client_1 = __nccwpck_require__(4963);
const EndpointParameters_1 = __nccwpck_require__(61426);
const runtimeConfig_1 = __nccwpck_require__(25524);
class SSOOIDCClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        super(_config_6);
        this.config = _config_6;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.SSOOIDCClient = SSOOIDCClient;


/***/ }),

/***/ 62853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTokenCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(69374);
const Aws_restJson1_1 = __nccwpck_require__(21518);
class CreateTokenCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "CreateTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.CreateTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.CreateTokenResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.serializeAws_restJson1CreateTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.deserializeAws_restJson1CreateTokenCommand)(output, context);
    }
}
exports.CreateTokenCommand = CreateTokenCommand;


/***/ }),

/***/ 36677:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RegisterClientCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(69374);
const Aws_restJson1_1 = __nccwpck_require__(21518);
class RegisterClientCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RegisterClientCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "RegisterClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RegisterClientRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.RegisterClientResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.serializeAws_restJson1RegisterClientCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.deserializeAws_restJson1RegisterClientCommand)(output, context);
    }
}
exports.RegisterClientCommand = RegisterClientCommand;


/***/ }),

/***/ 38359:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StartDeviceAuthorizationCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(69374);
const Aws_restJson1_1 = __nccwpck_require__(21518);
class StartDeviceAuthorizationCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StartDeviceAuthorizationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "StartDeviceAuthorizationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.StartDeviceAuthorizationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.StartDeviceAuthorizationResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.serializeAws_restJson1StartDeviceAuthorizationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.deserializeAws_restJson1StartDeviceAuthorizationCommand)(output, context);
    }
}
exports.StartDeviceAuthorizationCommand = StartDeviceAuthorizationCommand;


/***/ }),

/***/ 50447:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(62853), exports);
tslib_1.__exportStar(__nccwpck_require__(36677), exports);
tslib_1.__exportStar(__nccwpck_require__(38359), exports);


/***/ }),

/***/ 61426:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssooidc",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 97604:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(51756);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 51756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const p = "required", q = "fn", r = "argv", s = "ref";
const a = "PartitionResult", b = "tree", c = "error", d = "endpoint", e = { [p]: false, "type": "String" }, f = { [p]: true, "default": false, "type": "Boolean" }, g = { [s]: "Endpoint" }, h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] }, i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] }, j = {}, k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] }, l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] }, m = [g], n = [h], o = [i];
const _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 54527:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDCServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(17124), exports);
tslib_1.__exportStar(__nccwpck_require__(70139), exports);
tslib_1.__exportStar(__nccwpck_require__(50447), exports);
tslib_1.__exportStar(__nccwpck_require__(35973), exports);
var SSOOIDCServiceException_1 = __nccwpck_require__(43026);
Object.defineProperty(exports, "SSOOIDCServiceException", ({ enumerable: true, get: function () { return SSOOIDCServiceException_1.SSOOIDCServiceException; } }));


/***/ }),

/***/ 43026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOOIDCServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
class SSOOIDCServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
    }
}
exports.SSOOIDCServiceException = SSOOIDCServiceException;


/***/ }),

/***/ 35973:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(69374), exports);


/***/ }),

/***/ 69374:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StartDeviceAuthorizationResponseFilterSensitiveLog = exports.StartDeviceAuthorizationRequestFilterSensitiveLog = exports.RegisterClientResponseFilterSensitiveLog = exports.RegisterClientRequestFilterSensitiveLog = exports.CreateTokenResponseFilterSensitiveLog = exports.CreateTokenRequestFilterSensitiveLog = exports.InvalidClientMetadataException = exports.UnsupportedGrantTypeException = exports.UnauthorizedClientException = exports.SlowDownException = exports.InvalidScopeException = exports.InvalidRequestException = exports.InvalidGrantException = exports.InvalidClientException = exports.InternalServerException = exports.ExpiredTokenException = exports.AuthorizationPendingException = exports.AccessDeniedException = void 0;
const SSOOIDCServiceException_1 = __nccwpck_require__(43026);
class AccessDeniedException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.AccessDeniedException = AccessDeniedException;
class AuthorizationPendingException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...opts,
        });
        this.name = "AuthorizationPendingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.AuthorizationPendingException = AuthorizationPendingException;
class ExpiredTokenException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.ExpiredTokenException = ExpiredTokenException;
class InternalServerException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InternalServerException = InternalServerException;
class InvalidClientException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidClientException = InvalidClientException;
class InvalidGrantException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidGrantException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidGrantException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidGrantException = InvalidGrantException;
class InvalidRequestException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidRequestException = InvalidRequestException;
class InvalidScopeException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidScopeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidScopeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidScopeException = InvalidScopeException;
class SlowDownException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "SlowDownException",
            $fault: "client",
            ...opts,
        });
        this.name = "SlowDownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.SlowDownException = SlowDownException;
class UnauthorizedClientException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.UnauthorizedClientException = UnauthorizedClientException;
class UnsupportedGrantTypeException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedGrantTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.UnsupportedGrantTypeException = UnsupportedGrantTypeException;
class InvalidClientMetadataException extends SSOOIDCServiceException_1.SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientMetadataException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientMetadataException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidClientMetadataException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
}
exports.InvalidClientMetadataException = InvalidClientMetadataException;
const CreateTokenRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateTokenRequestFilterSensitiveLog = CreateTokenRequestFilterSensitiveLog;
const CreateTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CreateTokenResponseFilterSensitiveLog = CreateTokenResponseFilterSensitiveLog;
const RegisterClientRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterClientRequestFilterSensitiveLog = RegisterClientRequestFilterSensitiveLog;
const RegisterClientResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RegisterClientResponseFilterSensitiveLog = RegisterClientResponseFilterSensitiveLog;
const StartDeviceAuthorizationRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StartDeviceAuthorizationRequestFilterSensitiveLog = StartDeviceAuthorizationRequestFilterSensitiveLog;
const StartDeviceAuthorizationResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.StartDeviceAuthorizationResponseFilterSensitiveLog = StartDeviceAuthorizationResponseFilterSensitiveLog;


/***/ }),

/***/ 21518:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeAws_restJson1StartDeviceAuthorizationCommand = exports.deserializeAws_restJson1RegisterClientCommand = exports.deserializeAws_restJson1CreateTokenCommand = exports.serializeAws_restJson1StartDeviceAuthorizationCommand = exports.serializeAws_restJson1RegisterClientCommand = exports.serializeAws_restJson1CreateTokenCommand = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(69374);
const SSOOIDCServiceException_1 = __nccwpck_require__(43026);
const serializeAws_restJson1CreateTokenCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/token";
    let body;
    body = JSON.stringify({
        ...(input.clientId != null && { clientId: input.clientId }),
        ...(input.clientSecret != null && { clientSecret: input.clientSecret }),
        ...(input.code != null && { code: input.code }),
        ...(input.deviceCode != null && { deviceCode: input.deviceCode }),
        ...(input.grantType != null && { grantType: input.grantType }),
        ...(input.redirectUri != null && { redirectUri: input.redirectUri }),
        ...(input.refreshToken != null && { refreshToken: input.refreshToken }),
        ...(input.scope != null && { scope: serializeAws_restJson1Scopes(input.scope, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1CreateTokenCommand = serializeAws_restJson1CreateTokenCommand;
const serializeAws_restJson1RegisterClientCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/client/register";
    let body;
    body = JSON.stringify({
        ...(input.clientName != null && { clientName: input.clientName }),
        ...(input.clientType != null && { clientType: input.clientType }),
        ...(input.scopes != null && { scopes: serializeAws_restJson1Scopes(input.scopes, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1RegisterClientCommand = serializeAws_restJson1RegisterClientCommand;
const serializeAws_restJson1StartDeviceAuthorizationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/device_authorization";
    let body;
    body = JSON.stringify({
        ...(input.clientId != null && { clientId: input.clientId }),
        ...(input.clientSecret != null && { clientSecret: input.clientSecret }),
        ...(input.startUrl != null && { startUrl: input.startUrl }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1StartDeviceAuthorizationCommand = serializeAws_restJson1StartDeviceAuthorizationCommand;
const deserializeAws_restJson1CreateTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateTokenCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.accessToken != null) {
        contents.accessToken = (0, smithy_client_1.expectString)(data.accessToken);
    }
    if (data.expiresIn != null) {
        contents.expiresIn = (0, smithy_client_1.expectInt32)(data.expiresIn);
    }
    if (data.idToken != null) {
        contents.idToken = (0, smithy_client_1.expectString)(data.idToken);
    }
    if (data.refreshToken != null) {
        contents.refreshToken = (0, smithy_client_1.expectString)(data.refreshToken);
    }
    if (data.tokenType != null) {
        contents.tokenType = (0, smithy_client_1.expectString)(data.tokenType);
    }
    return contents;
};
exports.deserializeAws_restJson1CreateTokenCommand = deserializeAws_restJson1CreateTokenCommand;
const deserializeAws_restJson1CreateTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await deserializeAws_restJson1AuthorizationPendingExceptionResponse(parsedOutput, context);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await deserializeAws_restJson1ExpiredTokenExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await deserializeAws_restJson1InvalidClientExceptionResponse(parsedOutput, context);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await deserializeAws_restJson1InvalidGrantExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await deserializeAws_restJson1InvalidScopeExceptionResponse(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await deserializeAws_restJson1SlowDownExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: SSOOIDCServiceException_1.SSOOIDCServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restJson1RegisterClientCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1RegisterClientCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.authorizationEndpoint != null) {
        contents.authorizationEndpoint = (0, smithy_client_1.expectString)(data.authorizationEndpoint);
    }
    if (data.clientId != null) {
        contents.clientId = (0, smithy_client_1.expectString)(data.clientId);
    }
    if (data.clientIdIssuedAt != null) {
        contents.clientIdIssuedAt = (0, smithy_client_1.expectLong)(data.clientIdIssuedAt);
    }
    if (data.clientSecret != null) {
        contents.clientSecret = (0, smithy_client_1.expectString)(data.clientSecret);
    }
    if (data.clientSecretExpiresAt != null) {
        contents.clientSecretExpiresAt = (0, smithy_client_1.expectLong)(data.clientSecretExpiresAt);
    }
    if (data.tokenEndpoint != null) {
        contents.tokenEndpoint = (0, smithy_client_1.expectString)(data.tokenEndpoint);
    }
    return contents;
};
exports.deserializeAws_restJson1RegisterClientCommand = deserializeAws_restJson1RegisterClientCommand;
const deserializeAws_restJson1RegisterClientCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidClientMetadataException":
        case "com.amazonaws.ssooidc#InvalidClientMetadataException":
            throw await deserializeAws_restJson1InvalidClientMetadataExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await deserializeAws_restJson1InvalidScopeExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: SSOOIDCServiceException_1.SSOOIDCServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restJson1StartDeviceAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1StartDeviceAuthorizationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.deviceCode != null) {
        contents.deviceCode = (0, smithy_client_1.expectString)(data.deviceCode);
    }
    if (data.expiresIn != null) {
        contents.expiresIn = (0, smithy_client_1.expectInt32)(data.expiresIn);
    }
    if (data.interval != null) {
        contents.interval = (0, smithy_client_1.expectInt32)(data.interval);
    }
    if (data.userCode != null) {
        contents.userCode = (0, smithy_client_1.expectString)(data.userCode);
    }
    if (data.verificationUri != null) {
        contents.verificationUri = (0, smithy_client_1.expectString)(data.verificationUri);
    }
    if (data.verificationUriComplete != null) {
        contents.verificationUriComplete = (0, smithy_client_1.expectString)(data.verificationUriComplete);
    }
    return contents;
};
exports.deserializeAws_restJson1StartDeviceAuthorizationCommand = deserializeAws_restJson1StartDeviceAuthorizationCommand;
const deserializeAws_restJson1StartDeviceAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await deserializeAws_restJson1InvalidClientExceptionResponse(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await deserializeAws_restJson1SlowDownExceptionResponse(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: SSOOIDCServiceException_1.SSOOIDCServiceException,
                errorCode,
            });
    }
};
const map = smithy_client_1.map;
const deserializeAws_restJson1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1AuthorizationPendingExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.AuthorizationPendingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ExpiredTokenExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1InternalServerExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidClientExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.InvalidClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidClientMetadataExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.InvalidClientMetadataException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidGrantExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.InvalidGrantException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1InvalidScopeExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.InvalidScopeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1SlowDownExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.SlowDownException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1UnauthorizedClientExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.UnauthorizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1UnsupportedGrantTypeExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.error != null) {
        contents.error = (0, smithy_client_1.expectString)(data.error);
    }
    if (data.error_description != null) {
        contents.error_description = (0, smithy_client_1.expectString)(data.error_description);
    }
    const exception = new models_0_1.UnsupportedGrantTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const serializeAws_restJson1Scopes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 25524:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(69722));
const config_resolver_1 = __nccwpck_require__(56153);
const hash_node_1 = __nccwpck_require__(97442);
const middleware_retry_1 = __nccwpck_require__(96064);
const node_config_provider_1 = __nccwpck_require__(87684);
const node_http_handler_1 = __nccwpck_require__(68805);
const util_body_length_node_1 = __nccwpck_require__(74147);
const util_retry_1 = __nccwpck_require__(99395);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const util_utf8_node_1 = __nccwpck_require__(66278);
const runtimeConfig_shared_1 = __nccwpck_require__(68005);
const smithy_client_1 = __nccwpck_require__(4963);
const util_defaults_mode_node_1 = __nccwpck_require__(74243);
const smithy_client_2 = __nccwpck_require__(4963);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        utf8Decoder: config?.utf8Decoder ?? util_utf8_node_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_node_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 68005:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const url_parser_1 = __nccwpck_require__(2992);
const util_base64_1 = __nccwpck_require__(97727);
const endpointResolver_1 = __nccwpck_require__(97604);
const getRuntimeConfig = (config) => ({
    apiVersion: "2019-06-10",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "SSO OIDC",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 69838:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSO = void 0;
const GetRoleCredentialsCommand_1 = __nccwpck_require__(18972);
const ListAccountRolesCommand_1 = __nccwpck_require__(1513);
const ListAccountsCommand_1 = __nccwpck_require__(64296);
const LogoutCommand_1 = __nccwpck_require__(12586);
const SSOClient_1 = __nccwpck_require__(71057);
class SSO extends SSOClient_1.SSOClient {
    getRoleCredentials(args, optionsOrCb, cb) {
        const command = new GetRoleCredentialsCommand_1.GetRoleCredentialsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listAccountRoles(args, optionsOrCb, cb) {
        const command = new ListAccountRolesCommand_1.ListAccountRolesCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    listAccounts(args, optionsOrCb, cb) {
        const command = new ListAccountsCommand_1.ListAccountsCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    logout(args, optionsOrCb, cb) {
        const command = new LogoutCommand_1.LogoutCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
}
exports.SSO = SSO;


/***/ }),

/***/ 71057:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOClient = void 0;
const config_resolver_1 = __nccwpck_require__(56153);
const middleware_content_length_1 = __nccwpck_require__(42245);
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_retry_1 = __nccwpck_require__(96064);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const smithy_client_1 = __nccwpck_require__(4963);
const EndpointParameters_1 = __nccwpck_require__(34214);
const runtimeConfig_1 = __nccwpck_require__(19756);
class SSOClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        super(_config_6);
        this.config = _config_6;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.SSOClient = SSOClient;


/***/ }),

/***/ 18972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRoleCredentialsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class GetRoleCredentialsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetRoleCredentialsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "GetRoleCredentialsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetRoleCredentialsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetRoleCredentialsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.serializeAws_restJson1GetRoleCredentialsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.deserializeAws_restJson1GetRoleCredentialsCommand)(output, context);
    }
}
exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;


/***/ }),

/***/ 1513:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountRolesCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class ListAccountRolesCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountRolesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "ListAccountRolesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAccountRolesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListAccountRolesResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.serializeAws_restJson1ListAccountRolesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.deserializeAws_restJson1ListAccountRolesCommand)(output, context);
    }
}
exports.ListAccountRolesCommand = ListAccountRolesCommand;


/***/ }),

/***/ 64296:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountsCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class ListAccountsCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "ListAccountsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAccountsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListAccountsResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.serializeAws_restJson1ListAccountsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.deserializeAws_restJson1ListAccountsCommand)(output, context);
    }
}
exports.ListAccountsCommand = ListAccountsCommand;


/***/ }),

/***/ 12586:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogoutCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class LogoutCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, LogoutCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "LogoutCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.LogoutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (output) => output,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.serializeAws_restJson1LogoutCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.deserializeAws_restJson1LogoutCommand)(output, context);
    }
}
exports.LogoutCommand = LogoutCommand;


/***/ }),

/***/ 65706:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18972), exports);
tslib_1.__exportStar(__nccwpck_require__(1513), exports);
tslib_1.__exportStar(__nccwpck_require__(64296), exports);
tslib_1.__exportStar(__nccwpck_require__(12586), exports);


/***/ }),

/***/ 34214:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 30898:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(13341);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 13341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const p = "required", q = "fn", r = "argv", s = "ref";
const a = "PartitionResult", b = "tree", c = "error", d = "endpoint", e = { [p]: false, "type": "String" }, f = { [p]: true, "default": false, "type": "Boolean" }, g = { [s]: "Endpoint" }, h = { [q]: "booleanEquals", [r]: [{ [s]: "UseFIPS" }, true] }, i = { [q]: "booleanEquals", [r]: [{ [s]: "UseDualStack" }, true] }, j = {}, k = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsFIPS"] }] }, l = { [q]: "booleanEquals", [r]: [true, { [q]: "getAttr", [r]: [{ [s]: a }, "supportsDualStack"] }] }, m = [g], n = [h], o = [i];
const _data = { version: "1.0", parameters: { Region: e, UseDualStack: f, UseFIPS: f, Endpoint: e }, rules: [{ conditions: [{ [q]: "aws.partition", [r]: [{ [s]: "Region" }], assign: a }], type: b, rules: [{ conditions: [{ [q]: "isSet", [r]: m }, { [q]: "parseURL", [r]: m, assign: "url" }], type: b, rules: [{ conditions: n, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c }, { type: b, rules: [{ conditions: o, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c }, { endpoint: { url: g, properties: j, headers: j }, type: d }] }] }, { conditions: [h, i], type: b, rules: [{ conditions: [k, l], type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c }] }, { conditions: n, type: b, rules: [{ conditions: [k], type: b, rules: [{ type: b, rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: c }] }, { conditions: o, type: b, rules: [{ conditions: [l], type: b, rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: j, headers: j }, type: d }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: c }] }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: j, headers: j }, type: d }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 82666:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(69838), exports);
tslib_1.__exportStar(__nccwpck_require__(71057), exports);
tslib_1.__exportStar(__nccwpck_require__(65706), exports);
tslib_1.__exportStar(__nccwpck_require__(14952), exports);
tslib_1.__exportStar(__nccwpck_require__(36773), exports);
var SSOServiceException_1 = __nccwpck_require__(81517);
Object.defineProperty(exports, "SSOServiceException", ({ enumerable: true, get: function () { return SSOServiceException_1.SSOServiceException; } }));


/***/ }),

/***/ 81517:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
class SSOServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
}
exports.SSOServiceException = SSOServiceException;


/***/ }),

/***/ 14952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(66390), exports);


/***/ }),

/***/ 66390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogoutRequestFilterSensitiveLog = exports.ListAccountsResponseFilterSensitiveLog = exports.ListAccountsRequestFilterSensitiveLog = exports.ListAccountRolesResponseFilterSensitiveLog = exports.RoleInfoFilterSensitiveLog = exports.ListAccountRolesRequestFilterSensitiveLog = exports.GetRoleCredentialsResponseFilterSensitiveLog = exports.RoleCredentialsFilterSensitiveLog = exports.GetRoleCredentialsRequestFilterSensitiveLog = exports.AccountInfoFilterSensitiveLog = exports.UnauthorizedException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.InvalidRequestException = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const SSOServiceException_1 = __nccwpck_require__(81517);
class InvalidRequestException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
}
exports.InvalidRequestException = InvalidRequestException;
class ResourceNotFoundException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class TooManyRequestsException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
}
exports.TooManyRequestsException = TooManyRequestsException;
class UnauthorizedException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
exports.UnauthorizedException = UnauthorizedException;
const AccountInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AccountInfoFilterSensitiveLog = AccountInfoFilterSensitiveLog;
const GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.GetRoleCredentialsRequestFilterSensitiveLog = GetRoleCredentialsRequestFilterSensitiveLog;
const RoleCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.secretAccessKey && { secretAccessKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.sessionToken && { sessionToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.RoleCredentialsFilterSensitiveLog = RoleCredentialsFilterSensitiveLog;
const GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.roleCredentials && { roleCredentials: (0, exports.RoleCredentialsFilterSensitiveLog)(obj.roleCredentials) }),
});
exports.GetRoleCredentialsResponseFilterSensitiveLog = GetRoleCredentialsResponseFilterSensitiveLog;
const ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.ListAccountRolesRequestFilterSensitiveLog = ListAccountRolesRequestFilterSensitiveLog;
const RoleInfoFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.RoleInfoFilterSensitiveLog = RoleInfoFilterSensitiveLog;
const ListAccountRolesResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListAccountRolesResponseFilterSensitiveLog = ListAccountRolesResponseFilterSensitiveLog;
const ListAccountsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.ListAccountsRequestFilterSensitiveLog = ListAccountsRequestFilterSensitiveLog;
const ListAccountsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListAccountsResponseFilterSensitiveLog = ListAccountsResponseFilterSensitiveLog;
const LogoutRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.LogoutRequestFilterSensitiveLog = LogoutRequestFilterSensitiveLog;


/***/ }),

/***/ 80849:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 88460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccountRoles = void 0;
const ListAccountRolesCommand_1 = __nccwpck_require__(1513);
const SSO_1 = __nccwpck_require__(69838);
const SSOClient_1 = __nccwpck_require__(71057);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAccountRolesCommand_1.ListAccountRolesCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listAccountRoles(input, ...args);
};
async function* paginateListAccountRoles(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof SSO_1.SSO) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof SSOClient_1.SSOClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SSO | SSOClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccountRoles = paginateListAccountRoles;


/***/ }),

/***/ 50938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccounts = void 0;
const ListAccountsCommand_1 = __nccwpck_require__(64296);
const SSO_1 = __nccwpck_require__(69838);
const SSOClient_1 = __nccwpck_require__(71057);
const makePagedClientRequest = async (client, input, ...args) => {
    return await client.send(new ListAccountsCommand_1.ListAccountsCommand(input), ...args);
};
const makePagedRequest = async (client, input, ...args) => {
    return await client.listAccounts(input, ...args);
};
async function* paginateListAccounts(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while (hasNext) {
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof SSO_1.SSO) {
            page = await makePagedRequest(config.client, input, ...additionalArguments);
        }
        else if (config.client instanceof SSOClient_1.SSOClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        }
        else {
            throw new Error("Invalid client, expected SSO | SSOClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccounts = paginateListAccounts;


/***/ }),

/***/ 36773:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80849), exports);
tslib_1.__exportStar(__nccwpck_require__(88460), exports);
tslib_1.__exportStar(__nccwpck_require__(50938), exports);


/***/ }),

/***/ 98507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeAws_restJson1LogoutCommand = exports.deserializeAws_restJson1ListAccountsCommand = exports.deserializeAws_restJson1ListAccountRolesCommand = exports.deserializeAws_restJson1GetRoleCredentialsCommand = exports.serializeAws_restJson1LogoutCommand = exports.serializeAws_restJson1ListAccountsCommand = exports.serializeAws_restJson1ListAccountRolesCommand = exports.serializeAws_restJson1GetRoleCredentialsCommand = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(66390);
const SSOServiceException_1 = __nccwpck_require__(81517);
const serializeAws_restJson1GetRoleCredentialsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/federation/credentials";
    const query = map({
        role_name: [, (0, smithy_client_1.expectNonNull)(input.roleName, `roleName`)],
        account_id: [, (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetRoleCredentialsCommand = serializeAws_restJson1GetRoleCredentialsCommand;
const serializeAws_restJson1ListAccountRolesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/roles";
    const query = map({
        next_token: [, input.nextToken],
        max_result: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        account_id: [, (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListAccountRolesCommand = serializeAws_restJson1ListAccountRolesCommand;
const serializeAws_restJson1ListAccountsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/accounts";
    const query = map({
        next_token: [, input.nextToken],
        max_result: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListAccountsCommand = serializeAws_restJson1ListAccountsCommand;
const serializeAws_restJson1LogoutCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/logout";
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1LogoutCommand = serializeAws_restJson1LogoutCommand;
const deserializeAws_restJson1GetRoleCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetRoleCredentialsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.roleCredentials != null) {
        contents.roleCredentials = deserializeAws_restJson1RoleCredentials(data.roleCredentials, context);
    }
    return contents;
};
exports.deserializeAws_restJson1GetRoleCredentialsCommand = deserializeAws_restJson1GetRoleCredentialsCommand;
const deserializeAws_restJson1GetRoleCredentialsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: SSOServiceException_1.SSOServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restJson1ListAccountRolesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAccountRolesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.nextToken != null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    if (data.roleList != null) {
        contents.roleList = deserializeAws_restJson1RoleListType(data.roleList, context);
    }
    return contents;
};
exports.deserializeAws_restJson1ListAccountRolesCommand = deserializeAws_restJson1ListAccountRolesCommand;
const deserializeAws_restJson1ListAccountRolesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: SSOServiceException_1.SSOServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restJson1ListAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListAccountsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.accountList != null) {
        contents.accountList = deserializeAws_restJson1AccountListType(data.accountList, context);
    }
    if (data.nextToken != null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    return contents;
};
exports.deserializeAws_restJson1ListAccountsCommand = deserializeAws_restJson1ListAccountsCommand;
const deserializeAws_restJson1ListAccountsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: SSOServiceException_1.SSOServiceException,
                errorCode,
            });
    }
};
const deserializeAws_restJson1LogoutCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1LogoutCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
exports.deserializeAws_restJson1LogoutCommand = deserializeAws_restJson1LogoutCommand;
const deserializeAws_restJson1LogoutCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await deserializeAws_restJson1TooManyRequestsExceptionResponse(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody,
                exceptionCtor: SSOServiceException_1.SSOServiceException,
                errorCode,
            });
    }
};
const map = smithy_client_1.map;
const deserializeAws_restJson1InvalidRequestExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    const exception = new models_0_1.InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1TooManyRequestsExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1UnauthorizedExceptionResponse = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    if (data.message != null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1AccountInfo = (output, context) => {
    return {
        accountId: (0, smithy_client_1.expectString)(output.accountId),
        accountName: (0, smithy_client_1.expectString)(output.accountName),
        emailAddress: (0, smithy_client_1.expectString)(output.emailAddress),
    };
};
const deserializeAws_restJson1AccountListType = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AccountInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1RoleCredentials = (output, context) => {
    return {
        accessKeyId: (0, smithy_client_1.expectString)(output.accessKeyId),
        expiration: (0, smithy_client_1.expectLong)(output.expiration),
        secretAccessKey: (0, smithy_client_1.expectString)(output.secretAccessKey),
        sessionToken: (0, smithy_client_1.expectString)(output.sessionToken),
    };
};
const deserializeAws_restJson1RoleInfo = (output, context) => {
    return {
        accountId: (0, smithy_client_1.expectString)(output.accountId),
        roleName: (0, smithy_client_1.expectString)(output.roleName),
    };
};
const deserializeAws_restJson1RoleListType = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1RoleInfo(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 19756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(91092));
const config_resolver_1 = __nccwpck_require__(56153);
const hash_node_1 = __nccwpck_require__(97442);
const middleware_retry_1 = __nccwpck_require__(96064);
const node_config_provider_1 = __nccwpck_require__(87684);
const node_http_handler_1 = __nccwpck_require__(68805);
const util_body_length_node_1 = __nccwpck_require__(74147);
const util_retry_1 = __nccwpck_require__(99395);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const util_utf8_node_1 = __nccwpck_require__(66278);
const runtimeConfig_shared_1 = __nccwpck_require__(44809);
const smithy_client_1 = __nccwpck_require__(4963);
const util_defaults_mode_node_1 = __nccwpck_require__(74243);
const smithy_client_2 = __nccwpck_require__(4963);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        utf8Decoder: config?.utf8Decoder ?? util_utf8_node_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_node_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 44809:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const url_parser_1 = __nccwpck_require__(2992);
const util_base64_1 = __nccwpck_require__(97727);
const endpointResolver_1 = __nccwpck_require__(30898);
const getRuntimeConfig = (config) => ({
    apiVersion: "2019-06-10",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "SSO",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 32605:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STS = void 0;
const AssumeRoleCommand_1 = __nccwpck_require__(59802);
const AssumeRoleWithSAMLCommand_1 = __nccwpck_require__(72865);
const AssumeRoleWithWebIdentityCommand_1 = __nccwpck_require__(37451);
const DecodeAuthorizationMessageCommand_1 = __nccwpck_require__(74150);
const GetAccessKeyInfoCommand_1 = __nccwpck_require__(49804);
const GetCallerIdentityCommand_1 = __nccwpck_require__(24278);
const GetFederationTokenCommand_1 = __nccwpck_require__(57552);
const GetSessionTokenCommand_1 = __nccwpck_require__(43285);
const STSClient_1 = __nccwpck_require__(64195);
class STS extends STSClient_1.STSClient {
    assumeRole(args, optionsOrCb, cb) {
        const command = new AssumeRoleCommand_1.AssumeRoleCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    assumeRoleWithSAML(args, optionsOrCb, cb) {
        const command = new AssumeRoleWithSAMLCommand_1.AssumeRoleWithSAMLCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    assumeRoleWithWebIdentity(args, optionsOrCb, cb) {
        const command = new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    decodeAuthorizationMessage(args, optionsOrCb, cb) {
        const command = new DecodeAuthorizationMessageCommand_1.DecodeAuthorizationMessageCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getAccessKeyInfo(args, optionsOrCb, cb) {
        const command = new GetAccessKeyInfoCommand_1.GetAccessKeyInfoCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getCallerIdentity(args, optionsOrCb, cb) {
        const command = new GetCallerIdentityCommand_1.GetCallerIdentityCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getFederationToken(args, optionsOrCb, cb) {
        const command = new GetFederationTokenCommand_1.GetFederationTokenCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
    getSessionToken(args, optionsOrCb, cb) {
        const command = new GetSessionTokenCommand_1.GetSessionTokenCommand(args);
        if (typeof optionsOrCb === "function") {
            this.send(command, optionsOrCb);
        }
        else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
                throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
            this.send(command, optionsOrCb || {}, cb);
        }
        else {
            return this.send(command, optionsOrCb);
        }
    }
}
exports.STS = STS;


/***/ }),

/***/ 64195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSClient = void 0;
const config_resolver_1 = __nccwpck_require__(56153);
const middleware_content_length_1 = __nccwpck_require__(42245);
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_retry_1 = __nccwpck_require__(96064);
const middleware_sdk_sts_1 = __nccwpck_require__(55959);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const smithy_client_1 = __nccwpck_require__(4963);
const EndpointParameters_1 = __nccwpck_require__(20510);
const runtimeConfig_1 = __nccwpck_require__(83405);
class STSClient extends smithy_client_1.Client {
    constructor(configuration) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration);
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_sdk_sts_1.resolveStsAuthConfig)(_config_5, { stsClientCtor: STSClient });
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.STSClient = STSClient;


/***/ }),

/***/ 59802:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const middleware_signing_1 = __nccwpck_require__(14935);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssumeRoleRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssumeRoleResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryAssumeRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryAssumeRoleCommand)(output, context);
    }
}
exports.AssumeRoleCommand = AssumeRoleCommand;


/***/ }),

/***/ 72865:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleWithSAMLCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleWithSAMLCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithSAMLCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleWithSAMLCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryAssumeRoleWithSAMLCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryAssumeRoleWithSAMLCommand)(output, context);
    }
}
exports.AssumeRoleWithSAMLCommand = AssumeRoleWithSAMLCommand;


/***/ }),

/***/ 37451:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleWithWebIdentityCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleWithWebIdentityCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleWithWebIdentityCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryAssumeRoleWithWebIdentityCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryAssumeRoleWithWebIdentityCommand)(output, context);
    }
}
exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;


/***/ }),

/***/ 74150:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecodeAuthorizationMessageCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const middleware_signing_1 = __nccwpck_require__(14935);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class DecodeAuthorizationMessageCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DecodeAuthorizationMessageCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "DecodeAuthorizationMessageCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DecodeAuthorizationMessageRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DecodeAuthorizationMessageResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryDecodeAuthorizationMessageCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryDecodeAuthorizationMessageCommand)(output, context);
    }
}
exports.DecodeAuthorizationMessageCommand = DecodeAuthorizationMessageCommand;


/***/ }),

/***/ 49804:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAccessKeyInfoCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const middleware_signing_1 = __nccwpck_require__(14935);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetAccessKeyInfoCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccessKeyInfoCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetAccessKeyInfoCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetAccessKeyInfoRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetAccessKeyInfoResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryGetAccessKeyInfoCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryGetAccessKeyInfoCommand)(output, context);
    }
}
exports.GetAccessKeyInfoCommand = GetAccessKeyInfoCommand;


/***/ }),

/***/ 24278:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCallerIdentityCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const middleware_signing_1 = __nccwpck_require__(14935);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetCallerIdentityCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetCallerIdentityCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetCallerIdentityCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetCallerIdentityRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetCallerIdentityResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryGetCallerIdentityCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryGetCallerIdentityCommand)(output, context);
    }
}
exports.GetCallerIdentityCommand = GetCallerIdentityCommand;


/***/ }),

/***/ 57552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFederationTokenCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const middleware_signing_1 = __nccwpck_require__(14935);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetFederationTokenCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetFederationTokenCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetFederationTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetFederationTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetFederationTokenResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryGetFederationTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryGetFederationTokenCommand)(output, context);
    }
}
exports.GetFederationTokenCommand = GetFederationTokenCommand;


/***/ }),

/***/ 43285:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionTokenCommand = void 0;
const middleware_endpoint_1 = __nccwpck_require__(5497);
const middleware_serde_1 = __nccwpck_require__(93631);
const middleware_signing_1 = __nccwpck_require__(14935);
const smithy_client_1 = __nccwpck_require__(4963);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetSessionTokenCommand extends smithy_client_1.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetSessionTokenCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetSessionTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetSessionTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetSessionTokenResponseFilterSensitiveLog,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.serializeAws_queryGetSessionTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.deserializeAws_queryGetSessionTokenCommand)(output, context);
    }
}
exports.GetSessionTokenCommand = GetSessionTokenCommand;


/***/ }),

/***/ 55716:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(59802), exports);
tslib_1.__exportStar(__nccwpck_require__(72865), exports);
tslib_1.__exportStar(__nccwpck_require__(37451), exports);
tslib_1.__exportStar(__nccwpck_require__(74150), exports);
tslib_1.__exportStar(__nccwpck_require__(49804), exports);
tslib_1.__exportStar(__nccwpck_require__(24278), exports);
tslib_1.__exportStar(__nccwpck_require__(57552), exports);
tslib_1.__exportStar(__nccwpck_require__(43285), exports);


/***/ }),

/***/ 88028:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const defaultStsRoleAssumers_1 = __nccwpck_require__(90048);
const STSClient_1 = __nccwpck_require__(64195);
const getCustomizableStsClientCtor = (baseCtor, customizations) => {
    if (!customizations)
        return baseCtor;
    else
        return class CustomizableSTSClient extends baseCtor {
            constructor(config) {
                super(config);
                for (const customization of customizations) {
                    this.middlewareStack.use(customization);
                }
            }
        };
};
const getDefaultRoleAssumer = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumer)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumerWithWebIdentity)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input),
    ...input,
});
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 90048:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const AssumeRoleCommand_1 = __nccwpck_require__(59802);
const AssumeRoleWithWebIdentityCommand_1 = __nccwpck_require__(37451);
const ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
const decorateDefaultRegion = (region) => {
    if (typeof region !== "function") {
        return region === undefined ? ASSUME_ROLE_DEFAULT_REGION : region;
    }
    return async () => {
        try {
            return await region();
        }
        catch (e) {
            return ASSUME_ROLE_DEFAULT_REGION;
        }
    };
};
const getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                credentialDefaultProvider: () => async () => closureSourceCreds,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...(requestHandler ? { requestHandler } : {}),
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleCommand_1.AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
        };
    };
};
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
    let stsClient;
    return async (params) => {
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...(requestHandler ? { requestHandler } : {}),
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
        };
    };
};
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input, input.stsClientCtor),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input, input.stsClientCtor),
    ...input,
});
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 20510:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 41203:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const ruleset_1 = __nccwpck_require__(86882);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 86882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const H = "required", I = "fn", J = "argv", K = "ref", L = "properties", M = "headers";
const a = false, b = true, c = "PartitionResult", d = "tree", e = "booleanEquals", f = "stringEquals", g = "https://sts.amazonaws.com", h = "sigv4", i = "sts", j = "us-east-1", k = "endpoint", l = "https://sts.{Region}.{PartitionResult#dnsSuffix}", m = "error", n = "getAttr", o = { [H]: false, "type": "String" }, p = { [H]: true, "default": false, "type": "Boolean" }, q = { [K]: "Region" }, r = { [K]: "UseFIPS" }, s = { [K]: "UseDualStack" }, t = { [I]: "isSet", [J]: [{ [K]: "Endpoint" }] }, u = { [K]: "Endpoint" }, v = { "url": g, [L]: { "authSchemes": [{ "name": h, "signingName": i, "signingRegion": j }] }, [M]: {} }, w = {}, x = { [I]: e, [J]: [r, true] }, y = { [I]: e, [J]: [s, true] }, z = { [I]: e, [J]: [true, { [I]: n, [J]: [{ [K]: c }, "supportsFIPS"] }] }, A = { [K]: c }, B = { [I]: e, [J]: [true, { [I]: n, [J]: [A, "supportsDualStack"] }] }, C = { "url": l, [L]: {}, [M]: {} }, D = [u], E = [{ [I]: f, [J]: [q, "aws-global"] }], F = [x], G = [y];
const _data = { version: "1.0", parameters: { Region: o, UseDualStack: p, UseFIPS: p, Endpoint: o, UseGlobalEndpoint: p }, rules: [{ conditions: [{ [I]: "aws.partition", [J]: [q], assign: c }], type: d, rules: [{ conditions: [{ [I]: e, [J]: [{ [K]: "UseGlobalEndpoint" }, b] }, { [I]: e, [J]: [r, a] }, { [I]: e, [J]: [s, a] }, { [I]: "not", [J]: [t] }], type: d, rules: [{ conditions: [{ [I]: f, [J]: [q, "ap-northeast-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "ap-south-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "ap-southeast-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "ap-southeast-2"] }], endpoint: v, type: k }, { conditions: E, endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "ca-central-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "eu-central-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "eu-north-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "eu-west-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "eu-west-2"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "eu-west-3"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "sa-east-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, j] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "us-east-2"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "us-west-1"] }], endpoint: v, type: k }, { conditions: [{ [I]: f, [J]: [q, "us-west-2"] }], endpoint: v, type: k }, { endpoint: { url: l, [L]: { authSchemes: [{ name: h, signingName: i, signingRegion: "{Region}" }] }, [M]: w }, type: k }] }, { conditions: [t, { [I]: "parseURL", [J]: D, assign: "url" }], type: d, rules: [{ conditions: F, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: m }, { type: d, rules: [{ conditions: G, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: m }, { endpoint: { url: u, [L]: w, [M]: w }, type: k }] }] }, { conditions: [x, y], type: d, rules: [{ conditions: [z, B], type: d, rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", [L]: w, [M]: w }, type: k }] }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: m }] }, { conditions: F, type: d, rules: [{ conditions: [z], type: d, rules: [{ type: d, rules: [{ conditions: [{ [I]: f, [J]: ["aws-us-gov", { [I]: n, [J]: [A, "name"] }] }], endpoint: C, type: k }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", [L]: w, [M]: w }, type: k }] }] }, { error: "FIPS is enabled but this partition does not support FIPS", type: m }] }, { conditions: G, type: d, rules: [{ conditions: [B], type: d, rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", [L]: w, [M]: w }, type: k }] }, { error: "DualStack is enabled but this partition does not support DualStack", type: m }] }, { type: d, rules: [{ conditions: E, endpoint: { url: g, [L]: { authSchemes: [{ name: h, signingRegion: j, signingName: i }] }, [M]: w }, type: k }, { endpoint: C, type: k }] }] }] };
exports.ruleSet = _data;


/***/ }),

/***/ 52209:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(32605), exports);
tslib_1.__exportStar(__nccwpck_require__(64195), exports);
tslib_1.__exportStar(__nccwpck_require__(55716), exports);
tslib_1.__exportStar(__nccwpck_require__(88028), exports);
tslib_1.__exportStar(__nccwpck_require__(20106), exports);
var STSServiceException_1 = __nccwpck_require__(26450);
Object.defineProperty(exports, "STSServiceException", ({ enumerable: true, get: function () { return STSServiceException_1.STSServiceException; } }));


/***/ }),

/***/ 26450:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
class STSServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, STSServiceException.prototype);
    }
}
exports.STSServiceException = STSServiceException;


/***/ }),

/***/ 20106:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(21780), exports);


/***/ }),

/***/ 21780:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionTokenResponseFilterSensitiveLog = exports.GetSessionTokenRequestFilterSensitiveLog = exports.GetFederationTokenResponseFilterSensitiveLog = exports.FederatedUserFilterSensitiveLog = exports.GetFederationTokenRequestFilterSensitiveLog = exports.GetCallerIdentityResponseFilterSensitiveLog = exports.GetCallerIdentityRequestFilterSensitiveLog = exports.GetAccessKeyInfoResponseFilterSensitiveLog = exports.GetAccessKeyInfoRequestFilterSensitiveLog = exports.DecodeAuthorizationMessageResponseFilterSensitiveLog = exports.DecodeAuthorizationMessageRequestFilterSensitiveLog = exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = exports.AssumeRoleResponseFilterSensitiveLog = exports.CredentialsFilterSensitiveLog = exports.AssumeRoleRequestFilterSensitiveLog = exports.TagFilterSensitiveLog = exports.PolicyDescriptorTypeFilterSensitiveLog = exports.AssumedRoleUserFilterSensitiveLog = exports.InvalidAuthorizationMessageException = exports.IDPCommunicationErrorException = exports.InvalidIdentityTokenException = exports.IDPRejectedClaimException = exports.RegionDisabledException = exports.PackedPolicyTooLargeException = exports.MalformedPolicyDocumentException = exports.ExpiredTokenException = void 0;
const STSServiceException_1 = __nccwpck_require__(26450);
class ExpiredTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
}
exports.ExpiredTokenException = ExpiredTokenException;
class MalformedPolicyDocumentException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
}
exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;
class PackedPolicyTooLargeException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...opts,
        });
        this.name = "PackedPolicyTooLargeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
}
exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;
class RegionDisabledException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "RegionDisabledException",
            $fault: "client",
            ...opts,
        });
        this.name = "RegionDisabledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
}
exports.RegionDisabledException = RegionDisabledException;
class IDPRejectedClaimException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "IDPRejectedClaimException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPRejectedClaimException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
}
exports.IDPRejectedClaimException = IDPRejectedClaimException;
class InvalidIdentityTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIdentityTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
}
exports.InvalidIdentityTokenException = InvalidIdentityTokenException;
class IDPCommunicationErrorException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPCommunicationErrorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
}
exports.IDPCommunicationErrorException = IDPCommunicationErrorException;
class InvalidAuthorizationMessageException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "InvalidAuthorizationMessageException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAuthorizationMessageException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
    }
}
exports.InvalidAuthorizationMessageException = InvalidAuthorizationMessageException;
const AssumedRoleUserFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssumedRoleUserFilterSensitiveLog = AssumedRoleUserFilterSensitiveLog;
const PolicyDescriptorTypeFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.PolicyDescriptorTypeFilterSensitiveLog = PolicyDescriptorTypeFilterSensitiveLog;
const TagFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.TagFilterSensitiveLog = TagFilterSensitiveLog;
const AssumeRoleRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssumeRoleRequestFilterSensitiveLog = AssumeRoleRequestFilterSensitiveLog;
const CredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.CredentialsFilterSensitiveLog = CredentialsFilterSensitiveLog;
const AssumeRoleResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssumeRoleResponseFilterSensitiveLog = AssumeRoleResponseFilterSensitiveLog;
const AssumeRoleWithSAMLRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = AssumeRoleWithSAMLRequestFilterSensitiveLog;
const AssumeRoleWithSAMLResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = AssumeRoleWithSAMLResponseFilterSensitiveLog;
const AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = AssumeRoleWithWebIdentityRequestFilterSensitiveLog;
const AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = AssumeRoleWithWebIdentityResponseFilterSensitiveLog;
const DecodeAuthorizationMessageRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DecodeAuthorizationMessageRequestFilterSensitiveLog = DecodeAuthorizationMessageRequestFilterSensitiveLog;
const DecodeAuthorizationMessageResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DecodeAuthorizationMessageResponseFilterSensitiveLog = DecodeAuthorizationMessageResponseFilterSensitiveLog;
const GetAccessKeyInfoRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetAccessKeyInfoRequestFilterSensitiveLog = GetAccessKeyInfoRequestFilterSensitiveLog;
const GetAccessKeyInfoResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetAccessKeyInfoResponseFilterSensitiveLog = GetAccessKeyInfoResponseFilterSensitiveLog;
const GetCallerIdentityRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetCallerIdentityRequestFilterSensitiveLog = GetCallerIdentityRequestFilterSensitiveLog;
const GetCallerIdentityResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetCallerIdentityResponseFilterSensitiveLog = GetCallerIdentityResponseFilterSensitiveLog;
const GetFederationTokenRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetFederationTokenRequestFilterSensitiveLog = GetFederationTokenRequestFilterSensitiveLog;
const FederatedUserFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.FederatedUserFilterSensitiveLog = FederatedUserFilterSensitiveLog;
const GetFederationTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetFederationTokenResponseFilterSensitiveLog = GetFederationTokenResponseFilterSensitiveLog;
const GetSessionTokenRequestFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetSessionTokenRequestFilterSensitiveLog = GetSessionTokenRequestFilterSensitiveLog;
const GetSessionTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetSessionTokenResponseFilterSensitiveLog = GetSessionTokenResponseFilterSensitiveLog;


/***/ }),

/***/ 10740:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeAws_queryGetSessionTokenCommand = exports.deserializeAws_queryGetFederationTokenCommand = exports.deserializeAws_queryGetCallerIdentityCommand = exports.deserializeAws_queryGetAccessKeyInfoCommand = exports.deserializeAws_queryDecodeAuthorizationMessageCommand = exports.deserializeAws_queryAssumeRoleWithWebIdentityCommand = exports.deserializeAws_queryAssumeRoleWithSAMLCommand = exports.deserializeAws_queryAssumeRoleCommand = exports.serializeAws_queryGetSessionTokenCommand = exports.serializeAws_queryGetFederationTokenCommand = exports.serializeAws_queryGetCallerIdentityCommand = exports.serializeAws_queryGetAccessKeyInfoCommand = exports.serializeAws_queryDecodeAuthorizationMessageCommand = exports.serializeAws_queryAssumeRoleWithWebIdentityCommand = exports.serializeAws_queryAssumeRoleWithSAMLCommand = exports.serializeAws_queryAssumeRoleCommand = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const smithy_client_1 = __nccwpck_require__(4963);
const fast_xml_parser_1 = __nccwpck_require__(12603);
const models_0_1 = __nccwpck_require__(21780);
const STSServiceException_1 = __nccwpck_require__(26450);
const serializeAws_queryAssumeRoleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryAssumeRoleRequest(input, context),
        Action: "AssumeRole",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryAssumeRoleCommand = serializeAws_queryAssumeRoleCommand;
const serializeAws_queryAssumeRoleWithSAMLCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryAssumeRoleWithSAMLRequest(input, context),
        Action: "AssumeRoleWithSAML",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryAssumeRoleWithSAMLCommand = serializeAws_queryAssumeRoleWithSAMLCommand;
const serializeAws_queryAssumeRoleWithWebIdentityCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryAssumeRoleWithWebIdentityRequest(input, context),
        Action: "AssumeRoleWithWebIdentity",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryAssumeRoleWithWebIdentityCommand = serializeAws_queryAssumeRoleWithWebIdentityCommand;
const serializeAws_queryDecodeAuthorizationMessageCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryDecodeAuthorizationMessageRequest(input, context),
        Action: "DecodeAuthorizationMessage",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryDecodeAuthorizationMessageCommand = serializeAws_queryDecodeAuthorizationMessageCommand;
const serializeAws_queryGetAccessKeyInfoCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryGetAccessKeyInfoRequest(input, context),
        Action: "GetAccessKeyInfo",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryGetAccessKeyInfoCommand = serializeAws_queryGetAccessKeyInfoCommand;
const serializeAws_queryGetCallerIdentityCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryGetCallerIdentityRequest(input, context),
        Action: "GetCallerIdentity",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryGetCallerIdentityCommand = serializeAws_queryGetCallerIdentityCommand;
const serializeAws_queryGetFederationTokenCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryGetFederationTokenRequest(input, context),
        Action: "GetFederationToken",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryGetFederationTokenCommand = serializeAws_queryGetFederationTokenCommand;
const serializeAws_queryGetSessionTokenCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-www-form-urlencoded",
    };
    let body;
    body = buildFormUrlencodedString({
        ...serializeAws_queryGetSessionTokenRequest(input, context),
        Action: "GetSessionToken",
        Version: "2011-06-15",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.serializeAws_queryGetSessionTokenCommand = serializeAws_queryGetSessionTokenCommand;
const deserializeAws_queryAssumeRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryAssumeRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryAssumeRoleResponse(data.AssumeRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryAssumeRoleCommand = deserializeAws_queryAssumeRoleCommand;
const deserializeAws_queryAssumeRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: STSServiceException_1.STSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_queryAssumeRoleWithSAMLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryAssumeRoleWithSAMLCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryAssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryAssumeRoleWithSAMLCommand = deserializeAws_queryAssumeRoleWithSAMLCommand;
const deserializeAws_queryAssumeRoleWithSAMLCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await deserializeAws_queryIDPRejectedClaimExceptionResponse(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await deserializeAws_queryInvalidIdentityTokenExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: STSServiceException_1.STSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_queryAssumeRoleWithWebIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryAssumeRoleWithWebIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryAssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryAssumeRoleWithWebIdentityCommand = deserializeAws_queryAssumeRoleWithWebIdentityCommand;
const deserializeAws_queryAssumeRoleWithWebIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await deserializeAws_queryExpiredTokenExceptionResponse(parsedOutput, context);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await deserializeAws_queryIDPCommunicationErrorExceptionResponse(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await deserializeAws_queryIDPRejectedClaimExceptionResponse(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await deserializeAws_queryInvalidIdentityTokenExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: STSServiceException_1.STSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_queryDecodeAuthorizationMessageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryDecodeAuthorizationMessageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryDecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryDecodeAuthorizationMessageCommand = deserializeAws_queryDecodeAuthorizationMessageCommand;
const deserializeAws_queryDecodeAuthorizationMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidAuthorizationMessageException":
        case "com.amazonaws.sts#InvalidAuthorizationMessageException":
            throw await deserializeAws_queryInvalidAuthorizationMessageExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: STSServiceException_1.STSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_queryGetAccessKeyInfoCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryGetAccessKeyInfoCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryGetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryGetAccessKeyInfoCommand = deserializeAws_queryGetAccessKeyInfoCommand;
const deserializeAws_queryGetAccessKeyInfoCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    (0, smithy_client_1.throwDefaultError)({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: STSServiceException_1.STSServiceException,
        errorCode,
    });
};
const deserializeAws_queryGetCallerIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryGetCallerIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryGetCallerIdentityResponse(data.GetCallerIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryGetCallerIdentityCommand = deserializeAws_queryGetCallerIdentityCommand;
const deserializeAws_queryGetCallerIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    (0, smithy_client_1.throwDefaultError)({
        output,
        parsedBody: parsedBody.Error,
        exceptionCtor: STSServiceException_1.STSServiceException,
        errorCode,
    });
};
const deserializeAws_queryGetFederationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryGetFederationTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryGetFederationTokenResponse(data.GetFederationTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryGetFederationTokenCommand = deserializeAws_queryGetFederationTokenCommand;
const deserializeAws_queryGetFederationTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await deserializeAws_queryMalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await deserializeAws_queryPackedPolicyTooLargeExceptionResponse(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: STSServiceException_1.STSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_queryGetSessionTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_queryGetSessionTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_queryGetSessionTokenResponse(data.GetSessionTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
exports.deserializeAws_queryGetSessionTokenCommand = deserializeAws_queryGetSessionTokenCommand;
const deserializeAws_queryGetSessionTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await deserializeAws_queryRegionDisabledExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            (0, smithy_client_1.throwDefaultError)({
                output,
                parsedBody: parsedBody.Error,
                exceptionCtor: STSServiceException_1.STSServiceException,
                errorCode,
            });
    }
};
const deserializeAws_queryExpiredTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryExpiredTokenException(body.Error, context);
    const exception = new models_0_1.ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_queryIDPCommunicationErrorExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryIDPCommunicationErrorException(body.Error, context);
    const exception = new models_0_1.IDPCommunicationErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_queryIDPRejectedClaimExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryIDPRejectedClaimException(body.Error, context);
    const exception = new models_0_1.IDPRejectedClaimException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_queryInvalidAuthorizationMessageExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryInvalidAuthorizationMessageException(body.Error, context);
    const exception = new models_0_1.InvalidAuthorizationMessageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_queryInvalidIdentityTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryInvalidIdentityTokenException(body.Error, context);
    const exception = new models_0_1.InvalidIdentityTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_queryMalformedPolicyDocumentExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryMalformedPolicyDocumentException(body.Error, context);
    const exception = new models_0_1.MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_queryPackedPolicyTooLargeExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryPackedPolicyTooLargeException(body.Error, context);
    const exception = new models_0_1.PackedPolicyTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const deserializeAws_queryRegionDisabledExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_queryRegionDisabledException(body.Error, context);
    const exception = new models_0_1.RegionDisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const serializeAws_queryAssumeRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.PolicyArns != null) {
        const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
        const memberEntries = serializeAws_querytagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TransitiveTagKeys != null) {
        const memberEntries = serializeAws_querytagKeyListType(input.TransitiveTagKeys, context);
        if (input.TransitiveTagKeys?.length === 0) {
            entries.TransitiveTagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitiveTagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ExternalId != null) {
        entries["ExternalId"] = input.ExternalId;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
        entries["TokenCode"] = input.TokenCode;
    }
    if (input.SourceIdentity != null) {
        entries["SourceIdentity"] = input.SourceIdentity;
    }
    return entries;
};
const serializeAws_queryAssumeRoleWithSAMLRequest = (input, context) => {
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.PrincipalArn != null) {
        entries["PrincipalArn"] = input.PrincipalArn;
    }
    if (input.SAMLAssertion != null) {
        entries["SAMLAssertion"] = input.SAMLAssertion;
    }
    if (input.PolicyArns != null) {
        const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    return entries;
};
const serializeAws_queryAssumeRoleWithWebIdentityRequest = (input, context) => {
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.WebIdentityToken != null) {
        entries["WebIdentityToken"] = input.WebIdentityToken;
    }
    if (input.ProviderId != null) {
        entries["ProviderId"] = input.ProviderId;
    }
    if (input.PolicyArns != null) {
        const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    return entries;
};
const serializeAws_queryDecodeAuthorizationMessageRequest = (input, context) => {
    const entries = {};
    if (input.EncodedMessage != null) {
        entries["EncodedMessage"] = input.EncodedMessage;
    }
    return entries;
};
const serializeAws_queryGetAccessKeyInfoRequest = (input, context) => {
    const entries = {};
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    return entries;
};
const serializeAws_queryGetCallerIdentityRequest = (input, context) => {
    const entries = {};
    return entries;
};
const serializeAws_queryGetFederationTokenRequest = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.PolicyArns != null) {
        const memberEntries = serializeAws_querypolicyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
        const memberEntries = serializeAws_querytagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const serializeAws_queryGetSessionTokenRequest = (input, context) => {
    const entries = {};
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
        entries["TokenCode"] = input.TokenCode;
    }
    return entries;
};
const serializeAws_querypolicyDescriptorListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = serializeAws_queryPolicyDescriptorType(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const serializeAws_queryPolicyDescriptorType = (input, context) => {
    const entries = {};
    if (input.arn != null) {
        entries["arn"] = input.arn;
    }
    return entries;
};
const serializeAws_queryTag = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const serializeAws_querytagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const serializeAws_querytagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = serializeAws_queryTag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const deserializeAws_queryAssumedRoleUser = (output, context) => {
    const contents = {
        AssumedRoleId: undefined,
        Arn: undefined,
    };
    if (output["AssumedRoleId"] !== undefined) {
        contents.AssumedRoleId = (0, smithy_client_1.expectString)(output["AssumedRoleId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const deserializeAws_queryAssumeRoleResponse = (output, context) => {
    const contents = {
        Credentials: undefined,
        AssumedRoleUser: undefined,
        PackedPolicySize: undefined,
        SourceIdentity: undefined,
    };
    if (output["Credentials"] !== undefined) {
        contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const deserializeAws_queryAssumeRoleWithSAMLResponse = (output, context) => {
    const contents = {
        Credentials: undefined,
        AssumedRoleUser: undefined,
        PackedPolicySize: undefined,
        Subject: undefined,
        SubjectType: undefined,
        Issuer: undefined,
        Audience: undefined,
        NameQualifier: undefined,
        SourceIdentity: undefined,
    };
    if (output["Credentials"] !== undefined) {
        contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Subject"] !== undefined) {
        contents.Subject = (0, smithy_client_1.expectString)(output["Subject"]);
    }
    if (output["SubjectType"] !== undefined) {
        contents.SubjectType = (0, smithy_client_1.expectString)(output["SubjectType"]);
    }
    if (output["Issuer"] !== undefined) {
        contents.Issuer = (0, smithy_client_1.expectString)(output["Issuer"]);
    }
    if (output["Audience"] !== undefined) {
        contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["NameQualifier"] !== undefined) {
        contents.NameQualifier = (0, smithy_client_1.expectString)(output["NameQualifier"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const deserializeAws_queryAssumeRoleWithWebIdentityResponse = (output, context) => {
    const contents = {
        Credentials: undefined,
        SubjectFromWebIdentityToken: undefined,
        AssumedRoleUser: undefined,
        PackedPolicySize: undefined,
        Provider: undefined,
        Audience: undefined,
        SourceIdentity: undefined,
    };
    if (output["Credentials"] !== undefined) {
        contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
    }
    if (output["SubjectFromWebIdentityToken"] !== undefined) {
        contents.SubjectFromWebIdentityToken = (0, smithy_client_1.expectString)(output["SubjectFromWebIdentityToken"]);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = deserializeAws_queryAssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Provider"] !== undefined) {
        contents.Provider = (0, smithy_client_1.expectString)(output["Provider"]);
    }
    if (output["Audience"] !== undefined) {
        contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const deserializeAws_queryCredentials = (output, context) => {
    const contents = {
        AccessKeyId: undefined,
        SecretAccessKey: undefined,
        SessionToken: undefined,
        Expiration: undefined,
    };
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = (0, smithy_client_1.expectString)(output["AccessKeyId"]);
    }
    if (output["SecretAccessKey"] !== undefined) {
        contents.SecretAccessKey = (0, smithy_client_1.expectString)(output["SecretAccessKey"]);
    }
    if (output["SessionToken"] !== undefined) {
        contents.SessionToken = (0, smithy_client_1.expectString)(output["SessionToken"]);
    }
    if (output["Expiration"] !== undefined) {
        contents.Expiration = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTime)(output["Expiration"]));
    }
    return contents;
};
const deserializeAws_queryDecodeAuthorizationMessageResponse = (output, context) => {
    const contents = {
        DecodedMessage: undefined,
    };
    if (output["DecodedMessage"] !== undefined) {
        contents.DecodedMessage = (0, smithy_client_1.expectString)(output["DecodedMessage"]);
    }
    return contents;
};
const deserializeAws_queryExpiredTokenException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeAws_queryFederatedUser = (output, context) => {
    const contents = {
        FederatedUserId: undefined,
        Arn: undefined,
    };
    if (output["FederatedUserId"] !== undefined) {
        contents.FederatedUserId = (0, smithy_client_1.expectString)(output["FederatedUserId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const deserializeAws_queryGetAccessKeyInfoResponse = (output, context) => {
    const contents = {
        Account: undefined,
    };
    if (output["Account"] !== undefined) {
        contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    return contents;
};
const deserializeAws_queryGetCallerIdentityResponse = (output, context) => {
    const contents = {
        UserId: undefined,
        Account: undefined,
        Arn: undefined,
    };
    if (output["UserId"] !== undefined) {
        contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
    }
    if (output["Account"] !== undefined) {
        contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const deserializeAws_queryGetFederationTokenResponse = (output, context) => {
    const contents = {
        Credentials: undefined,
        FederatedUser: undefined,
        PackedPolicySize: undefined,
    };
    if (output["Credentials"] !== undefined) {
        contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
    }
    if (output["FederatedUser"] !== undefined) {
        contents.FederatedUser = deserializeAws_queryFederatedUser(output["FederatedUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    return contents;
};
const deserializeAws_queryGetSessionTokenResponse = (output, context) => {
    const contents = {
        Credentials: undefined,
    };
    if (output["Credentials"] !== undefined) {
        contents.Credentials = deserializeAws_queryCredentials(output["Credentials"], context);
    }
    return contents;
};
const deserializeAws_queryIDPCommunicationErrorException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeAws_queryIDPRejectedClaimException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeAws_queryInvalidAuthorizationMessageException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeAws_queryInvalidIdentityTokenException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeAws_queryMalformedPolicyDocumentException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeAws_queryPackedPolicyTooLargeException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeAws_queryRegionDisabledException = (output, context) => {
    const contents = {
        message: undefined,
    };
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 83405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(7947));
const defaultStsRoleAssumers_1 = __nccwpck_require__(90048);
const config_resolver_1 = __nccwpck_require__(56153);
const credential_provider_node_1 = __nccwpck_require__(75531);
const hash_node_1 = __nccwpck_require__(97442);
const middleware_retry_1 = __nccwpck_require__(96064);
const node_config_provider_1 = __nccwpck_require__(87684);
const node_http_handler_1 = __nccwpck_require__(68805);
const util_body_length_node_1 = __nccwpck_require__(74147);
const util_retry_1 = __nccwpck_require__(99395);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const util_utf8_node_1 = __nccwpck_require__(66278);
const runtimeConfig_shared_1 = __nccwpck_require__(52642);
const smithy_client_1 = __nccwpck_require__(4963);
const util_defaults_mode_node_1 = __nccwpck_require__(74243);
const smithy_client_2 = __nccwpck_require__(4963);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, defaultStsRoleAssumers_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
        utf8Decoder: config?.utf8Decoder ?? util_utf8_node_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_node_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 52642:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(4963);
const url_parser_1 = __nccwpck_require__(2992);
const util_base64_1 = __nccwpck_require__(97727);
const endpointResolver_1 = __nccwpck_require__(41203);
const getRuntimeConfig = (config) => ({
    apiVersion: "2011-06-15",
    base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
    base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
    logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
    serviceId: config?.serviceId ?? "STS",
    urlParser: config?.urlParser ?? url_parser_1.parseUrl,
});
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 14723:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_DUALSTACK_ENDPOINT = exports.CONFIG_USE_DUALSTACK_ENDPOINT = exports.ENV_USE_DUALSTACK_ENDPOINT = void 0;
const util_config_provider_1 = __nccwpck_require__(6168);
exports.ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
exports.CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
exports.DEFAULT_USE_DUALSTACK_ENDPOINT = false;
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 42478:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_FIPS_ENDPOINT = exports.CONFIG_USE_FIPS_ENDPOINT = exports.ENV_USE_FIPS_ENDPOINT = void 0;
const util_config_provider_1 = __nccwpck_require__(6168);
exports.ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
exports.CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
exports.DEFAULT_USE_FIPS_ENDPOINT = false;
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 47392:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(14723), exports);
tslib_1.__exportStar(__nccwpck_require__(42478), exports);
tslib_1.__exportStar(__nccwpck_require__(92108), exports);
tslib_1.__exportStar(__nccwpck_require__(92327), exports);


/***/ }),

/***/ 92108:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveCustomEndpointsConfig = void 0;
const util_middleware_1 = __nccwpck_require__(10236);
const resolveCustomEndpointsConfig = (input) => {
    var _a, _b;
    const { endpoint, urlParser } = input;
    return {
        ...input,
        tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,
        endpoint: (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false),
    };
};
exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;


/***/ }),

/***/ 92327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpointsConfig = void 0;
const util_middleware_1 = __nccwpck_require__(10236);
const getEndpointFromRegion_1 = __nccwpck_require__(94159);
const resolveEndpointsConfig = (input) => {
    var _a, _b;
    const useDualstackEndpoint = (0, util_middleware_1.normalizeProvider)((_a = input.useDualstackEndpoint) !== null && _a !== void 0 ? _a : false);
    const { endpoint, useFipsEndpoint, urlParser } = input;
    return {
        ...input,
        tls: (_b = input.tls) !== null && _b !== void 0 ? _b : true,
        endpoint: endpoint
            ? (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
            : () => (0, getEndpointFromRegion_1.getEndpointFromRegion)({ ...input, useDualstackEndpoint, useFipsEndpoint }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint,
    };
};
exports.resolveEndpointsConfig = resolveEndpointsConfig;


/***/ }),

/***/ 94159:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointFromRegion = void 0;
const getEndpointFromRegion = async (input) => {
    var _a;
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
        throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = (_a = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }))) !== null && _a !== void 0 ? _a : {};
    if (!hostname) {
        throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
};
exports.getEndpointFromRegion = getEndpointFromRegion;


/***/ }),

/***/ 56153:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(47392), exports);
tslib_1.__exportStar(__nccwpck_require__(85441), exports);
tslib_1.__exportStar(__nccwpck_require__(86258), exports);


/***/ }),

/***/ 70422:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = void 0;
exports.REGION_ENV_NAME = "AWS_REGION";
exports.REGION_INI_NAME = "region";
exports.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.REGION_ENV_NAME],
    configFileSelector: (profile) => profile[exports.REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};


/***/ }),

/***/ 52844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRealRegion = void 0;
const isFipsRegion_1 = __nccwpck_require__(82440);
const getRealRegion = (region) => (0, isFipsRegion_1.isFipsRegion)(region)
    ? ["fips-aws-global", "aws-fips"].includes(region)
        ? "us-east-1"
        : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
    : region;
exports.getRealRegion = getRealRegion;


/***/ }),

/***/ 85441:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(70422), exports);
tslib_1.__exportStar(__nccwpck_require__(60174), exports);


/***/ }),

/***/ 82440:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFipsRegion = void 0;
const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
exports.isFipsRegion = isFipsRegion;


/***/ }),

/***/ 60174:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRegionConfig = void 0;
const getRealRegion_1 = __nccwpck_require__(52844);
const isFipsRegion_1 = __nccwpck_require__(82440);
const resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return {
        ...input,
        region: async () => {
            if (typeof region === "string") {
                return (0, getRealRegion_1.getRealRegion)(region);
            }
            const providedRegion = await region();
            return (0, getRealRegion_1.getRealRegion)(providedRegion);
        },
        useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        },
    };
};
exports.resolveRegionConfig = resolveRegionConfig;


/***/ }),

/***/ 3566:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 56057:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 15280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHostnameFromVariants = void 0;
const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => {
    var _a;
    return (_a = variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))) === null || _a === void 0 ? void 0 : _a.hostname;
};
exports.getHostnameFromVariants = getHostnameFromVariants;


/***/ }),

/***/ 26167:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRegionInfo = void 0;
const getHostnameFromVariants_1 = __nccwpck_require__(15280);
const getResolvedHostname_1 = __nccwpck_require__(63877);
const getResolvedPartition_1 = __nccwpck_require__(37642);
const getResolvedSigningRegion_1 = __nccwpck_require__(53517);
const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {
    var _a, _b, _c, _d, _e, _f;
    const partition = (0, getResolvedPartition_1.getResolvedPartition)(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : (_b = (_a = partitionHash[partition]) === null || _a === void 0 ? void 0 : _a.endpoint) !== null && _b !== void 0 ? _b : region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_c = regionHash[resolvedRegion]) === null || _c === void 0 ? void 0 : _c.variants, hostnameOptions);
    const partitionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_d = partitionHash[partition]) === null || _d === void 0 ? void 0 : _d.variants, hostnameOptions);
    const hostname = (0, getResolvedHostname_1.getResolvedHostname)(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
        throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = (0, getResolvedSigningRegion_1.getResolvedSigningRegion)(hostname, {
        signingRegion: (_e = regionHash[resolvedRegion]) === null || _e === void 0 ? void 0 : _e.signingRegion,
        regionRegex: partitionHash[partition].regionRegex,
        useFipsEndpoint,
    });
    return {
        partition,
        signingService,
        hostname,
        ...(signingRegion && { signingRegion }),
        ...(((_f = regionHash[resolvedRegion]) === null || _f === void 0 ? void 0 : _f.signingService) && {
            signingService: regionHash[resolvedRegion].signingService,
        }),
    };
};
exports.getRegionInfo = getRegionInfo;


/***/ }),

/***/ 63877:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedHostname = void 0;
const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname
    ? regionHostname
    : partitionHostname
        ? partitionHostname.replace("{region}", resolvedRegion)
        : undefined;
exports.getResolvedHostname = getResolvedHostname;


/***/ }),

/***/ 37642:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedPartition = void 0;
const getResolvedPartition = (region, { partitionHash }) => { var _a; return (_a = Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region))) !== null && _a !== void 0 ? _a : "aws"; };
exports.getResolvedPartition = getResolvedPartition;


/***/ }),

/***/ 53517:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedSigningRegion = void 0;
const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
        return signingRegion;
    }
    else if (useFipsEndpoint) {
        const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
        const regionRegexmatchArray = hostname.match(regionRegexJs);
        if (regionRegexmatchArray) {
            return regionRegexmatchArray[0].slice(1, -1);
        }
    }
};
exports.getResolvedSigningRegion = getResolvedSigningRegion;


/***/ }),

/***/ 86258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(3566), exports);
tslib_1.__exportStar(__nccwpck_require__(56057), exports);
tslib_1.__exportStar(__nccwpck_require__(26167), exports);


/***/ }),

/***/ 80255:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromEnv = exports.ENV_EXPIRATION = exports.ENV_SESSION = exports.ENV_SECRET = exports.ENV_KEY = void 0;
const property_provider_1 = __nccwpck_require__(74462);
exports.ENV_KEY = "AWS_ACCESS_KEY_ID";
exports.ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
exports.ENV_SESSION = "AWS_SESSION_TOKEN";
exports.ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
const fromEnv = () => async () => {
    const accessKeyId = process.env[exports.ENV_KEY];
    const secretAccessKey = process.env[exports.ENV_SECRET];
    const sessionToken = process.env[exports.ENV_SESSION];
    const expiry = process.env[exports.ENV_EXPIRATION];
    if (accessKeyId && secretAccessKey) {
        return {
            accessKeyId,
            secretAccessKey,
            ...(sessionToken && { sessionToken }),
            ...(expiry && { expiration: new Date(expiry) }),
        };
    }
    throw new property_provider_1.CredentialsProviderError("Unable to find environment variable credentials.");
};
exports.fromEnv = fromEnv;


/***/ }),

/***/ 15972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80255), exports);


/***/ }),

/***/ 3736:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Endpoint = void 0;
var Endpoint;
(function (Endpoint) {
    Endpoint["IPv4"] = "http://169.254.169.254";
    Endpoint["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint = exports.Endpoint || (exports.Endpoint = {}));


/***/ }),

/***/ 18438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENDPOINT_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_NAME = exports.ENV_ENDPOINT_NAME = void 0;
exports.ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
exports.CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
exports.ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_NAME],
    default: undefined,
};


/***/ }),

/***/ 21695:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointMode = void 0;
var EndpointMode;
(function (EndpointMode) {
    EndpointMode["IPv4"] = "IPv4";
    EndpointMode["IPv6"] = "IPv6";
})(EndpointMode = exports.EndpointMode || (exports.EndpointMode = {}));


/***/ }),

/***/ 97824:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENDPOINT_MODE_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_MODE_NAME = exports.ENV_ENDPOINT_MODE_NAME = void 0;
const EndpointMode_1 = __nccwpck_require__(21695);
exports.ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
exports.CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
exports.ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode_1.EndpointMode.IPv4,
};


/***/ }),

/***/ 75232:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromContainerMetadata = exports.ENV_CMDS_AUTH_TOKEN = exports.ENV_CMDS_RELATIVE_URI = exports.ENV_CMDS_FULL_URI = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const url_1 = __nccwpck_require__(57310);
const httpRequest_1 = __nccwpck_require__(81303);
const ImdsCredentials_1 = __nccwpck_require__(91467);
const RemoteProviderInit_1 = __nccwpck_require__(72314);
const retry_1 = __nccwpck_require__(49912);
exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
const fromContainerMetadata = (init = {}) => {
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    return () => (0, retry_1.retry)(async () => {
        const requestOptions = await getCmdsUri();
        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
        if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
            throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
        }
        return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
    }, maxRetries);
};
exports.fromContainerMetadata = fromContainerMetadata;
const requestFromEcsImds = async (timeout, options) => {
    if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
            ...options.headers,
            Authorization: process.env[exports.ENV_CMDS_AUTH_TOKEN],
        };
    }
    const buffer = await (0, httpRequest_1.httpRequest)({
        ...options,
        timeout,
    });
    return buffer.toString();
};
const CMDS_IP = "169.254.170.2";
const GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true,
};
const GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true,
};
const getCmdsUri = async () => {
    if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
        return {
            hostname: CMDS_IP,
            path: process.env[exports.ENV_CMDS_RELATIVE_URI],
        };
    }
    if (process.env[exports.ENV_CMDS_FULL_URI]) {
        const parsed = (0, url_1.parse)(process.env[exports.ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
        }
        return {
            ...parsed,
            port: parsed.port ? parseInt(parsed.port, 10) : undefined,
        };
    }
    throw new property_provider_1.CredentialsProviderError("The container metadata credential provider cannot be used unless" +
        ` the ${exports.ENV_CMDS_RELATIVE_URI} or ${exports.ENV_CMDS_FULL_URI} environment` +
        " variable is set", false);
};


/***/ }),

/***/ 35813:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromInstanceMetadata = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const httpRequest_1 = __nccwpck_require__(81303);
const ImdsCredentials_1 = __nccwpck_require__(91467);
const RemoteProviderInit_1 = __nccwpck_require__(72314);
const retry_1 = __nccwpck_require__(49912);
const getInstanceMetadataEndpoint_1 = __nccwpck_require__(41206);
const staticStabilityProvider_1 = __nccwpck_require__(54620);
const IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
const IMDS_TOKEN_PATH = "/latest/api/token";
const fromInstanceMetadata = (init = {}) => (0, staticStabilityProvider_1.staticStabilityProvider)(getInstanceImdsProvider(init), { logger: init.logger });
exports.fromInstanceMetadata = fromInstanceMetadata;
const getInstanceImdsProvider = (init) => {
    let disableFetchToken = false;
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    const getCredentials = async (maxRetries, options) => {
        const profile = (await (0, retry_1.retry)(async () => {
            let profile;
            try {
                profile = await getProfile(options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return profile;
        }, maxRetries)).trim();
        return (0, retry_1.retry)(async () => {
            let creds;
            try {
                creds = await getCredentialsFromProfile(profile, options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return creds;
        }, maxRetries);
    };
    return async () => {
        const endpoint = await (0, getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint)();
        if (disableFetchToken) {
            return getCredentials(maxRetries, { ...endpoint, timeout });
        }
        else {
            let token;
            try {
                token = (await getMetadataToken({ ...endpoint, timeout })).toString();
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.statusCode) === 400) {
                    throw Object.assign(error, {
                        message: "EC2 Metadata token request returned error",
                    });
                }
                else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
                    disableFetchToken = true;
                }
                return getCredentials(maxRetries, { ...endpoint, timeout });
            }
            return getCredentials(maxRetries, {
                ...endpoint,
                headers: {
                    "x-aws-ec2-metadata-token": token,
                },
                timeout,
            });
        }
    };
};
const getMetadataToken = async (options) => (0, httpRequest_1.httpRequest)({
    ...options,
    path: IMDS_TOKEN_PATH,
    method: "PUT",
    headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600",
    },
});
const getProfile = async (options) => (await (0, httpRequest_1.httpRequest)({ ...options, path: IMDS_PATH })).toString();
const getCredentialsFromProfile = async (profile, options) => {
    const credsResponse = JSON.parse((await (0, httpRequest_1.httpRequest)({
        ...options,
        path: IMDS_PATH + profile,
    })).toString());
    if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
        throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
};


/***/ }),

/***/ 25898:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInstanceMetadataEndpoint = exports.httpRequest = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(75232), exports);
tslib_1.__exportStar(__nccwpck_require__(35813), exports);
tslib_1.__exportStar(__nccwpck_require__(72314), exports);
tslib_1.__exportStar(__nccwpck_require__(91178), exports);
var httpRequest_1 = __nccwpck_require__(81303);
Object.defineProperty(exports, "httpRequest", ({ enumerable: true, get: function () { return httpRequest_1.httpRequest; } }));
var getInstanceMetadataEndpoint_1 = __nccwpck_require__(41206);
Object.defineProperty(exports, "getInstanceMetadataEndpoint", ({ enumerable: true, get: function () { return getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint; } }));


/***/ }),

/***/ 91467:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromImdsCredentials = exports.isImdsCredentials = void 0;
const isImdsCredentials = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.AccessKeyId === "string" &&
    typeof arg.SecretAccessKey === "string" &&
    typeof arg.Token === "string" &&
    typeof arg.Expiration === "string";
exports.isImdsCredentials = isImdsCredentials;
const fromImdsCredentials = (creds) => ({
    accessKeyId: creds.AccessKeyId,
    secretAccessKey: creds.SecretAccessKey,
    sessionToken: creds.Token,
    expiration: new Date(creds.Expiration),
});
exports.fromImdsCredentials = fromImdsCredentials;


/***/ }),

/***/ 72314:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.providerConfigFromInit = exports.DEFAULT_MAX_RETRIES = exports.DEFAULT_TIMEOUT = void 0;
exports.DEFAULT_TIMEOUT = 1000;
exports.DEFAULT_MAX_RETRIES = 0;
const providerConfigFromInit = ({ maxRetries = exports.DEFAULT_MAX_RETRIES, timeout = exports.DEFAULT_TIMEOUT, }) => ({ maxRetries, timeout });
exports.providerConfigFromInit = providerConfigFromInit;


/***/ }),

/***/ 81303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.httpRequest = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const buffer_1 = __nccwpck_require__(14300);
const http_1 = __nccwpck_require__(13685);
function httpRequest(options) {
    return new Promise((resolve, reject) => {
        var _a;
        const req = (0, http_1.request)({
            method: "GET",
            ...options,
            hostname: (_a = options.hostname) === null || _a === void 0 ? void 0 : _a.replace(/^\[(.+)\]$/, "$1"),
        });
        req.on("error", (err) => {
            reject(Object.assign(new property_provider_1.ProviderError("Unable to connect to instance metadata service"), err));
            req.destroy();
        });
        req.on("timeout", () => {
            reject(new property_provider_1.ProviderError("TimeoutError from instance metadata service"));
            req.destroy();
        });
        req.on("response", (res) => {
            const { statusCode = 400 } = res;
            if (statusCode < 200 || 300 <= statusCode) {
                reject(Object.assign(new property_provider_1.ProviderError("Error response received from instance metadata service"), { statusCode }));
                req.destroy();
            }
            const chunks = [];
            res.on("data", (chunk) => {
                chunks.push(chunk);
            });
            res.on("end", () => {
                resolve(buffer_1.Buffer.concat(chunks));
                req.destroy();
            });
        });
        req.end();
    });
}
exports.httpRequest = httpRequest;


/***/ }),

/***/ 49912:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retry = void 0;
const retry = (toRetry, maxRetries) => {
    let promise = toRetry();
    for (let i = 0; i < maxRetries; i++) {
        promise = promise.catch(toRetry);
    }
    return promise;
};
exports.retry = retry;


/***/ }),

/***/ 91178:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 8473:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExtendedInstanceMetadataCredentials = void 0;
const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
const STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
const STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
const getExtendedInstanceMetadataCredentials = (credentials, logger) => {
    var _a;
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS +
        Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " +
        "credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " +
        STATIC_STABILITY_DOC_URL);
    const originalExpiration = (_a = credentials.originalExpiration) !== null && _a !== void 0 ? _a : credentials.expiration;
    return {
        ...credentials,
        ...(originalExpiration ? { originalExpiration } : {}),
        expiration: newExpiration,
    };
};
exports.getExtendedInstanceMetadataCredentials = getExtendedInstanceMetadataCredentials;


/***/ }),

/***/ 41206:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInstanceMetadataEndpoint = void 0;
const node_config_provider_1 = __nccwpck_require__(87684);
const url_parser_1 = __nccwpck_require__(2992);
const Endpoint_1 = __nccwpck_require__(3736);
const EndpointConfigOptions_1 = __nccwpck_require__(18438);
const EndpointMode_1 = __nccwpck_require__(21695);
const EndpointModeConfigOptions_1 = __nccwpck_require__(97824);
const getInstanceMetadataEndpoint = async () => (0, url_parser_1.parseUrl)((await getFromEndpointConfig()) || (await getFromEndpointModeConfig()));
exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
const getFromEndpointConfig = async () => (0, node_config_provider_1.loadConfig)(EndpointConfigOptions_1.ENDPOINT_CONFIG_OPTIONS)();
const getFromEndpointModeConfig = async () => {
    const endpointMode = await (0, node_config_provider_1.loadConfig)(EndpointModeConfigOptions_1.ENDPOINT_MODE_CONFIG_OPTIONS)();
    switch (endpointMode) {
        case EndpointMode_1.EndpointMode.IPv4:
            return Endpoint_1.Endpoint.IPv4;
        case EndpointMode_1.EndpointMode.IPv6:
            return Endpoint_1.Endpoint.IPv6;
        default:
            throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode_1.EndpointMode)}`);
    }
};


/***/ }),

/***/ 54620:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.staticStabilityProvider = void 0;
const getExtendedInstanceMetadataCredentials_1 = __nccwpck_require__(8473);
const staticStabilityProvider = (provider, options = {}) => {
    const logger = (options === null || options === void 0 ? void 0 : options.logger) || console;
    let pastCredentials;
    return async () => {
        let credentials;
        try {
            credentials = await provider();
            if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(credentials, logger);
            }
        }
        catch (e) {
            if (pastCredentials) {
                logger.warn("Credential renew failed: ", e);
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(pastCredentials, logger);
            }
            else {
                throw e;
            }
        }
        pastCredentials = credentials;
        return credentials;
    };
};
exports.staticStabilityProvider = staticStabilityProvider;


/***/ }),

/***/ 55442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromIni = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const resolveProfileData_1 = __nccwpck_require__(95653);
const fromIni = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    return (0, resolveProfileData_1.resolveProfileData)((0, shared_ini_file_loader_1.getProfileName)(init), profiles, init);
};
exports.fromIni = fromIni;


/***/ }),

/***/ 74203:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(55442), exports);


/***/ }),

/***/ 60853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAssumeRoleCredentials = exports.isAssumeRoleProfile = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const resolveCredentialSource_1 = __nccwpck_require__(82458);
const resolveProfileData_1 = __nccwpck_require__(95653);
const isAssumeRoleProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.external_id) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 &&
    (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
exports.isAssumeRoleProfile = isAssumeRoleProfile;
const isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
const isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
const resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (!options.roleAssumer) {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
    }
    const { source_profile } = data;
    if (source_profile && source_profile in visitedProfiles) {
        throw new property_provider_1.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile` +
            ` ${(0, shared_ini_file_loader_1.getProfileName)(options)}. Profiles visited: ` +
            Object.keys(visitedProfiles).join(", "), false);
    }
    const sourceCredsProvider = source_profile
        ? (0, resolveProfileData_1.resolveProfileData)(source_profile, profiles, options, {
            ...visitedProfiles,
            [source_profile]: true,
        })
        : (0, resolveCredentialSource_1.resolveCredentialSource)(data.credential_source, profileName)();
    const params = {
        RoleArn: data.role_arn,
        RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
        ExternalId: data.external_id,
    };
    const { mfa_serial } = data;
    if (mfa_serial) {
        if (!options.mfaCodeProvider) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
        }
        params.SerialNumber = mfa_serial;
        params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params);
};
exports.resolveAssumeRoleCredentials = resolveAssumeRoleCredentials;


/***/ }),

/***/ 82458:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveCredentialSource = void 0;
const credential_provider_env_1 = __nccwpck_require__(15972);
const credential_provider_imds_1 = __nccwpck_require__(25898);
const property_provider_1 = __nccwpck_require__(74462);
const resolveCredentialSource = (credentialSource, profileName) => {
    const sourceProvidersMap = {
        EcsContainer: credential_provider_imds_1.fromContainerMetadata,
        Ec2InstanceMetadata: credential_provider_imds_1.fromInstanceMetadata,
        Environment: credential_provider_env_1.fromEnv,
    };
    if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource]();
    }
    else {
        throw new property_provider_1.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, ` +
            `expected EcsContainer or Ec2InstanceMetadata or Environment.`);
    }
};
exports.resolveCredentialSource = resolveCredentialSource;


/***/ }),

/***/ 69993:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProcessCredentials = exports.isProcessProfile = void 0;
const credential_provider_process_1 = __nccwpck_require__(89969);
const isProcessProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.credential_process === "string";
exports.isProcessProfile = isProcessProfile;
const resolveProcessCredentials = async (options, profile) => (0, credential_provider_process_1.fromProcess)({
    ...options,
    profile,
})();
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 95653:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProfileData = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const resolveAssumeRoleCredentials_1 = __nccwpck_require__(60853);
const resolveProcessCredentials_1 = __nccwpck_require__(69993);
const resolveSsoCredentials_1 = __nccwpck_require__(59867);
const resolveStaticCredentials_1 = __nccwpck_require__(33071);
const resolveWebIdentityCredentials_1 = __nccwpck_require__(58342);
const resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (Object.keys(visitedProfiles).length > 0 && (0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveAssumeRoleCredentials_1.isAssumeRoleProfile)(data)) {
        return (0, resolveAssumeRoleCredentials_1.resolveAssumeRoleCredentials)(profileName, profiles, options, visitedProfiles);
    }
    if ((0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveWebIdentityCredentials_1.isWebIdentityProfile)(data)) {
        return (0, resolveWebIdentityCredentials_1.resolveWebIdentityCredentials)(data, options);
    }
    if ((0, resolveProcessCredentials_1.isProcessProfile)(data)) {
        return (0, resolveProcessCredentials_1.resolveProcessCredentials)(options, profileName);
    }
    if ((0, resolveSsoCredentials_1.isSsoProfile)(data)) {
        return (0, resolveSsoCredentials_1.resolveSsoCredentials)(data);
    }
    throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};
exports.resolveProfileData = resolveProfileData;


/***/ }),

/***/ 59867:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSsoCredentials = exports.isSsoProfile = void 0;
const credential_provider_sso_1 = __nccwpck_require__(26414);
var credential_provider_sso_2 = __nccwpck_require__(26414);
Object.defineProperty(exports, "isSsoProfile", ({ enumerable: true, get: function () { return credential_provider_sso_2.isSsoProfile; } }));
const resolveSsoCredentials = (data) => {
    const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = (0, credential_provider_sso_1.validateSsoProfile)(data);
    return (0, credential_provider_sso_1.fromSSO)({
        ssoStartUrl: sso_start_url,
        ssoAccountId: sso_account_id,
        ssoSession: sso_session,
        ssoRegion: sso_region,
        ssoRoleName: sso_role_name,
    })();
};
exports.resolveSsoCredentials = resolveSsoCredentials;


/***/ }),

/***/ 33071:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveStaticCredentials = exports.isStaticCredsProfile = void 0;
const isStaticCredsProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.aws_access_key_id === "string" &&
    typeof arg.aws_secret_access_key === "string" &&
    ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
exports.isStaticCredsProfile = isStaticCredsProfile;
const resolveStaticCredentials = (profile) => Promise.resolve({
    accessKeyId: profile.aws_access_key_id,
    secretAccessKey: profile.aws_secret_access_key,
    sessionToken: profile.aws_session_token,
});
exports.resolveStaticCredentials = resolveStaticCredentials;


/***/ }),

/***/ 58342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveWebIdentityCredentials = exports.isWebIdentityProfile = void 0;
const credential_provider_web_identity_1 = __nccwpck_require__(15646);
const isWebIdentityProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.web_identity_token_file === "string" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
exports.isWebIdentityProfile = isWebIdentityProfile;
const resolveWebIdentityCredentials = async (profile, options) => (0, credential_provider_web_identity_1.fromTokenFile)({
    webIdentityTokenFile: profile.web_identity_token_file,
    roleArn: profile.role_arn,
    roleSessionName: profile.role_session_name,
    roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
})();
exports.resolveWebIdentityCredentials = resolveWebIdentityCredentials;


/***/ }),

/***/ 15560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultProvider = void 0;
const credential_provider_env_1 = __nccwpck_require__(15972);
const credential_provider_ini_1 = __nccwpck_require__(74203);
const credential_provider_process_1 = __nccwpck_require__(89969);
const credential_provider_sso_1 = __nccwpck_require__(26414);
const credential_provider_web_identity_1 = __nccwpck_require__(15646);
const property_provider_1 = __nccwpck_require__(74462);
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const remoteProvider_1 = __nccwpck_require__(50626);
const defaultProvider = (init = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)(...(init.profile || process.env[shared_ini_file_loader_1.ENV_PROFILE] ? [] : [(0, credential_provider_env_1.fromEnv)()]), (0, credential_provider_sso_1.fromSSO)(init), (0, credential_provider_ini_1.fromIni)(init), (0, credential_provider_process_1.fromProcess)(init), (0, credential_provider_web_identity_1.fromTokenFile)(init), (0, remoteProvider_1.remoteProvider)(init), async () => {
    throw new property_provider_1.CredentialsProviderError("Could not load credentials from any providers", false);
}), (credentials) => credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000, (credentials) => credentials.expiration !== undefined);
exports.defaultProvider = defaultProvider;


/***/ }),

/***/ 75531:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(15560), exports);


/***/ }),

/***/ 50626:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.remoteProvider = exports.ENV_IMDS_DISABLED = void 0;
const credential_provider_imds_1 = __nccwpck_require__(25898);
const property_provider_1 = __nccwpck_require__(74462);
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const remoteProvider = (init) => {
    if (process.env[credential_provider_imds_1.ENV_CMDS_RELATIVE_URI] || process.env[credential_provider_imds_1.ENV_CMDS_FULL_URI]) {
        return (0, credential_provider_imds_1.fromContainerMetadata)(init);
    }
    if (process.env[exports.ENV_IMDS_DISABLED]) {
        return async () => {
            throw new property_provider_1.CredentialsProviderError("EC2 Instance Metadata Service access disabled");
        };
    }
    return (0, credential_provider_imds_1.fromInstanceMetadata)(init);
};
exports.remoteProvider = remoteProvider;


/***/ }),

/***/ 72650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromProcess = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const resolveProcessCredentials_1 = __nccwpck_require__(74926);
const fromProcess = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    return (0, resolveProcessCredentials_1.resolveProcessCredentials)((0, shared_ini_file_loader_1.getProfileName)(init), profiles);
};
exports.fromProcess = fromProcess;


/***/ }),

/***/ 41104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValidatedProcessCredentials = void 0;
const getValidatedProcessCredentials = (profileName, data) => {
    if (data.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
    }
    if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
    }
    if (data.Expiration) {
        const currentTime = new Date();
        const expireTime = new Date(data.Expiration);
        if (expireTime < currentTime) {
            throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
    }
    return {
        accessKeyId: data.AccessKeyId,
        secretAccessKey: data.SecretAccessKey,
        ...(data.SessionToken && { sessionToken: data.SessionToken }),
        ...(data.Expiration && { expiration: new Date(data.Expiration) }),
    };
};
exports.getValidatedProcessCredentials = getValidatedProcessCredentials;


/***/ }),

/***/ 89969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(72650), exports);


/***/ }),

/***/ 74926:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProcessCredentials = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const child_process_1 = __nccwpck_require__(32081);
const util_1 = __nccwpck_require__(73837);
const getValidatedProcessCredentials_1 = __nccwpck_require__(41104);
const resolveProcessCredentials = async (profileName, profiles) => {
    const profile = profiles[profileName];
    if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== undefined) {
            const execPromise = (0, util_1.promisify)(child_process_1.exec);
            try {
                const { stdout } = await execPromise(credentialProcess);
                let data;
                try {
                    data = JSON.parse(stdout.trim());
                }
                catch (_a) {
                    throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
                }
                return (0, getValidatedProcessCredentials_1.getValidatedProcessCredentials)(profileName, data);
            }
            catch (error) {
                throw new property_provider_1.CredentialsProviderError(error.message);
            }
        }
        else {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
        }
    }
    else {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
    }
};
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 35959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSSO = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const isSsoProfile_1 = __nccwpck_require__(32572);
const resolveSSOCredentials_1 = __nccwpck_require__(94729);
const validateSsoProfile_1 = __nccwpck_require__(48098);
const fromSSO = (init = {}) => async () => {
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
        const profile = profiles[profileName];
        if (!profile) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} was not found.`);
        }
        if (!(0, isSsoProfile_1.isSsoProfile)(profile)) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
        }
        if (profile === null || profile === void 0 ? void 0 : profile.sso_session) {
            const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
            const session = ssoSessions[profile.sso_session];
            const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
            if (ssoRegion && ssoRegion !== session.sso_region) {
                throw new property_provider_1.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
            }
            if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
                throw new property_provider_1.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
            }
            profile.sso_region = session.sso_region;
            profile.sso_start_url = session.sso_start_url;
        }
        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = (0, validateSsoProfile_1.validateSsoProfile)(profile);
        return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
            ssoStartUrl: sso_start_url,
            ssoSession: sso_session,
            ssoAccountId: sso_account_id,
            ssoRegion: sso_region,
            ssoRoleName: sso_role_name,
            ssoClient: ssoClient,
            profile: profileName,
        });
    }
    else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
        throw new property_provider_1.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " +
            '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
    }
    else {
        return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
            ssoStartUrl,
            ssoSession,
            ssoAccountId,
            ssoRegion,
            ssoRoleName,
            ssoClient,
            profile: profileName,
        });
    }
};
exports.fromSSO = fromSSO;


/***/ }),

/***/ 26414:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(35959), exports);
tslib_1.__exportStar(__nccwpck_require__(32572), exports);
tslib_1.__exportStar(__nccwpck_require__(86623), exports);
tslib_1.__exportStar(__nccwpck_require__(48098), exports);


/***/ }),

/***/ 32572:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSsoProfile = void 0;
const isSsoProfile = (arg) => arg &&
    (typeof arg.sso_start_url === "string" ||
        typeof arg.sso_account_id === "string" ||
        typeof arg.sso_session === "string" ||
        typeof arg.sso_region === "string" ||
        typeof arg.sso_role_name === "string");
exports.isSsoProfile = isSsoProfile;


/***/ }),

/***/ 94729:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSSOCredentials = void 0;
const client_sso_1 = __nccwpck_require__(82666);
const property_provider_1 = __nccwpck_require__(74462);
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const token_providers_1 = __nccwpck_require__(52843);
const EXPIRE_WINDOW_MS = 15 * 60 * 1000;
const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
const resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile, }) => {
    let token;
    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
    if (ssoSession) {
        try {
            const _token = await (0, token_providers_1.fromSso)({ profile })();
            token = {
                accessToken: _token.token,
                expiresAt: new Date(_token.expiration).toISOString(),
            };
        }
        catch (e) {
            throw new property_provider_1.CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    else {
        try {
            token = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoStartUrl);
        }
        catch (e) {
            throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
        throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { accessToken } = token;
    const sso = ssoClient || new client_sso_1.SSOClient({ region: ssoRegion });
    let ssoResp;
    try {
        ssoResp = await sso.send(new client_sso_1.GetRoleCredentialsCommand({
            accountId: ssoAccountId,
            roleName: ssoRoleName,
            accessToken,
        }));
    }
    catch (e) {
        throw property_provider_1.CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new property_provider_1.CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration) };
};
exports.resolveSSOCredentials = resolveSSOCredentials;


/***/ }),

/***/ 86623:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 48098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSsoProfile = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const validateSsoProfile = (profile) => {
    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new property_provider_1.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` +
            `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
    }
    return profile;
};
exports.validateSsoProfile = validateSsoProfile;


/***/ }),

/***/ 35614:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromTokenFile = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const fs_1 = __nccwpck_require__(57147);
const fromWebToken_1 = __nccwpck_require__(47905);
const ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
const ENV_ROLE_ARN = "AWS_ROLE_ARN";
const ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
const fromTokenFile = (init = {}) => async () => {
    return resolveTokenFile(init);
};
exports.fromTokenFile = fromTokenFile;
const resolveTokenFile = (init) => {
    var _a, _b, _c;
    const webIdentityTokenFile = (_a = init === null || init === void 0 ? void 0 : init.webIdentityTokenFile) !== null && _a !== void 0 ? _a : process.env[ENV_TOKEN_FILE];
    const roleArn = (_b = init === null || init === void 0 ? void 0 : init.roleArn) !== null && _b !== void 0 ? _b : process.env[ENV_ROLE_ARN];
    const roleSessionName = (_c = init === null || init === void 0 ? void 0 : init.roleSessionName) !== null && _c !== void 0 ? _c : process.env[ENV_ROLE_SESSION_NAME];
    if (!webIdentityTokenFile || !roleArn) {
        throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified");
    }
    return (0, fromWebToken_1.fromWebToken)({
        ...init,
        webIdentityToken: (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
        roleArn,
        roleSessionName,
    })();
};


/***/ }),

/***/ 47905:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromWebToken = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const fromWebToken = (init) => () => {
    const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity, } = init;
    if (!roleAssumerWithWebIdentity) {
        throw new property_provider_1.CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity,` +
            ` but no role assumption callback was provided.`, false);
    }
    return roleAssumerWithWebIdentity({
        RoleArn: roleArn,
        RoleSessionName: roleSessionName !== null && roleSessionName !== void 0 ? roleSessionName : `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        ProviderId: providerId,
        PolicyArns: policyArns,
        Policy: policy,
        DurationSeconds: durationSeconds,
    });
};
exports.fromWebToken = fromWebToken;


/***/ }),

/***/ 15646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(35614), exports);
tslib_1.__exportStar(__nccwpck_require__(47905), exports);


/***/ }),

/***/ 97442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash = void 0;
const util_buffer_from_1 = __nccwpck_require__(36010);
const buffer_1 = __nccwpck_require__(14300);
const crypto_1 = __nccwpck_require__(6113);
class Hash {
    constructor(algorithmIdentifier, secret) {
        this.hash = secret ? (0, crypto_1.createHmac)(algorithmIdentifier, castSourceData(secret)) : (0, crypto_1.createHash)(algorithmIdentifier);
    }
    update(toHash, encoding) {
        this.hash.update(castSourceData(toHash, encoding));
    }
    digest() {
        return Promise.resolve(this.hash.digest());
    }
}
exports.Hash = Hash;
function castSourceData(toCast, encoding) {
    if (buffer_1.Buffer.isBuffer(toCast)) {
        return toCast;
    }
    if (typeof toCast === "string") {
        return (0, util_buffer_from_1.fromString)(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
        return (0, util_buffer_from_1.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(toCast);
}


/***/ }),

/***/ 69126:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArrayBuffer = void 0;
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
exports.isArrayBuffer = isArrayBuffer;


/***/ }),

/***/ 42245:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContentLengthPlugin = exports.contentLengthMiddlewareOptions = exports.contentLengthMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
        const request = args.request;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            const { body, headers } = request;
            if (body &&
                Object.keys(headers)
                    .map((str) => str.toLowerCase())
                    .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                try {
                    const length = bodyLengthChecker(body);
                    request.headers = {
                        ...request.headers,
                        [CONTENT_LENGTH_HEADER]: String(length),
                    };
                }
                catch (error) {
                }
            }
        }
        return next({
            ...args,
            request,
        });
    };
}
exports.contentLengthMiddleware = contentLengthMiddleware;
exports.contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true,
};
const getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), exports.contentLengthMiddlewareOptions);
    },
});
exports.getContentLengthPlugin = getContentLengthPlugin;


/***/ }),

/***/ 53504:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConfigValueProvider = void 0;
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        var _a;
        const configValue = (_a = config[configKey]) !== null && _a !== void 0 ? _a : config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};
exports.createConfigValueProvider = createConfigValueProvider;


/***/ }),

/***/ 62419:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveParams = exports.getEndpointFromInstructions = void 0;
const service_customizations_1 = __nccwpck_require__(3589);
const createConfigValueProvider_1 = __nccwpck_require__(53504);
const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    const endpointParams = await (0, exports.resolveParams)(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
exports.getEndpointFromInstructions = getEndpointFromInstructions;
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    var _a;
    const endpointParams = {};
    const instructions = ((_a = instructionsSupplier === null || instructionsSupplier === void 0 ? void 0 : instructionsSupplier.getEndpointParameterInstructions) === null || _a === void 0 ? void 0 : _a.call(instructionsSupplier)) || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await (0, createConfigValueProvider_1.createConfigValueProvider)(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await (0, service_customizations_1.resolveParamsForS3)(endpointParams);
    }
    return endpointParams;
};
exports.resolveParams = resolveParams;


/***/ }),

/***/ 50197:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(62419), exports);
tslib_1.__exportStar(__nccwpck_require__(98289), exports);


/***/ }),

/***/ 98289:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toEndpointV1 = void 0;
const url_parser_1 = __nccwpck_require__(2992);
const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return (0, url_parser_1.parseUrl)(endpoint.url);
        }
        return endpoint;
    }
    return (0, url_parser_1.parseUrl)(endpoint);
};
exports.toEndpointV1 = toEndpointV1;


/***/ }),

/***/ 72639:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.endpointMiddleware = void 0;
const getEndpointFromInstructions_1 = __nccwpck_require__(62419);
const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        var _a, _b;
        const endpoint = await (0, getEndpointFromInstructions_1.getEndpointFromInstructions)(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = (_a = endpoint.properties) === null || _a === void 0 ? void 0 : _a.authSchemes;
        const authScheme = (_b = context.authSchemes) === null || _b === void 0 ? void 0 : _b[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
        }
        return next({
            ...args,
        });
    };
};
exports.endpointMiddleware = endpointMiddleware;


/***/ }),

/***/ 37981:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointPlugin = exports.endpointMiddlewareOptions = void 0;
const middleware_serde_1 = __nccwpck_require__(93631);
const endpointMiddleware_1 = __nccwpck_require__(72639);
exports.endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_serde_1.serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, endpointMiddleware_1.endpointMiddleware)({
            config,
            instructions,
        }), exports.endpointMiddlewareOptions);
    },
});
exports.getEndpointPlugin = getEndpointPlugin;


/***/ }),

/***/ 5497:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(50197), exports);
tslib_1.__exportStar(__nccwpck_require__(72639), exports);
tslib_1.__exportStar(__nccwpck_require__(37981), exports);
tslib_1.__exportStar(__nccwpck_require__(13157), exports);
tslib_1.__exportStar(__nccwpck_require__(32521), exports);


/***/ }),

/***/ 13157:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpointConfig = void 0;
const util_middleware_1 = __nccwpck_require__(10236);
const toEndpointV1_1 = __nccwpck_require__(98289);
const resolveEndpointConfig = (input) => {
    var _a, _b, _c;
    const tls = (_a = input.tls) !== null && _a !== void 0 ? _a : true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => (0, toEndpointV1_1.toEndpointV1)(await (0, util_middleware_1.normalizeProvider)(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false),
        useFipsEndpoint: (0, util_middleware_1.normalizeProvider)((_c = input.useFipsEndpoint) !== null && _c !== void 0 ? _c : false),
    };
};
exports.resolveEndpointConfig = resolveEndpointConfig;


/***/ }),

/***/ 3589:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18648), exports);


/***/ }),

/***/ 18648:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArnBucketName = exports.isDnsCompatibleBucketName = exports.S3_HOSTNAME_PATTERN = exports.DOT_PATTERN = exports.resolveParamsForS3 = void 0;
const resolveParamsForS3 = async (endpointParams) => {
    const bucket = (endpointParams === null || endpointParams === void 0 ? void 0 : endpointParams.Bucket) || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if ((0, exports.isArnBucketName)(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!(0, exports.isDnsCompatibleBucketName)(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
exports.resolveParamsForS3 = resolveParamsForS3;
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
exports.DOT_PATTERN = /\./;
exports.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
exports.isDnsCompatibleBucketName = isDnsCompatibleBucketName;
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, region, account, typeOrId] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = [arn, partition, service, account, typeOrId].filter(Boolean).length === 5;
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return arn === "arn" && !!partition && !!service && !!account && !!typeOrId;
};
exports.isArnBucketName = isArnBucketName;


/***/ }),

/***/ 32521:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 22545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHostHeaderPlugin = exports.hostHeaderMiddlewareOptions = exports.hostHeaderMiddleware = exports.resolveHostHeaderConfig = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
function resolveHostHeaderConfig(input) {
    return input;
}
exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
const hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
        return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = "";
    }
    else if (!request.headers["host"]) {
        request.headers["host"] = request.hostname;
    }
    return next(args);
};
exports.hostHeaderMiddleware = hostHeaderMiddleware;
exports.hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true,
};
const getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.hostHeaderMiddleware)(options), exports.hostHeaderMiddlewareOptions);
    },
});
exports.getHostHeaderPlugin = getHostHeaderPlugin;


/***/ }),

/***/ 20014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(9754), exports);


/***/ }),

/***/ 9754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLoggerPlugin = exports.loggerMiddlewareOptions = exports.loggerMiddleware = void 0;
const loggerMiddleware = () => (next, context) => async (args) => {
    const response = await next(args);
    const { clientName, commandName, logger, inputFilterSensitiveLog, outputFilterSensitiveLog, dynamoDbDocumentClientOptions = {}, } = context;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    if (!logger) {
        return response;
    }
    if (typeof logger.info === "function") {
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger.info({
            clientName,
            commandName,
            input: (overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== void 0 ? overrideInputFilterSensitiveLog : inputFilterSensitiveLog)(args.input),
            output: (overrideOutputFilterSensitiveLog !== null && overrideOutputFilterSensitiveLog !== void 0 ? overrideOutputFilterSensitiveLog : outputFilterSensitiveLog)(outputWithoutMetadata),
            metadata: $metadata,
        });
    }
    return response;
};
exports.loggerMiddleware = loggerMiddleware;
exports.loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true,
};
const getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.loggerMiddleware)(), exports.loggerMiddlewareOptions);
    },
});
exports.getLoggerPlugin = getLoggerPlugin;


/***/ }),

/***/ 85525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRecursionDetectionPlugin = exports.addRecursionDetectionMiddlewareOptions = exports.recursionDetectionMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options) => (next) => async (args) => {
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request) ||
        options.runtime !== "node" ||
        request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
        return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceId = process.env[ENV_TRACE_ID];
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
        ...args,
        request,
    });
};
exports.recursionDetectionMiddleware = recursionDetectionMiddleware;
exports.addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low",
};
const getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.recursionDetectionMiddleware)(options), exports.addRecursionDetectionMiddlewareOptions);
    },
});
exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;


/***/ }),

/***/ 47328:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveRetryStrategy = void 0;
const util_retry_1 = __nccwpck_require__(99395);
const StandardRetryStrategy_1 = __nccwpck_require__(533);
class AdaptiveRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        const { rateLimiter, ...superOptions } = options !== null && options !== void 0 ? options : {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new util_retry_1.DefaultRateLimiter();
        this.mode = util_retry_1.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
        return super.retry(next, args, {
            beforeRequest: async () => {
                return this.rateLimiter.getSendToken();
            },
            afterRequest: (response) => {
                this.rateLimiter.updateClientSendingRate(response);
            },
        });
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 533:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardRetryStrategy = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const service_error_classification_1 = __nccwpck_require__(61921);
const util_retry_1 = __nccwpck_require__(99395);
const uuid_1 = __nccwpck_require__(40726);
const defaultRetryQuota_1 = __nccwpck_require__(12568);
const delayDecider_1 = __nccwpck_require__(55940);
const retryDecider_1 = __nccwpck_require__(19572);
const util_1 = __nccwpck_require__(17154);
class StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        var _a, _b, _c;
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = util_retry_1.RETRY_MODES.STANDARD;
        this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : retryDecider_1.defaultRetryDecider;
        this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : delayDecider_1.defaultDelayDecider;
        this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(util_retry_1.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
        let maxAttempts;
        try {
            maxAttempts = await this.maxAttemptsProvider();
        }
        catch (error) {
            maxAttempts = util_retry_1.DEFAULT_MAX_ATTEMPTS;
        }
        return maxAttempts;
    }
    async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
        }
        while (true) {
            try {
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                if (options === null || options === void 0 ? void 0 : options.beforeRequest) {
                    await options.beforeRequest();
                }
                const { response, output } = await next(args);
                if (options === null || options === void 0 ? void 0 : options.afterRequest) {
                    options.afterRequest(response);
                }
                this.retryQuota.releaseRetryTokens(retryTokenAmount);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalDelay;
                return { response, output };
            }
            catch (e) {
                const err = (0, util_1.asSdkError)(e);
                attempts++;
                if (this.shouldRetry(err, attempts, maxAttempts)) {
                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                    const delayFromDecider = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? util_retry_1.THROTTLING_RETRY_DELAY_BASE : util_retry_1.DEFAULT_RETRY_DELAY_BASE, attempts);
                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);
                    totalDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    continue;
                }
                if (!err.$metadata) {
                    err.$metadata = {};
                }
                err.$metadata.attempts = attempts;
                err.$metadata.totalRetryDelay = totalDelay;
                throw err;
            }
        }
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;
const getDelayFromRetryAfterHeader = (response) => {
    if (!protocol_http_1.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
};


/***/ }),

/***/ 76160:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = exports.CONFIG_RETRY_MODE = exports.ENV_RETRY_MODE = exports.resolveRetryConfig = exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = exports.CONFIG_MAX_ATTEMPTS = exports.ENV_MAX_ATTEMPTS = void 0;
const util_middleware_1 = __nccwpck_require__(10236);
const util_retry_1 = __nccwpck_require__(99395);
exports.ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
exports.CONFIG_MAX_ATTEMPTS = "max_attempts";
exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        const value = env[exports.ENV_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${exports.ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    configFileSelector: (profile) => {
        const value = profile[exports.CONFIG_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${exports.CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    default: util_retry_1.DEFAULT_MAX_ATTEMPTS,
};
const resolveRetryConfig = (input) => {
    var _a;
    const { retryStrategy } = input;
    const maxAttempts = (0, util_middleware_1.normalizeProvider)((_a = input.maxAttempts) !== null && _a !== void 0 ? _a : util_retry_1.DEFAULT_MAX_ATTEMPTS);
    return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
            if (retryStrategy) {
                return retryStrategy;
            }
            const retryMode = await (0, util_middleware_1.normalizeProvider)(input.retryMode)();
            if (retryMode === util_retry_1.RETRY_MODES.ADAPTIVE) {
                return new util_retry_1.AdaptiveRetryStrategy(maxAttempts);
            }
            return new util_retry_1.StandardRetryStrategy(maxAttempts);
        },
    };
};
exports.resolveRetryConfig = resolveRetryConfig;
exports.ENV_RETRY_MODE = "AWS_RETRY_MODE";
exports.CONFIG_RETRY_MODE = "retry_mode";
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[exports.CONFIG_RETRY_MODE],
    default: util_retry_1.DEFAULT_RETRY_MODE,
};


/***/ }),

/***/ 12568:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRetryQuota = void 0;
const util_retry_1 = __nccwpck_require__(99395);
const getDefaultRetryQuota = (initialRetryTokens, options) => {
    var _a, _b, _c;
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : util_retry_1.NO_RETRY_INCREMENT;
    const retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : util_retry_1.RETRY_COST;
    const timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : util_retry_1.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => (error.name === "TimeoutError" ? timeoutRetryCost : retryCost);
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
        if (!hasRetryTokens(error)) {
            throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error);
        availableCapacity -= capacityAmount;
        return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
        availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens,
    });
};
exports.getDefaultRetryQuota = getDefaultRetryQuota;


/***/ }),

/***/ 55940:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultDelayDecider = void 0;
const util_retry_1 = __nccwpck_require__(99395);
const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(util_retry_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
exports.defaultDelayDecider = defaultDelayDecider;


/***/ }),

/***/ 96064:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(47328), exports);
tslib_1.__exportStar(__nccwpck_require__(533), exports);
tslib_1.__exportStar(__nccwpck_require__(76160), exports);
tslib_1.__exportStar(__nccwpck_require__(55940), exports);
tslib_1.__exportStar(__nccwpck_require__(43521), exports);
tslib_1.__exportStar(__nccwpck_require__(19572), exports);
tslib_1.__exportStar(__nccwpck_require__(11806), exports);


/***/ }),

/***/ 43521:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOmitRetryHeadersPlugin = exports.omitRetryHeadersMiddlewareOptions = exports.omitRetryHeadersMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const util_retry_1 = __nccwpck_require__(99395);
const omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (protocol_http_1.HttpRequest.isInstance(request)) {
        delete request.headers[util_retry_1.INVOCATION_ID_HEADER];
        delete request.headers[util_retry_1.REQUEST_HEADER];
    }
    return next(args);
};
exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
exports.omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true,
};
const getOmitRetryHeadersPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.omitRetryHeadersMiddleware)(), exports.omitRetryHeadersMiddlewareOptions);
    },
});
exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;


/***/ }),

/***/ 19572:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultRetryDecider = void 0;
const service_error_classification_1 = __nccwpck_require__(61921);
const defaultRetryDecider = (error) => {
    if (!error) {
        return false;
    }
    return (0, service_error_classification_1.isRetryableByTrait)(error) || (0, service_error_classification_1.isClockSkewError)(error) || (0, service_error_classification_1.isThrottlingError)(error) || (0, service_error_classification_1.isTransientError)(error);
};
exports.defaultRetryDecider = defaultRetryDecider;


/***/ }),

/***/ 11806:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRetryAfterHint = exports.getRetryPlugin = exports.retryMiddlewareOptions = exports.retryMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const service_error_classification_1 = __nccwpck_require__(61921);
const util_retry_1 = __nccwpck_require__(99395);
const uuid_1 = __nccwpck_require__(40726);
const util_1 = __nccwpck_require__(17154);
const retryMiddleware = (options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
        }
        while (true) {
            try {
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                const { response, output } = await next(args);
                retryStrategy.recordSuccess(retryToken);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalRetryDelay;
                return { response, output };
            }
            catch (e) {
                const retryErrorInfo = getRetyErrorInto(e);
                lastError = (0, util_1.asSdkError)(e);
                try {
                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                }
                catch (refreshError) {
                    if (!lastError.$metadata) {
                        lastError.$metadata = {};
                    }
                    lastError.$metadata.attempts = attempts + 1;
                    lastError.$metadata.totalRetryDelay = totalRetryDelay;
                    throw lastError;
                }
                attempts = retryToken.getRetryCount();
                const delay = retryToken.getRetryDelay();
                totalRetryDelay += delay;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
    }
    else {
        retryStrategy = retryStrategy;
        if (retryStrategy === null || retryStrategy === void 0 ? void 0 : retryStrategy.mode)
            context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
    }
};
exports.retryMiddleware = retryMiddleware;
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
    typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
    typeof retryStrategy.recordSuccess !== "undefined";
const getRetyErrorInto = (error) => {
    const errorInfo = {
        errorType: getRetryErrorType(error),
    };
    const retryAfterHint = (0, exports.getRetryAfterHint)(error.$response);
    if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
};
const getRetryErrorType = (error) => {
    if ((0, service_error_classification_1.isThrottlingError)(error))
        return "THROTTLING";
    if ((0, service_error_classification_1.isTransientError)(error))
        return "TRANSIENT";
    if ((0, service_error_classification_1.isServerError)(error))
        return "SERVER_ERROR";
    return "CLIENT_ERROR";
};
exports.retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true,
};
const getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.retryMiddleware)(options), exports.retryMiddlewareOptions);
    },
});
exports.getRetryPlugin = getRetryPlugin;
const getRetryAfterHint = (response) => {
    if (!protocol_http_1.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
};
exports.getRetryAfterHint = getRetryAfterHint;


/***/ }),

/***/ 17154:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asSdkError = void 0;
const asSdkError = (error) => {
    if (error instanceof Error)
        return error;
    if (error instanceof Object)
        return Object.assign(new Error(), error);
    if (typeof error === "string")
        return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
};
exports.asSdkError = asSdkError;


/***/ }),

/***/ 40726:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(37800));

var _v2 = _interopRequireDefault(__nccwpck_require__(67161));

var _v3 = _interopRequireDefault(__nccwpck_require__(781));

var _v4 = _interopRequireDefault(__nccwpck_require__(91002));

var _nil = _interopRequireDefault(__nccwpck_require__(79870));

var _version = _interopRequireDefault(__nccwpck_require__(97928));

var _validate = _interopRequireDefault(__nccwpck_require__(41962));

var _stringify = _interopRequireDefault(__nccwpck_require__(60110));

var _parse = _interopRequireDefault(__nccwpck_require__(64514));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 8981:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 79870:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 64514:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(41962));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 50642:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 69799:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 98158:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 60110:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(41962));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 37800:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(69799));

var _stringify = _interopRequireDefault(__nccwpck_require__(60110));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 67161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65011));

var _md = _interopRequireDefault(__nccwpck_require__(8981));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 65011:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(60110));

var _parse = _interopRequireDefault(__nccwpck_require__(64514));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(69799));

var _stringify = _interopRequireDefault(__nccwpck_require__(60110));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 91002:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65011));

var _sha = _interopRequireDefault(__nccwpck_require__(98158));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 41962:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(50642));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 97928:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(41962));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 55959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveStsAuthConfig = void 0;
const middleware_signing_1 = __nccwpck_require__(14935);
const resolveStsAuthConfig = (input, { stsClientCtor }) => (0, middleware_signing_1.resolveAwsAuthConfig)({
    ...input,
    stsClientCtor,
});
exports.resolveStsAuthConfig = resolveStsAuthConfig;


/***/ }),

/***/ 65648:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializerMiddleware = void 0;
const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        throw error;
    }
};
exports.deserializerMiddleware = deserializerMiddleware;


/***/ }),

/***/ 93631:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(65648), exports);
tslib_1.__exportStar(__nccwpck_require__(99328), exports);
tslib_1.__exportStar(__nccwpck_require__(19511), exports);


/***/ }),

/***/ 99328:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSerdePlugin = exports.serializerMiddlewareOption = exports.deserializerMiddlewareOption = void 0;
const deserializerMiddleware_1 = __nccwpck_require__(65648);
const serializerMiddleware_1 = __nccwpck_require__(19511);
exports.deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
exports.serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add((0, deserializerMiddleware_1.deserializerMiddleware)(config, deserializer), exports.deserializerMiddlewareOption);
            commandStack.add((0, serializerMiddleware_1.serializerMiddleware)(config, serializer), exports.serializerMiddlewareOption);
        },
    };
}
exports.getSerdePlugin = getSerdePlugin;


/***/ }),

/***/ 19511:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializerMiddleware = void 0;
const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    var _a;
    const endpoint = ((_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.url) && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};
exports.serializerMiddleware = serializerMiddleware;


/***/ }),

/***/ 63061:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSigV4AuthConfig = exports.resolveAwsAuthConfig = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const signature_v4_1 = __nccwpck_require__(37776);
const util_middleware_1 = __nccwpck_require__(10236);
const CREDENTIAL_EXPIRE_WINDOW = 300000;
const resolveAwsAuthConfig = (input) => {
    const normalizedCreds = input.credentials
        ? normalizeCredentialProvider(input.credentials)
        : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    }
    else if (input.regionInfoProvider) {
        signer = () => (0, util_middleware_1.normalizeProvider)(input.region)()
            .then(async (region) => [
            (await input.regionInfoProvider(region, {
                useFipsEndpoint: await input.useFipsEndpoint(),
                useDualstackEndpoint: await input.useDualstackEndpoint(),
            })) || {},
            region,
        ])
            .then(([regionInfo, region]) => {
            const { signingRegion, signingService } = regionInfo;
            input.signingRegion = input.signingRegion || signingRegion || region;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
                ...input,
                credentials: normalizedCreds,
                region: input.signingRegion,
                service: input.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        });
    }
    else {
        signer = async (authScheme) => {
            authScheme = Object.assign({}, {
                name: "sigv4",
                signingName: input.signingName || input.defaultSigningName,
                signingRegion: await (0, util_middleware_1.normalizeProvider)(input.region)(),
                properties: {},
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            input.signingRegion = input.signingRegion || signingRegion;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
                ...input,
                credentials: normalizedCreds,
                region: input.signingRegion,
                service: input.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        };
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer,
    };
};
exports.resolveAwsAuthConfig = resolveAwsAuthConfig;
const resolveSigV4AuthConfig = (input) => {
    const normalizedCreds = input.credentials
        ? normalizeCredentialProvider(input.credentials)
        : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    }
    else {
        signer = (0, util_middleware_1.normalizeProvider)(new signature_v4_1.SignatureV4({
            credentials: normalizedCreds,
            region: input.region,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath,
        }));
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer,
    };
};
exports.resolveSigV4AuthConfig = resolveSigV4AuthConfig;
const normalizeCredentialProvider = (credentials) => {
    if (typeof credentials === "function") {
        return (0, property_provider_1.memoize)(credentials, (credentials) => credentials.expiration !== undefined &&
            credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials) => credentials.expiration !== undefined);
    }
    return (0, util_middleware_1.normalizeProvider)(credentials);
};


/***/ }),

/***/ 14935:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(63061), exports);
tslib_1.__exportStar(__nccwpck_require__(42509), exports);


/***/ }),

/***/ 42509:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin = exports.awsAuthMiddlewareOptions = exports.awsAuthMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const getSkewCorrectedDate_1 = __nccwpck_require__(68253);
const getUpdatedSystemClockOffset_1 = __nccwpck_require__(35863);
const awsAuthMiddleware = (options) => (next, context) => async function (args) {
    var _a, _b, _c, _d;
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
        return next(args);
    const authScheme = (_c = (_b = (_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.authSchemes) === null || _c === void 0 ? void 0 : _c[0];
    const multiRegionOverride = (authScheme === null || authScheme === void 0 ? void 0 : authScheme.name) === "sigv4a" ? (_d = authScheme === null || authScheme === void 0 ? void 0 : authScheme.signingRegionSet) === null || _d === void 0 ? void 0 : _d.join(",") : undefined;
    const signer = await options.signer(authScheme);
    const output = await next({
        ...args,
        request: await signer.sign(args.request, {
            signingDate: (0, getSkewCorrectedDate_1.getSkewCorrectedDate)(options.systemClockOffset),
            signingRegion: multiRegionOverride || context["signing_region"],
            signingService: context["signing_service"],
        }),
    }).catch((error) => {
        var _a;
        const serverTime = (_a = error.ServerTime) !== null && _a !== void 0 ? _a : getDateHeader(error.$response);
        if (serverTime) {
            options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(serverTime, options.systemClockOffset);
        }
        throw error;
    });
    const dateHeader = getDateHeader(output.response);
    if (dateHeader) {
        options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(dateHeader, options.systemClockOffset);
    }
    return output;
};
exports.awsAuthMiddleware = awsAuthMiddleware;
const getDateHeader = (response) => { var _a, _b, _c; return protocol_http_1.HttpResponse.isInstance(response) ? (_b = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.date) !== null && _b !== void 0 ? _b : (_c = response.headers) === null || _c === void 0 ? void 0 : _c.Date : undefined; };
exports.awsAuthMiddlewareOptions = {
    name: "awsAuthMiddleware",
    tags: ["SIGNATURE", "AWSAUTH"],
    relation: "after",
    toMiddleware: "retryMiddleware",
    override: true,
};
const getAwsAuthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.awsAuthMiddleware)(options), exports.awsAuthMiddlewareOptions);
    },
});
exports.getAwsAuthPlugin = getAwsAuthPlugin;
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin;


/***/ }),

/***/ 68253:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSkewCorrectedDate = void 0;
const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
exports.getSkewCorrectedDate = getSkewCorrectedDate;


/***/ }),

/***/ 35863:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUpdatedSystemClockOffset = void 0;
const isClockSkewed_1 = __nccwpck_require__(18950);
const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if ((0, isClockSkewed_1.isClockSkewed)(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
};
exports.getUpdatedSystemClockOffset = getUpdatedSystemClockOffset;


/***/ }),

/***/ 18950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isClockSkewed = void 0;
const getSkewCorrectedDate_1 = __nccwpck_require__(68253);
const isClockSkewed = (clockTime, systemClockOffset) => Math.abs((0, getSkewCorrectedDate_1.getSkewCorrectedDate)(systemClockOffset).getTime() - clockTime) >= 300000;
exports.isClockSkewed = isClockSkewed;


/***/ }),

/***/ 38399:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constructStack = void 0;
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.name && entry.name === toRemove) {
                isRemoved = true;
                entriesNameSet.delete(toRemove);
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                if (entry.name)
                    entriesNameSet.delete(entry.name);
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            if (normalizedEntry.name)
                normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            if (normalizedEntry.name)
                normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expendedMiddlewareList) => {
            wholeList.push(...expendedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            if (name) {
                if (entriesNameSet.has(name)) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${name}'`);
                    const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === name);
                    const toOverride = absoluteEntries[toOverrideIndex];
                    if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
                        throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be ` +
                            `overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
                    }
                    absoluteEntries.splice(toOverrideIndex, 1);
                }
                entriesNameSet.add(name);
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override } = options;
            const entry = {
                middleware,
                ...options,
            };
            if (name) {
                if (entriesNameSet.has(name)) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${name}'`);
                    const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === name);
                    const toOverride = relativeEntries[toOverrideIndex];
                    if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                        throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                            `by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                    }
                    relativeEntries.splice(toOverrideIndex, 1);
                }
                entriesNameSet.add(name);
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo((0, exports.constructStack)()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name } = entry;
                if (tags && tags.includes(toRemove)) {
                    if (name)
                        entriesNameSet.delete(name);
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo((0, exports.constructStack)());
            cloned.use(from);
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                return mw.name + ": " + (mw.tags || []).join(",");
            });
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            return handler;
        },
    };
    return stack;
};
exports.constructStack = constructStack;
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};


/***/ }),

/***/ 11461:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(38399), exports);


/***/ }),

/***/ 36546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveUserAgentConfig = void 0;
function resolveUserAgentConfig(input) {
    return {
        ...input,
        customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
    };
}
exports.resolveUserAgentConfig = resolveUserAgentConfig;


/***/ }),

/***/ 28025:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UA_ESCAPE_REGEX = exports.SPACE = exports.X_AMZ_USER_AGENT = exports.USER_AGENT = void 0;
exports.USER_AGENT = "user-agent";
exports.X_AMZ_USER_AGENT = "x-amz-user-agent";
exports.SPACE = " ";
exports.UA_ESCAPE_REGEX = /[^\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;


/***/ }),

/***/ 64688:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(36546), exports);
tslib_1.__exportStar(__nccwpck_require__(76236), exports);


/***/ }),

/***/ 76236:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserAgentPlugin = exports.getUserAgentMiddlewareOptions = exports.userAgentMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const constants_1 = __nccwpck_require__(28025);
const userAgentMiddleware = (options) => (next, context) => async (args) => {
    var _a, _b;
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request))
        return next(args);
    const { headers } = request;
    const userAgent = ((_a = context === null || context === void 0 ? void 0 : context.userAgent) === null || _a === void 0 ? void 0 : _a.map(escapeUserAgent)) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    const customUserAgent = ((_b = options === null || options === void 0 ? void 0 : options.customUserAgent) === null || _b === void 0 ? void 0 : _b.map(escapeUserAgent)) || [];
    const sdkUserAgentValue = [...defaultUserAgent, ...userAgent, ...customUserAgent].join(constants_1.SPACE);
    const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent,
    ].join(constants_1.SPACE);
    if (options.runtime !== "browser") {
        if (normalUAValue) {
            headers[constants_1.X_AMZ_USER_AGENT] = headers[constants_1.X_AMZ_USER_AGENT]
                ? `${headers[constants_1.USER_AGENT]} ${normalUAValue}`
                : normalUAValue;
        }
        headers[constants_1.USER_AGENT] = sdkUserAgentValue;
    }
    else {
        headers[constants_1.X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
        ...args,
        request,
    });
};
exports.userAgentMiddleware = userAgentMiddleware;
const escapeUserAgent = ([name, version]) => {
    const prefixSeparatorIndex = name.indexOf("/");
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
        uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version]
        .filter((item) => item && item.length > 0)
        .map((item) => item === null || item === void 0 ? void 0 : item.replace(constants_1.UA_ESCAPE_REGEX, "_"))
        .join("/");
};
exports.getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true,
};
const getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.userAgentMiddleware)(config), exports.getUserAgentMiddlewareOptions);
    },
});
exports.getUserAgentPlugin = getUserAgentPlugin;


/***/ }),

/***/ 52175:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadConfig = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const fromEnv_1 = __nccwpck_require__(46161);
const fromSharedConfigFiles_1 = __nccwpck_require__(63905);
const fromStatic_1 = __nccwpck_require__(5881);
const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromEnv_1.fromEnv)(environmentVariableSelector), (0, fromSharedConfigFiles_1.fromSharedConfigFiles)(configFileSelector, configuration), (0, fromStatic_1.fromStatic)(defaultValue)));
exports.loadConfig = loadConfig;


/***/ }),

/***/ 46161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromEnv = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};
exports.fromEnv = fromEnv;


/***/ }),

/***/ 63905:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSharedConfigFiles = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = (0, shared_ini_file_loader_1.getProfileName)(init);
    const { configFile, credentialsFile } = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const configValue = configSelector(mergedProfile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new property_provider_1.CredentialsProviderError(e.message ||
            `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};
exports.fromSharedConfigFiles = fromSharedConfigFiles;


/***/ }),

/***/ 5881:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const isFunction = (func) => typeof func === "function";
const fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : (0, property_provider_1.fromStatic)(defaultValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 87684:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(52175), exports);


/***/ }),

/***/ 33647:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODEJS_TIMEOUT_ERROR_CODES = void 0;
exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];


/***/ }),

/***/ 96225:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransformedHeaders = void 0;
const getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};
exports.getTransformedHeaders = getTransformedHeaders;


/***/ }),

/***/ 68805:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(2298), exports);
tslib_1.__exportStar(__nccwpck_require__(92533), exports);
tslib_1.__exportStar(__nccwpck_require__(72198), exports);


/***/ }),

/***/ 2298:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttpHandler = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const querystring_builder_1 = __nccwpck_require__(43402);
const http_1 = __nccwpck_require__(13685);
const https_1 = __nccwpck_require__(95687);
const constants_1 = __nccwpck_require__(33647);
const get_transformed_headers_1 = __nccwpck_require__(96225);
const set_connection_timeout_1 = __nccwpck_require__(63598);
const set_socket_timeout_1 = __nccwpck_require__(44751);
const write_request_body_1 = __nccwpck_require__(5248);
class NodeHttpHandler {
    constructor(options) {
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            socketTimeout,
            httpAgent: httpAgent || new http_1.Agent({ keepAlive, maxSockets }),
            httpsAgent: httpsAgent || new https_1.Agent({ keepAlive, maxSockets }),
        };
    }
    destroy() {
        var _a, _b, _c, _d;
        (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.httpAgent) === null || _b === void 0 ? void 0 : _b.destroy();
        (_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.httpsAgent) === null || _d === void 0 ? void 0 : _d.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        return new Promise((resolve, reject) => {
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path: queryString ? `${request.path}?${queryString}` : request.path,
                port: request.port,
                agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
            };
            const requestFunc = isSSL ? https_1.request : http_1.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: res.statusCode || -1,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            (0, set_connection_timeout_1.setConnectionTimeout)(req, reject, this.config.connectionTimeout);
            (0, set_socket_timeout_1.setSocketTimeout)(req, reject, this.config.socketTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            (0, write_request_body_1.writeRequestBody)(req, request);
        });
    }
}
exports.NodeHttpHandler = NodeHttpHandler;


/***/ }),

/***/ 92533:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttp2Handler = void 0;
const protocol_http_1 = __nccwpck_require__(70223);
const querystring_builder_1 = __nccwpck_require__(43402);
const http2_1 = __nccwpck_require__(85158);
const get_transformed_headers_1 = __nccwpck_require__(96225);
const write_request_body_1 = __nccwpck_require__(5248);
class NodeHttp2Handler {
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
        this.sessionCache = new Map();
    }
    destroy() {
        for (const sessions of this.sessionCache.values()) {
            sessions.forEach((session) => this.destroySession(session));
        }
        this.sessionCache.clear();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((resolve, rejectOriginal) => {
            let fulfilled = false;
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                rejectOriginal(abortError);
                return;
            }
            const { hostname, method, port, protocol, path, query } = request;
            const authority = `${protocol}//${hostname}${port ? `:${port}` : ""}`;
            const session = this.getSession(authority, disableConcurrentStreams || false);
            const reject = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                rejectOriginal(err);
            };
            const queryString = (0, querystring_builder_1.buildQueryString)(query || {});
            const req = session.request({
                ...request.headers,
                [http2_1.constants.HTTP2_HEADER_PATH]: queryString ? `${path}?${queryString}` : path,
                [http2_1.constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.deleteSessionFromCache(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    reject(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                reject(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", reject);
            req.on("aborted", () => {
                reject(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    reject(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            (0, write_request_body_1.writeRequestBody)(req, request);
        });
    }
    getSession(authority, disableConcurrentStreams) {
        var _a;
        const sessionCache = this.sessionCache;
        const existingSessions = sessionCache.get(authority) || [];
        if (existingSessions.length > 0 && !disableConcurrentStreams)
            return existingSessions[0];
        const newSession = (0, http2_1.connect)(authority);
        newSession.unref();
        const destroySessionCb = () => {
            this.destroySession(newSession);
            this.deleteSessionFromCache(authority, newSession);
        };
        newSession.on("goaway", destroySessionCb);
        newSession.on("error", destroySessionCb);
        newSession.on("frameError", destroySessionCb);
        newSession.on("close", () => this.deleteSessionFromCache(authority, newSession));
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.sessionTimeout) {
            newSession.setTimeout(this.config.sessionTimeout, destroySessionCb);
        }
        existingSessions.push(newSession);
        sessionCache.set(authority, existingSessions);
        return newSession;
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
    deleteSessionFromCache(authority, session) {
        const existingSessions = this.sessionCache.get(authority) || [];
        if (!existingSessions.includes(session)) {
            return;
        }
        this.sessionCache.set(authority, existingSessions.filter((s) => s !== session));
    }
}
exports.NodeHttp2Handler = NodeHttp2Handler;


/***/ }),

/***/ 63598:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setConnectionTimeout = void 0;
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    request.on("socket", (socket) => {
        if (socket.connecting) {
            const timeoutId = setTimeout(() => {
                request.destroy();
                reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
                    name: "TimeoutError",
                }));
            }, timeoutInMs);
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
    });
};
exports.setConnectionTimeout = setConnectionTimeout;


/***/ }),

/***/ 44751:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSocketTimeout = void 0;
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};
exports.setSocketTimeout = setSocketTimeout;


/***/ }),

/***/ 84362:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collector = void 0;
const stream_1 = __nccwpck_require__(12781);
class Collector extends stream_1.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}
exports.Collector = Collector;


/***/ }),

/***/ 72198:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.streamCollector = void 0;
const collector_1 = __nccwpck_require__(84362);
const streamCollector = (stream) => new Promise((resolve, reject) => {
    const collector = new collector_1.Collector();
    stream.pipe(collector);
    stream.on("error", (err) => {
        collector.end();
        reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function () {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve(bytes);
    });
});
exports.streamCollector = streamCollector;


/***/ }),

/***/ 5248:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeRequestBody = void 0;
const stream_1 = __nccwpck_require__(12781);
function writeRequestBody(httpRequest, request) {
    const expect = request.headers["Expect"] || request.headers["expect"];
    if (expect === "100-continue") {
        httpRequest.on("continue", () => {
            writeBody(httpRequest, request.body);
        });
    }
    else {
        writeBody(httpRequest, request.body);
    }
}
exports.writeRequestBody = writeRequestBody;
function writeBody(httpRequest, body) {
    if (body instanceof stream_1.Readable) {
        body.pipe(httpRequest);
    }
    else if (body) {
        httpRequest.end(Buffer.from(body));
    }
    else {
        httpRequest.end();
    }
}


/***/ }),

/***/ 96875:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CredentialsProviderError = void 0;
const ProviderError_1 = __nccwpck_require__(81786);
class CredentialsProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}
exports.CredentialsProviderError = CredentialsProviderError;


/***/ }),

/***/ 81786:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProviderError = void 0;
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}
exports.ProviderError = ProviderError;


/***/ }),

/***/ 22173:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenProviderError = void 0;
const ProviderError_1 = __nccwpck_require__(81786);
class TokenProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}
exports.TokenProviderError = TokenProviderError;


/***/ }),

/***/ 51444:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chain = void 0;
const ProviderError_1 = __nccwpck_require__(81786);
function chain(...providers) {
    return () => {
        let promise = Promise.reject(new ProviderError_1.ProviderError("No providers in chain"));
        for (const provider of providers) {
            promise = promise.catch((err) => {
                if (err === null || err === void 0 ? void 0 : err.tryNextLink) {
                    return provider();
                }
                throw err;
            });
        }
        return promise;
    };
}
exports.chain = chain;


/***/ }),

/***/ 10529:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 74462:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(96875), exports);
tslib_1.__exportStar(__nccwpck_require__(81786), exports);
tslib_1.__exportStar(__nccwpck_require__(22173), exports);
tslib_1.__exportStar(__nccwpck_require__(51444), exports);
tslib_1.__exportStar(__nccwpck_require__(10529), exports);
tslib_1.__exportStar(__nccwpck_require__(714), exports);


/***/ }),

/***/ 714:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.memoize = void 0;
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};
exports.memoize = memoize;


/***/ }),

/***/ 56779:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 52872:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpRequest = void 0;
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
exports.HttpRequest = HttpRequest;
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}


/***/ }),

/***/ 92348:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpResponse = void 0;
class HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}
exports.HttpResponse = HttpResponse;


/***/ }),

/***/ 70223:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(56779), exports);
tslib_1.__exportStar(__nccwpck_require__(52872), exports);
tslib_1.__exportStar(__nccwpck_require__(92348), exports);
tslib_1.__exportStar(__nccwpck_require__(85694), exports);


/***/ }),

/***/ 85694:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidHostname = void 0;
function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
}
exports.isValidHostname = isValidHostname;


/***/ }),

/***/ 43402:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildQueryString = void 0;
const util_uri_escape_1 = __nccwpck_require__(57952);
function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = (0, util_uri_escape_1.escapeUri)(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${(0, util_uri_escape_1.escapeUri)(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${(0, util_uri_escape_1.escapeUri)(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}
exports.buildQueryString = buildQueryString;


/***/ }),

/***/ 47424:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseQueryString = void 0;
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}
exports.parseQueryString = parseQueryString;


/***/ }),

/***/ 7352:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODEJS_TIMEOUT_ERROR_CODES = exports.TRANSIENT_ERROR_STATUS_CODES = exports.TRANSIENT_ERROR_CODES = exports.THROTTLING_ERROR_CODES = exports.CLOCK_SKEW_ERROR_CODES = void 0;
exports.CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch",
];
exports.THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException",
];
exports.TRANSIENT_ERROR_CODES = ["AbortError", "TimeoutError", "RequestTimeout", "RequestTimeoutException"];
exports.TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];


/***/ }),

/***/ 61921:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isServerError = exports.isTransientError = exports.isThrottlingError = exports.isClockSkewError = exports.isRetryableByTrait = void 0;
const constants_1 = __nccwpck_require__(7352);
const isRetryableByTrait = (error) => error.$retryable !== undefined;
exports.isRetryableByTrait = isRetryableByTrait;
const isClockSkewError = (error) => constants_1.CLOCK_SKEW_ERROR_CODES.includes(error.name);
exports.isClockSkewError = isClockSkewError;
const isThrottlingError = (error) => {
    var _a, _b;
    return ((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 429 ||
        constants_1.THROTTLING_ERROR_CODES.includes(error.name) ||
        ((_b = error.$retryable) === null || _b === void 0 ? void 0 : _b.throttling) == true;
};
exports.isThrottlingError = isThrottlingError;
const isTransientError = (error) => {
    var _a;
    return constants_1.TRANSIENT_ERROR_CODES.includes(error.name) ||
        constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes((error === null || error === void 0 ? void 0 : error.code) || "") ||
        constants_1.TRANSIENT_ERROR_STATUS_CODES.includes(((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) || 0);
};
exports.isTransientError = isTransientError;
const isServerError = (error) => {
    var _a;
    if (((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) !== undefined) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !(0, exports.isTransientError)(error)) {
            return true;
        }
        return false;
    }
    return false;
};
exports.isServerError = isServerError;


/***/ }),

/***/ 75216:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getConfigFilepath = exports.ENV_CONFIG_PATH = void 0;
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(97363);
exports.ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath = () => process.env[exports.ENV_CONFIG_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "config");
exports.getConfigFilepath = getConfigFilepath;


/***/ }),

/***/ 91569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCredentialsFilepath = exports.ENV_CREDENTIALS_PATH = void 0;
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(97363);
exports.ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[exports.ENV_CREDENTIALS_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "credentials");
exports.getCredentialsFilepath = getCredentialsFilepath;


/***/ }),

/***/ 97363:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHomeDir = void 0;
const os_1 = __nccwpck_require__(22037);
const path_1 = __nccwpck_require__(71017);
const getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    return (0, os_1.homedir)();
};
exports.getHomeDir = getHomeDir;


/***/ }),

/***/ 57498:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProfileData = void 0;
const profileKeyRegex = /^profile\s(["'])?([^\1]+)\1$/;
const getProfileData = (data) => Object.entries(data)
    .filter(([key]) => profileKeyRegex.test(key))
    .reduce((acc, [key, value]) => ({ ...acc, [profileKeyRegex.exec(key)[2]]: value }), {
    ...(data.default && { default: data.default }),
});
exports.getProfileData = getProfileData;


/***/ }),

/***/ 36776:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProfileName = exports.DEFAULT_PROFILE = exports.ENV_PROFILE = void 0;
exports.ENV_PROFILE = "AWS_PROFILE";
exports.DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[exports.ENV_PROFILE] || exports.DEFAULT_PROFILE;
exports.getProfileName = getProfileName;


/***/ }),

/***/ 42992:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFilepath = void 0;
const crypto_1 = __nccwpck_require__(6113);
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(97363);
const getSSOTokenFilepath = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
};
exports.getSSOTokenFilepath = getSSOTokenFilepath;


/***/ }),

/***/ 18553:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFromFile = void 0;
const fs_1 = __nccwpck_require__(57147);
const getSSOTokenFilepath_1 = __nccwpck_require__(42992);
const { readFile } = fs_1.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};
exports.getSSOTokenFromFile = getSSOTokenFromFile;


/***/ }),

/***/ 5175:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSsoSessionData = void 0;
const ssoSessionKeyRegex = /^sso-session\s(["'])?([^\1]+)\1$/;
const getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => ssoSessionKeyRegex.test(key))
    .reduce((acc, [key, value]) => ({ ...acc, [ssoSessionKeyRegex.exec(key)[2]]: value }), {});
exports.getSsoSessionData = getSsoSessionData;


/***/ }),

/***/ 67387:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(97363), exports);
tslib_1.__exportStar(__nccwpck_require__(36776), exports);
tslib_1.__exportStar(__nccwpck_require__(42992), exports);
tslib_1.__exportStar(__nccwpck_require__(18553), exports);
tslib_1.__exportStar(__nccwpck_require__(57871), exports);
tslib_1.__exportStar(__nccwpck_require__(96179), exports);
tslib_1.__exportStar(__nccwpck_require__(26533), exports);
tslib_1.__exportStar(__nccwpck_require__(84105), exports);


/***/ }),

/***/ 57871:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSharedConfigFiles = void 0;
const getConfigFilepath_1 = __nccwpck_require__(75216);
const getCredentialsFilepath_1 = __nccwpck_require__(91569);
const getProfileData_1 = __nccwpck_require__(57498);
const parseIni_1 = __nccwpck_require__(82806);
const slurpFile_1 = __nccwpck_require__(79242);
const swallowError = () => ({});
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = (0, getCredentialsFilepath_1.getCredentialsFilepath)(), configFilepath = (0, getConfigFilepath_1.getConfigFilepath)() } = init;
    const parsedFiles = await Promise.all([
        (0, slurpFile_1.slurpFile)(configFilepath).then(parseIni_1.parseIni).then(getProfileData_1.getProfileData).catch(swallowError),
        (0, slurpFile_1.slurpFile)(filepath).then(parseIni_1.parseIni).catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};
exports.loadSharedConfigFiles = loadSharedConfigFiles;


/***/ }),

/***/ 96179:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSsoSessionData = void 0;
const getConfigFilepath_1 = __nccwpck_require__(75216);
const getSsoSessionData_1 = __nccwpck_require__(5175);
const parseIni_1 = __nccwpck_require__(82806);
const slurpFile_1 = __nccwpck_require__(79242);
const swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => {
    var _a;
    return (0, slurpFile_1.slurpFile)((_a = init.configFilepath) !== null && _a !== void 0 ? _a : (0, getConfigFilepath_1.getConfigFilepath)())
        .then(parseIni_1.parseIni)
        .then(getSsoSessionData_1.getSsoSessionData)
        .catch(swallowError);
};
exports.loadSsoSessionData = loadSsoSessionData;


/***/ }),

/***/ 82806:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseIni = void 0;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni = (iniData) => {
    const map = {};
    let currentSection;
    for (let line of iniData.split(/\r?\n/)) {
        line = line.split(/(^|\s)[;#]/)[0].trim();
        const isSection = line[0] === "[" && line[line.length - 1] === "]";
        if (isSection) {
            currentSection = line.substring(1, line.length - 1);
            if (profileNameBlockList.includes(currentSection)) {
                throw new Error(`Found invalid profile name "${currentSection}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = line.indexOf("=");
            const start = 0;
            const end = line.length - 1;
            const isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
            if (isAssignment) {
                const [name, value] = [
                    line.substring(0, indexOfEqualsSign).trim(),
                    line.substring(indexOfEqualsSign + 1).trim(),
                ];
                map[currentSection] = map[currentSection] || {};
                map[currentSection][name] = value;
            }
        }
    }
    return map;
};
exports.parseIni = parseIni;


/***/ }),

/***/ 26533:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseKnownFiles = void 0;
const loadSharedConfigFiles_1 = __nccwpck_require__(57871);
const parseKnownFiles = async (init) => {
    const parsedFiles = await (0, loadSharedConfigFiles_1.loadSharedConfigFiles)(init);
    return {
        ...parsedFiles.configFile,
        ...parsedFiles.credentialsFile,
    };
};
exports.parseKnownFiles = parseKnownFiles;


/***/ }),

/***/ 79242:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.slurpFile = void 0;
const fs_1 = __nccwpck_require__(57147);
const { readFile } = fs_1.promises;
const filePromisesHash = {};
const slurpFile = (path) => {
    if (!filePromisesHash[path]) {
        filePromisesHash[path] = readFile(path, "utf8");
    }
    return filePromisesHash[path];
};
exports.slurpFile = slurpFile;


/***/ }),

/***/ 84105:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 75086:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureV4 = void 0;
const util_hex_encoding_1 = __nccwpck_require__(1968);
const util_middleware_1 = __nccwpck_require__(10236);
const constants_1 = __nccwpck_require__(30342);
const credentialDerivation_1 = __nccwpck_require__(11424);
const getCanonicalHeaders_1 = __nccwpck_require__(93590);
const getCanonicalQuery_1 = __nccwpck_require__(92019);
const getPayloadHash_1 = __nccwpck_require__(47080);
const headerUtil_1 = __nccwpck_require__(34120);
const moveHeadersToQuery_1 = __nccwpck_require__(98201);
const prepareRequest_1 = __nccwpck_require__(75772);
const utilDate_1 = __nccwpck_require__(94799);
class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);
        this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);
    }
    async presign(originalRequest, options = {}) {
        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), { unhoistableHeaders });
        if (credentials.sessionToken) {
            request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
        request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, options) {
        if (typeof toSign === "string") {
            return this.signString(toSign, options);
        }
        else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
        }
        else {
            return this.signRequest(toSign, options);
        }
    }
    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());
        const stringToSign = [
            constants_1.EVENT_ALGORITHM_IDENTIFIER,
            longDate,
            scope,
            priorSignature,
            hashedHeaders,
            hashedPayload,
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(stringToSign);
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const request = (0, prepareRequest_1.prepareRequest)(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);
        if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[constants_1.SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[constants_1.AUTH_HEADER] =
            `${constants_1.ALGORITHM_IDENTIFIER} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update(canonicalRequest);
        const hashedRequest = await hash.digest();
        return `${constants_1.ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")) {
                if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0)
                    continue;
                if (pathSegment === ".")
                    continue;
                if (pathSegment === "..") {
                    normalizedPathSegments.pop();
                }
                else {
                    normalizedPathSegments.push(pathSegment);
                }
            }
            const normalizedPath = `${(path === null || path === void 0 ? void 0 : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path === null || path === void 0 ? void 0 : path.endsWith("/")) ? "/" : ""}`;
            const doubleEncoded = encodeURIComponent(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update(stringToSign);
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
        return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" ||
            typeof credentials.accessKeyId !== "string" ||
            typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
        }
    }
}
exports.SignatureV4 = SignatureV4;
const formatDate = (now) => {
    const longDate = (0, utilDate_1.iso8601)(now).replace(/[\-:]/g, "");
    return {
        longDate,
        shortDate: longDate.slice(0, 8),
    };
};
const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");


/***/ }),

/***/ 53141:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneQuery = exports.cloneRequest = void 0;
const cloneRequest = ({ headers, query, ...rest }) => ({
    ...rest,
    headers: { ...headers },
    query: query ? (0, exports.cloneQuery)(query) : undefined,
});
exports.cloneRequest = cloneRequest;
const cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param,
    };
}, {});
exports.cloneQuery = cloneQuery;


/***/ }),

/***/ 30342:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MAX_PRESIGNED_TTL = exports.KEY_TYPE_IDENTIFIER = exports.MAX_CACHE_SIZE = exports.UNSIGNED_PAYLOAD = exports.EVENT_ALGORITHM_IDENTIFIER = exports.ALGORITHM_IDENTIFIER_V4A = exports.ALGORITHM_IDENTIFIER = exports.UNSIGNABLE_PATTERNS = exports.SEC_HEADER_PATTERN = exports.PROXY_HEADER_PATTERN = exports.ALWAYS_UNSIGNABLE_HEADERS = exports.HOST_HEADER = exports.TOKEN_HEADER = exports.SHA256_HEADER = exports.SIGNATURE_HEADER = exports.GENERATED_HEADERS = exports.DATE_HEADER = exports.AMZ_DATE_HEADER = exports.AUTH_HEADER = exports.REGION_SET_PARAM = exports.TOKEN_QUERY_PARAM = exports.SIGNATURE_QUERY_PARAM = exports.EXPIRES_QUERY_PARAM = exports.SIGNED_HEADERS_QUERY_PARAM = exports.AMZ_DATE_QUERY_PARAM = exports.CREDENTIAL_QUERY_PARAM = exports.ALGORITHM_QUERY_PARAM = void 0;
exports.ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
exports.CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
exports.AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
exports.SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
exports.EXPIRES_QUERY_PARAM = "X-Amz-Expires";
exports.SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
exports.TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
exports.REGION_SET_PARAM = "X-Amz-Region-Set";
exports.AUTH_HEADER = "authorization";
exports.AMZ_DATE_HEADER = exports.AMZ_DATE_QUERY_PARAM.toLowerCase();
exports.DATE_HEADER = "date";
exports.GENERATED_HEADERS = [exports.AUTH_HEADER, exports.AMZ_DATE_HEADER, exports.DATE_HEADER];
exports.SIGNATURE_HEADER = exports.SIGNATURE_QUERY_PARAM.toLowerCase();
exports.SHA256_HEADER = "x-amz-content-sha256";
exports.TOKEN_HEADER = exports.TOKEN_QUERY_PARAM.toLowerCase();
exports.HOST_HEADER = "host";
exports.ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true,
};
exports.PROXY_HEADER_PATTERN = /^proxy-/;
exports.SEC_HEADER_PATTERN = /^sec-/;
exports.UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
exports.ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
exports.ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
exports.EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
exports.UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
exports.MAX_CACHE_SIZE = 50;
exports.KEY_TYPE_IDENTIFIER = "aws4_request";
exports.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;


/***/ }),

/***/ 11424:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;
const util_hex_encoding_1 = __nccwpck_require__(1968);
const constants_1 = __nccwpck_require__(30342);
const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;
exports.createScope = createScope;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
    }
    return (signingKeyCache[cacheKey] = key);
};
exports.getSigningKey = getSigningKey;
const clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
    });
};
exports.clearCredentialCache = clearCredentialCache;
const hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update(data);
    return hash.digest();
};


/***/ }),

/***/ 93590:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCanonicalHeaders = void 0;
const constants_1 = __nccwpck_require__(30342);
const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == undefined) {
            continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in constants_1.ALWAYS_UNSIGNABLE_HEADERS ||
            (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) ||
            constants_1.PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
            constants_1.SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
};
exports.getCanonicalHeaders = getCanonicalHeaders;


/***/ }),

/***/ 92019:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCanonicalQuery = void 0;
const util_uri_escape_1 = __nccwpck_require__(57952);
const constants_1 = __nccwpck_require__(30342);
const getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === constants_1.SIGNATURE_HEADER) {
            continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
            serialized[key] = `${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`;
        }
        else if (Array.isArray(value)) {
            serialized[key] = value
                .slice(0)
                .sort()
                .reduce((encoded, value) => encoded.concat([`${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`]), [])
                .join("&");
        }
    }
    return keys
        .map((key) => serialized[key])
        .filter((serialized) => serialized)
        .join("&");
};
exports.getCanonicalQuery = getCanonicalQuery;


/***/ }),

/***/ 47080:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPayloadHash = void 0;
const is_array_buffer_1 = __nccwpck_require__(69126);
const util_hex_encoding_1 = __nccwpck_require__(1968);
const constants_1 = __nccwpck_require__(30342);
const getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === constants_1.SHA256_HEADER) {
            return headers[headerName];
        }
    }
    if (body == undefined) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    }
    else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, is_array_buffer_1.isArrayBuffer)(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(body);
        return (0, util_hex_encoding_1.toHex)(await hashCtor.digest());
    }
    return constants_1.UNSIGNED_PAYLOAD;
};
exports.getPayloadHash = getPayloadHash;


/***/ }),

/***/ 34120:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteHeader = exports.getHeaderValue = exports.hasHeader = void 0;
const hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};
exports.hasHeader = hasHeader;
const getHeaderValue = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return headers[headerName];
        }
    }
    return undefined;
};
exports.getHeaderValue = getHeaderValue;
const deleteHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            delete headers[headerName];
        }
    }
};
exports.deleteHeader = deleteHeader;


/***/ }),

/***/ 37776:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareRequest = exports.moveHeadersToQuery = exports.getPayloadHash = exports.getCanonicalQuery = exports.getCanonicalHeaders = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(75086), exports);
var getCanonicalHeaders_1 = __nccwpck_require__(93590);
Object.defineProperty(exports, "getCanonicalHeaders", ({ enumerable: true, get: function () { return getCanonicalHeaders_1.getCanonicalHeaders; } }));
var getCanonicalQuery_1 = __nccwpck_require__(92019);
Object.defineProperty(exports, "getCanonicalQuery", ({ enumerable: true, get: function () { return getCanonicalQuery_1.getCanonicalQuery; } }));
var getPayloadHash_1 = __nccwpck_require__(47080);
Object.defineProperty(exports, "getPayloadHash", ({ enumerable: true, get: function () { return getPayloadHash_1.getPayloadHash; } }));
var moveHeadersToQuery_1 = __nccwpck_require__(98201);
Object.defineProperty(exports, "moveHeadersToQuery", ({ enumerable: true, get: function () { return moveHeadersToQuery_1.moveHeadersToQuery; } }));
var prepareRequest_1 = __nccwpck_require__(75772);
Object.defineProperty(exports, "prepareRequest", ({ enumerable: true, get: function () { return prepareRequest_1.prepareRequest; } }));
tslib_1.__exportStar(__nccwpck_require__(11424), exports);


/***/ }),

/***/ 98201:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveHeadersToQuery = void 0;
const cloneRequest_1 = __nccwpck_require__(53141);
const moveHeadersToQuery = (request, options = {}) => {
    var _a;
    const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !((_a = options.unhoistableHeaders) === null || _a === void 0 ? void 0 : _a.has(lname))) {
            query[name] = headers[name];
            delete headers[name];
        }
    }
    return {
        ...request,
        headers,
        query,
    };
};
exports.moveHeadersToQuery = moveHeadersToQuery;


/***/ }),

/***/ 75772:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareRequest = void 0;
const cloneRequest_1 = __nccwpck_require__(53141);
const constants_1 = __nccwpck_require__(30342);
const prepareRequest = (request) => {
    request = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const headerName of Object.keys(request.headers)) {
        if (constants_1.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
        }
    }
    return request;
};
exports.prepareRequest = prepareRequest;


/***/ }),

/***/ 94799:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toDate = exports.iso8601 = void 0;
const iso8601 = (time) => (0, exports.toDate)(time)
    .toISOString()
    .replace(/\.\d{3}Z$/, "Z");
exports.iso8601 = iso8601;
const toDate = (time) => {
    if (typeof time === "number") {
        return new Date(time * 1000);
    }
    if (typeof time === "string") {
        if (Number(time)) {
            return new Date(Number(time) * 1000);
        }
        return new Date(time);
    }
    return time;
};
exports.toDate = toDate;


/***/ }),

/***/ 78571:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoOpLogger = void 0;
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}
exports.NoOpLogger = NoOpLogger;


/***/ }),

/***/ 36034:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = void 0;
const middleware_stack_1 = __nccwpck_require__(11461);
class Client {
    constructor(config) {
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}
exports.Client = Client;


/***/ }),

/***/ 4014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Command = void 0;
const middleware_stack_1 = __nccwpck_require__(11461);
class Command {
    constructor() {
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
    }
}
exports.Command = Command;


/***/ }),

/***/ 78392:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SENSITIVE_STRING = void 0;
exports.SENSITIVE_STRING = "***SensitiveInformation***";


/***/ }),

/***/ 24695:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEpochTimestamp = exports.parseRfc7231DateTime = exports.parseRfc3339DateTime = exports.dateToUtcString = void 0;
const parse_utils_1 = __nccwpck_require__(34014);
const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
exports.dateToUtcString = dateToUtcString;
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
exports.parseRfc3339DateTime = parseRfc3339DateTime;
const IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
exports.parseRfc7231DateTime = parseRfc7231DateTime;
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = (0, parse_utils_1.strictParseDouble)(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
exports.parseEpochTimestamp = parseEpochTimestamp;
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = (0, parse_utils_1.strictParseByte)(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return (0, parse_utils_1.strictParseFloat32)("0." + value) * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};


/***/ }),

/***/ 47222:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.throwDefaultError = void 0;
const exceptions_1 = __nccwpck_require__(57778);
const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw (0, exceptions_1.decorateServiceException)(response, parsedBody);
};
exports.throwDefaultError = throwDefaultError;
const deserializeMetadata = (output) => {
    var _a, _b;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== void 0 ? _b : output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};


/***/ }),

/***/ 33088:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadConfigsForDefaultMode = void 0;
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};
exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;


/***/ }),

/***/ 12363:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emitWarningIfUnsupportedVersion = void 0;
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 14) {
        warningEmitted = true;
    }
};
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;


/***/ }),

/***/ 57778:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateServiceException = exports.ServiceException = void 0;
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
exports.ServiceException = ServiceException;
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};
exports.decorateServiceException = decorateServiceException;


/***/ }),

/***/ 91927:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendedEncodeURIComponent = void 0;
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
exports.extendedEncodeURIComponent = extendedEncodeURIComponent;


/***/ }),

/***/ 86457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getArrayIfSingleItem = void 0;
const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
exports.getArrayIfSingleItem = getArrayIfSingleItem;


/***/ }),

/***/ 95830:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValueFromTextNode = void 0;
const getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
            obj[key] = obj[key][textNodeName];
        }
        else if (typeof obj[key] === "object" && obj[key] !== null) {
            obj[key] = (0, exports.getValueFromTextNode)(obj[key]);
        }
    }
    return obj;
};
exports.getValueFromTextNode = getValueFromTextNode;


/***/ }),

/***/ 4963:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(78571), exports);
tslib_1.__exportStar(__nccwpck_require__(36034), exports);
tslib_1.__exportStar(__nccwpck_require__(4014), exports);
tslib_1.__exportStar(__nccwpck_require__(78392), exports);
tslib_1.__exportStar(__nccwpck_require__(24695), exports);
tslib_1.__exportStar(__nccwpck_require__(47222), exports);
tslib_1.__exportStar(__nccwpck_require__(33088), exports);
tslib_1.__exportStar(__nccwpck_require__(12363), exports);
tslib_1.__exportStar(__nccwpck_require__(57778), exports);
tslib_1.__exportStar(__nccwpck_require__(91927), exports);
tslib_1.__exportStar(__nccwpck_require__(86457), exports);
tslib_1.__exportStar(__nccwpck_require__(95830), exports);
tslib_1.__exportStar(__nccwpck_require__(93613), exports);
tslib_1.__exportStar(__nccwpck_require__(21599), exports);
tslib_1.__exportStar(__nccwpck_require__(34014), exports);
tslib_1.__exportStar(__nccwpck_require__(80308), exports);
tslib_1.__exportStar(__nccwpck_require__(38000), exports);
tslib_1.__exportStar(__nccwpck_require__(48730), exports);


/***/ }),

/***/ 93613:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyJsonString = exports.StringWrapper = void 0;
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
exports.StringWrapper = StringWrapper;
exports.StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: exports.StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(exports.StringWrapper, String);
class LazyJsonString extends exports.StringWrapper {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}
exports.LazyJsonString = LazyJsonString;


/***/ }),

/***/ 21599:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertMap = exports.map = void 0;
function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        let [filter, value] = instructions[key];
        if (typeof value === "function") {
            let _value;
            const defaultFilterPassed = filter === undefined && (_value = value()) != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed) {
                target[key] = _value;
            }
            else if (customFilterPassed) {
                target[key] = value();
            }
        }
        else {
            const defaultFilterPassed = filter === undefined && value != null;
            const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
            if (defaultFilterPassed || customFilterPassed) {
                target[key] = value;
            }
        }
    }
    return target;
}
exports.map = map;
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
exports.convertMap = convertMap;
const mapWithFilter = (target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};


/***/ }),

/***/ 34014:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectUnion = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = void 0;
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
exports.parseBoolean = parseBoolean;
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
exports.expectBoolean = expectBoolean;
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                exports.logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
exports.expectNumber = expectNumber;
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = (0, exports.expectNumber)(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
exports.expectFloat32 = expectFloat32;
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
exports.expectLong = expectLong;
exports.expectInt = exports.expectLong;
const expectInt32 = (value) => expectSizedInt(value, 32);
exports.expectInt32 = expectInt32;
const expectShort = (value) => expectSizedInt(value, 16);
exports.expectShort = expectShort;
const expectByte = (value) => expectSizedInt(value, 8);
exports.expectByte = expectByte;
const expectSizedInt = (value, size) => {
    const expected = (0, exports.expectLong)(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
exports.expectNonNull = expectNonNull;
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
exports.expectObject = expectObject;
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        exports.logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
exports.expectString = expectString;
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = (0, exports.expectObject)(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
exports.expectUnion = expectUnion;
const strictParseDouble = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectNumber)(parseNumber(value));
    }
    return (0, exports.expectNumber)(value);
};
exports.strictParseDouble = strictParseDouble;
exports.strictParseFloat = exports.strictParseDouble;
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectFloat32)(parseNumber(value));
    }
    return (0, exports.expectFloat32)(value);
};
exports.strictParseFloat32 = strictParseFloat32;
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectNumber)(value);
};
exports.limitedParseDouble = limitedParseDouble;
exports.handleFloat = exports.limitedParseDouble;
exports.limitedParseFloat = exports.limitedParseDouble;
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectFloat32)(value);
};
exports.limitedParseFloat32 = limitedParseFloat32;
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectLong)(parseNumber(value));
    }
    return (0, exports.expectLong)(value);
};
exports.strictParseLong = strictParseLong;
exports.strictParseInt = exports.strictParseLong;
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectInt32)(parseNumber(value));
    }
    return (0, exports.expectInt32)(value);
};
exports.strictParseInt32 = strictParseInt32;
const strictParseShort = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectShort)(parseNumber(value));
    }
    return (0, exports.expectShort)(value);
};
exports.strictParseShort = strictParseShort;
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectByte)(parseNumber(value));
    }
    return (0, exports.expectByte)(value);
};
exports.strictParseByte = strictParseByte;
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
exports.logger = {
    warn: console.warn,
};


/***/ }),

/***/ 80308:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvedPath = void 0;
const extended_encode_uri_component_1 = __nccwpck_require__(91927);
const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
            ? labelValue
                .split("/")
                .map((segment) => (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(segment))
                .join("/")
            : (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};
exports.resolvedPath = resolvedPath;


/***/ }),

/***/ 38000:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeFloat = void 0;
const serializeFloat = (value) => {
    if (value !== value) {
        return "NaN";
    }
    switch (value) {
        case Infinity:
            return "Infinity";
        case -Infinity:
            return "-Infinity";
        default:
            return value;
    }
};
exports.serializeFloat = serializeFloat;


/***/ }),

/***/ 48730:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitEvery = void 0;
function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
        throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
        return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i = 0; i < segments.length; i++) {
        if (currentSegment === "") {
            currentSegment = segments[i];
        }
        else {
            currentSegment += delimiter + segments[i];
        }
        if ((i + 1) % numDelimiters === 0) {
            compoundSegments.push(currentSegment);
            currentSegment = "";
        }
    }
    if (currentSegment !== "") {
        compoundSegments.push(currentSegment);
    }
    return compoundSegments;
}
exports.splitEvery = splitEvery;


/***/ }),

/***/ 92242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REFRESH_MESSAGE = exports.EXPIRE_WINDOW_MS = void 0;
exports.EXPIRE_WINDOW_MS = 5 * 60 * 1000;
exports.REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;


/***/ }),

/***/ 85125:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSso = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const constants_1 = __nccwpck_require__(92242);
const getNewSsoOidcToken_1 = __nccwpck_require__(93601);
const validateTokenExpiry_1 = __nccwpck_require__(28418);
const validateTokenKey_1 = __nccwpck_require__(2488);
const writeSSOTokenToFile_1 = __nccwpck_require__(48552);
const lastRefreshAttemptTime = new Date(0);
const fromSso = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
    const profile = profiles[profileName];
    if (!profile) {
        throw new property_provider_1.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
    }
    else if (!profile["sso_session"]) {
        throw new property_provider_1.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
    }
    const ssoSessionName = profile["sso_session"];
    const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
    const ssoSession = ssoSessions[ssoSessionName];
    if (!ssoSession) {
        throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
    }
    for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
        if (!ssoSession[ssoSessionRequiredKey]) {
            throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
        }
    }
    const ssoStartUrl = ssoSession["sso_start_url"];
    const ssoRegion = ssoSession["sso_region"];
    let ssoToken;
    try {
        ssoToken = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoSessionName);
    }
    catch (e) {
        throw new property_provider_1.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${constants_1.REFRESH_MESSAGE}`, false);
    }
    (0, validateTokenKey_1.validateTokenKey)("accessToken", ssoToken.accessToken);
    (0, validateTokenKey_1.validateTokenKey)("expiresAt", ssoToken.expiresAt);
    const { accessToken, expiresAt } = ssoToken;
    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
    if (existingToken.expiration.getTime() - Date.now() > constants_1.EXPIRE_WINDOW_MS) {
        return existingToken;
    }
    if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
        (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
        return existingToken;
    }
    (0, validateTokenKey_1.validateTokenKey)("clientId", ssoToken.clientId, true);
    (0, validateTokenKey_1.validateTokenKey)("clientSecret", ssoToken.clientSecret, true);
    (0, validateTokenKey_1.validateTokenKey)("refreshToken", ssoToken.refreshToken, true);
    try {
        lastRefreshAttemptTime.setTime(Date.now());
        const newSsoOidcToken = await (0, getNewSsoOidcToken_1.getNewSsoOidcToken)(ssoToken, ssoRegion);
        (0, validateTokenKey_1.validateTokenKey)("accessToken", newSsoOidcToken.accessToken);
        (0, validateTokenKey_1.validateTokenKey)("expiresIn", newSsoOidcToken.expiresIn);
        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
        try {
            await (0, writeSSOTokenToFile_1.writeSSOTokenToFile)(ssoSessionName, {
                ...ssoToken,
                accessToken: newSsoOidcToken.accessToken,
                expiresAt: newTokenExpiration.toISOString(),
                refreshToken: newSsoOidcToken.refreshToken,
            });
        }
        catch (error) {
        }
        return {
            token: newSsoOidcToken.accessToken,
            expiration: newTokenExpiration,
        };
    }
    catch (error) {
        (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
        return existingToken;
    }
};
exports.fromSso = fromSso;


/***/ }),

/***/ 63258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const fromStatic = ({ token }) => async () => {
    if (!token || !token.token) {
        throw new property_provider_1.TokenProviderError(`Please pass a valid token to fromStatic`, false);
    }
    return token;
};
exports.fromStatic = fromStatic;


/***/ }),

/***/ 93601:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNewSsoOidcToken = void 0;
const client_sso_oidc_1 = __nccwpck_require__(54527);
const getSsoOidcClient_1 = __nccwpck_require__(99775);
const getNewSsoOidcToken = (ssoToken, ssoRegion) => {
    const ssoOidcClient = (0, getSsoOidcClient_1.getSsoOidcClient)(ssoRegion);
    return ssoOidcClient.send(new client_sso_oidc_1.CreateTokenCommand({
        clientId: ssoToken.clientId,
        clientSecret: ssoToken.clientSecret,
        refreshToken: ssoToken.refreshToken,
        grantType: "refresh_token",
    }));
};
exports.getNewSsoOidcToken = getNewSsoOidcToken;


/***/ }),

/***/ 99775:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSsoOidcClient = void 0;
const client_sso_oidc_1 = __nccwpck_require__(54527);
const ssoOidcClientsHash = {};
const getSsoOidcClient = (ssoRegion) => {
    if (ssoOidcClientsHash[ssoRegion]) {
        return ssoOidcClientsHash[ssoRegion];
    }
    const ssoOidcClient = new client_sso_oidc_1.SSOOIDCClient({ region: ssoRegion });
    ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
    return ssoOidcClient;
};
exports.getSsoOidcClient = getSsoOidcClient;


/***/ }),

/***/ 52843:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(85125), exports);
tslib_1.__exportStar(__nccwpck_require__(63258), exports);
tslib_1.__exportStar(__nccwpck_require__(70195), exports);


/***/ }),

/***/ 70195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nodeProvider = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const fromSso_1 = __nccwpck_require__(85125);
const nodeProvider = (init = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromSso_1.fromSso)(init), async () => {
    throw new property_provider_1.TokenProviderError("Could not load token from any providers", false);
}), (token) => token.expiration !== undefined && token.expiration.getTime() - Date.now() < 300000, (token) => token.expiration !== undefined);
exports.nodeProvider = nodeProvider;


/***/ }),

/***/ 28418:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTokenExpiry = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const constants_1 = __nccwpck_require__(92242);
const validateTokenExpiry = (token) => {
    if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new property_provider_1.TokenProviderError(`Token is expired. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenExpiry = validateTokenExpiry;


/***/ }),

/***/ 2488:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTokenKey = void 0;
const property_provider_1 = __nccwpck_require__(74462);
const constants_1 = __nccwpck_require__(92242);
const validateTokenKey = (key, value, forRefresh = false) => {
    if (typeof value === "undefined") {
        throw new property_provider_1.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenKey = validateTokenKey;


/***/ }),

/***/ 48552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeSSOTokenToFile = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(67387);
const fs_1 = __nccwpck_require__(57147);
const { writeFile } = fs_1.promises;
const writeSSOTokenToFile = (id, ssoToken) => {
    const tokenFilepath = (0, shared_ini_file_loader_1.getSSOTokenFilepath)(id);
    const tokenString = JSON.stringify(ssoToken, null, 2);
    return writeFile(tokenFilepath, tokenString);
};
exports.writeSSOTokenToFile = writeSSOTokenToFile;


/***/ }),

/***/ 52562:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 26913:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 65861:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 76527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 48470:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 67736:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 13268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 99385:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointURLScheme = void 0;
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme = exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));


/***/ }),

/***/ 37521:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 61393:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 51821:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 92635:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 71301:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
;


/***/ }),

/***/ 21268:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 7192:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 10640:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(51821), exports);
tslib_1.__exportStar(__nccwpck_require__(92635), exports);
tslib_1.__exportStar(__nccwpck_require__(71301), exports);
tslib_1.__exportStar(__nccwpck_require__(21268), exports);
tslib_1.__exportStar(__nccwpck_require__(7192), exports);


/***/ }),

/***/ 89029:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(52562), exports);
tslib_1.__exportStar(__nccwpck_require__(26913), exports);
tslib_1.__exportStar(__nccwpck_require__(65861), exports);
tslib_1.__exportStar(__nccwpck_require__(76527), exports);
tslib_1.__exportStar(__nccwpck_require__(48470), exports);
tslib_1.__exportStar(__nccwpck_require__(67736), exports);
tslib_1.__exportStar(__nccwpck_require__(13268), exports);
tslib_1.__exportStar(__nccwpck_require__(99385), exports);
tslib_1.__exportStar(__nccwpck_require__(37521), exports);
tslib_1.__exportStar(__nccwpck_require__(61393), exports);
tslib_1.__exportStar(__nccwpck_require__(10640), exports);
tslib_1.__exportStar(__nccwpck_require__(89910), exports);
tslib_1.__exportStar(__nccwpck_require__(36678), exports);
tslib_1.__exportStar(__nccwpck_require__(39931), exports);
tslib_1.__exportStar(__nccwpck_require__(42620), exports);
tslib_1.__exportStar(__nccwpck_require__(89546), exports);
tslib_1.__exportStar(__nccwpck_require__(80316), exports);
tslib_1.__exportStar(__nccwpck_require__(57835), exports);
tslib_1.__exportStar(__nccwpck_require__(91678), exports);
tslib_1.__exportStar(__nccwpck_require__(93818), exports);
tslib_1.__exportStar(__nccwpck_require__(51991), exports);
tslib_1.__exportStar(__nccwpck_require__(24296), exports);
tslib_1.__exportStar(__nccwpck_require__(59416), exports);
tslib_1.__exportStar(__nccwpck_require__(20134), exports);
tslib_1.__exportStar(__nccwpck_require__(34465), exports);


/***/ }),

/***/ 89910:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 36678:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 39931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 42620:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 80316:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 91678:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 93818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 51991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 24296:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 59416:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 20134:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 34465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 2992:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseUrl = void 0;
const querystring_parser_1 = __nccwpck_require__(47424);
const parseUrl = (url) => {
    if (typeof url === "string") {
        return (0, exports.parseUrl)(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = (0, querystring_parser_1.parseQueryString)(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};
exports.parseUrl = parseUrl;


/***/ }),

/***/ 58444:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(36010);
const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
exports.fromBase64 = fromBase64;


/***/ }),

/***/ 97727:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(58444), exports);
tslib_1.__exportStar(__nccwpck_require__(63439), exports);


/***/ }),

/***/ 63439:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(36010);
const toBase64 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
exports.toBase64 = toBase64;


/***/ }),

/***/ 89190:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.calculateBodyLength = void 0;
const fs_1 = __nccwpck_require__(57147);
const calculateBodyLength = (body) => {
    if (!body) {
        return 0;
    }
    if (typeof body === "string") {
        return Buffer.from(body).length;
    }
    else if (typeof body.byteLength === "number") {
        return body.byteLength;
    }
    else if (typeof body.size === "number") {
        return body.size;
    }
    else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return (0, fs_1.lstatSync)(body.path).size;
    }
    else if (typeof body.fd === "number") {
        return (0, fs_1.fstatSync)(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
};
exports.calculateBodyLength = calculateBodyLength;


/***/ }),

/***/ 74147:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(89190), exports);


/***/ }),

/***/ 36010:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromString = exports.fromArrayBuffer = void 0;
const is_array_buffer_1 = __nccwpck_require__(69126);
const buffer_1 = __nccwpck_require__(14300);
const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!(0, is_array_buffer_1.isArrayBuffer)(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer_1.Buffer.from(input, offset, length);
};
exports.fromArrayBuffer = fromArrayBuffer;
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer_1.Buffer.from(input, encoding) : buffer_1.Buffer.from(input);
};
exports.fromString = fromString;


/***/ }),

/***/ 79509:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.booleanSelector = exports.SelectorType = void 0;
var SelectorType;
(function (SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
const booleanSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    if (obj[key] === "true")
        return true;
    if (obj[key] === "false")
        return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};
exports.booleanSelector = booleanSelector;


/***/ }),

/***/ 6168:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(79509), exports);


/***/ }),

/***/ 16488:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IMDS_REGION_PATH = exports.DEFAULTS_MODE_OPTIONS = exports.ENV_IMDS_DISABLED = exports.AWS_DEFAULT_REGION_ENV = exports.AWS_REGION_ENV = exports.AWS_EXECUTION_ENV = void 0;
exports.AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
exports.AWS_REGION_ENV = "AWS_REGION";
exports.AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
exports.DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
exports.IMDS_REGION_PATH = "/latest/meta-data/placement/region";


/***/ }),

/***/ 28450:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = void 0;
const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy",
};


/***/ }),

/***/ 74243:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18238), exports);


/***/ }),

/***/ 18238:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveDefaultsModeConfig = void 0;
const config_resolver_1 = __nccwpck_require__(56153);
const credential_provider_imds_1 = __nccwpck_require__(25898);
const node_config_provider_1 = __nccwpck_require__(87684);
const property_provider_1 = __nccwpck_require__(74462);
const constants_1 = __nccwpck_require__(16488);
const defaultsModeConfig_1 = __nccwpck_require__(28450);
const resolveDefaultsModeConfig = ({ region = (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS), defaultsMode = (0, node_config_provider_1.loadConfig)(defaultsModeConfig_1.NODE_DEFAULTS_MODE_CONFIG_OPTIONS), } = {}) => (0, property_provider_1.memoize)(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode === null || mode === void 0 ? void 0 : mode.toLowerCase()) {
        case "auto":
            return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
            return Promise.resolve(mode === null || mode === void 0 ? void 0 : mode.toLocaleLowerCase());
        case undefined:
            return Promise.resolve("legacy");
        default:
            throw new Error(`Invalid parameter for "defaultsMode", expect ${constants_1.DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
});
exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
const resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
            return "standard";
        }
        if (resolvedRegion === inferredRegion) {
            return "in-region";
        }
        else {
            return "cross-region";
        }
    }
    return "standard";
};
const inferPhysicalRegion = async () => {
    var _a;
    if (process.env[constants_1.AWS_EXECUTION_ENV] && (process.env[constants_1.AWS_REGION_ENV] || process.env[constants_1.AWS_DEFAULT_REGION_ENV])) {
        return (_a = process.env[constants_1.AWS_REGION_ENV]) !== null && _a !== void 0 ? _a : process.env[constants_1.AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[constants_1.ENV_IMDS_DISABLED]) {
        try {
            const endpoint = await (0, credential_provider_imds_1.getInstanceMetadataEndpoint)();
            return (await (0, credential_provider_imds_1.httpRequest)({ ...endpoint, path: constants_1.IMDS_REGION_PATH })).toString();
        }
        catch (e) {
        }
    }
};


/***/ }),

/***/ 81809:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debugId = void 0;
exports.debugId = "endpoints";


/***/ }),

/***/ 27617:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(81809), exports);
tslib_1.__exportStar(__nccwpck_require__(46833), exports);


/***/ }),

/***/ 46833:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toDebugString = void 0;
function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
        return input;
    }
    if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
}
exports.toDebugString = toDebugString;


/***/ }),

/***/ 13350:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(37482), exports);
tslib_1.__exportStar(__nccwpck_require__(36563), exports);
tslib_1.__exportStar(__nccwpck_require__(57433), exports);


/***/ }),

/***/ 46835:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(48079), exports);
tslib_1.__exportStar(__nccwpck_require__(34711), exports);
tslib_1.__exportStar(__nccwpck_require__(37482), exports);


/***/ }),

/***/ 48079:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVirtualHostableS3Bucket = void 0;
const isIpAddress_1 = __nccwpck_require__(73442);
const isValidHostLabel_1 = __nccwpck_require__(57373);
const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
        for (const label of value.split(".")) {
            if (!(0, exports.isVirtualHostableS3Bucket)(label)) {
                return false;
            }
        }
        return true;
    }
    if (!(0, isValidHostLabel_1.isValidHostLabel)(value)) {
        return false;
    }
    if (value.length < 3 || value.length > 63) {
        return false;
    }
    if (value !== value.toLowerCase()) {
        return false;
    }
    if ((0, isIpAddress_1.isIpAddress)(value)) {
        return false;
    }
    return true;
};
exports.isVirtualHostableS3Bucket = isVirtualHostableS3Bucket;


/***/ }),

/***/ 34711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseArn = void 0;
const parseArn = (value) => {
    const segments = value.split(":");
    if (segments.length < 6)
        return null;
    const [arn, partition, service, region, accountId, ...resourceId] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "")
        return null;
    return {
        partition,
        service,
        region,
        accountId,
        resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId,
    };
};
exports.parseArn = parseArn;


/***/ }),

/***/ 37482:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.partition = void 0;
const tslib_1 = __nccwpck_require__(4351);
const partitions_json_1 = tslib_1.__importDefault(__nccwpck_require__(95367));
const { partitions } = partitions_json_1.default;
const DEFAULT_PARTITION = partitions.find((partition) => partition.id === "aws");
const partition = (value) => {
    for (const partition of partitions) {
        const { regions, outputs } = partition;
        for (const [region, regionData] of Object.entries(regions)) {
            if (region === value) {
                return {
                    ...outputs,
                    ...regionData,
                };
            }
        }
    }
    for (const partition of partitions) {
        const { regionRegex, outputs } = partition;
        if (new RegExp(regionRegex).test(value)) {
            return {
                ...outputs,
            };
        }
    }
    if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex," +
            " and default partition with id 'aws' doesn't exist.");
    }
    return {
        ...DEFAULT_PARTITION.outputs,
    };
};
exports.partition = partition;


/***/ }),

/***/ 55370:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.booleanEquals = void 0;
const booleanEquals = (value1, value2) => value1 === value2;
exports.booleanEquals = booleanEquals;


/***/ }),

/***/ 20767:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAttr = void 0;
const types_1 = __nccwpck_require__(57433);
const getAttrPathList_1 = __nccwpck_require__(81844);
const getAttr = (value, path) => (0, getAttrPathList_1.getAttrPathList)(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
        throw new types_1.EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    }
    else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
    }
    return acc[index];
}, value);
exports.getAttr = getAttr;


/***/ }),

/***/ 81844:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAttrPathList = void 0;
const types_1 = __nccwpck_require__(57433);
const getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
                throw new types_1.EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
                throw new types_1.EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
                pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
        }
        else {
            pathList.push(part);
        }
    }
    return pathList;
};
exports.getAttrPathList = getAttrPathList;


/***/ }),

/***/ 83188:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aws = void 0;
const tslib_1 = __nccwpck_require__(4351);
exports.aws = tslib_1.__importStar(__nccwpck_require__(46835));
tslib_1.__exportStar(__nccwpck_require__(55370), exports);
tslib_1.__exportStar(__nccwpck_require__(20767), exports);
tslib_1.__exportStar(__nccwpck_require__(78816), exports);
tslib_1.__exportStar(__nccwpck_require__(57373), exports);
tslib_1.__exportStar(__nccwpck_require__(29692), exports);
tslib_1.__exportStar(__nccwpck_require__(22780), exports);
tslib_1.__exportStar(__nccwpck_require__(55182), exports);
tslib_1.__exportStar(__nccwpck_require__(48305), exports);
tslib_1.__exportStar(__nccwpck_require__(6535), exports);


/***/ }),

/***/ 73442:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isIpAddress = void 0;
const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith("[") && value.endsWith("]"));
exports.isIpAddress = isIpAddress;


/***/ }),

/***/ 78816:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSet = void 0;
const isSet = (value) => value != null;
exports.isSet = isSet;


/***/ }),

/***/ 57373:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidHostLabel = void 0;
const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
        if (!(0, exports.isValidHostLabel)(label)) {
            return false;
        }
    }
    return true;
};
exports.isValidHostLabel = isValidHostLabel;


/***/ }),

/***/ 29692:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.not = void 0;
const not = (value) => !value;
exports.not = not;


/***/ }),

/***/ 22780:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseURL = void 0;
const types_1 = __nccwpck_require__(89029);
const isIpAddress_1 = __nccwpck_require__(73442);
const DEFAULT_PORTS = {
    [types_1.EndpointURLScheme.HTTP]: 80,
    [types_1.EndpointURLScheme.HTTPS]: 443,
};
const parseURL = (value) => {
    const whatwgURL = (() => {
        try {
            if (value instanceof URL) {
                return value;
            }
            if (typeof value === "object" && "hostname" in value) {
                const { hostname, port, protocol = "", path = "", query = {} } = value;
                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                url.search = Object.entries(query)
                    .map(([k, v]) => `${k}=${v}`)
                    .join("&");
                return url;
            }
            return new URL(value);
        }
        catch (error) {
            return null;
        }
    })();
    if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
        return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(types_1.EndpointURLScheme).includes(scheme)) {
        return null;
    }
    const isIp = (0, isIpAddress_1.isIpAddress)(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||
        (typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp,
    };
};
exports.parseURL = parseURL;


/***/ }),

/***/ 55182:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringEquals = void 0;
const stringEquals = (value1, value2) => value1 === value2;
exports.stringEquals = stringEquals;


/***/ }),

/***/ 48305:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.substring = void 0;
const substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
        return null;
    }
    if (!reverse) {
        return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
};
exports.substring = substring;


/***/ }),

/***/ 6535:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uriEncode = void 0;
const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
exports.uriEncode = uriEncode;


/***/ }),

/***/ 36563:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpoint = void 0;
const debug_1 = __nccwpck_require__(27617);
const types_1 = __nccwpck_require__(57433);
const utils_1 = __nccwpck_require__(81114);
const resolveEndpoint = (ruleSetObject, options) => {
    var _a, _b, _c, _d, _e, _f;
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `Initial EndpointParams: ${(0, debug_1.toDebugString)(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters)
        .filter(([, v]) => v.default != null)
        .map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
            endpointParams[paramKey] = (_c = endpointParams[paramKey]) !== null && _c !== void 0 ? _c : paramDefaultValue;
        }
    }
    const requiredParams = Object.entries(parameters)
        .filter(([, v]) => v.required)
        .map(([k]) => k);
    for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
            throw new types_1.EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
    }
    const endpoint = (0, utils_1.evaluateRules)(rules, { endpointParams, logger, referenceRecord: {} });
    if ((_d = options.endpointParams) === null || _d === void 0 ? void 0 : _d.Endpoint) {
        try {
            const givenEndpoint = new URL(options.endpointParams.Endpoint);
            const { protocol, port } = givenEndpoint;
            endpoint.url.protocol = protocol;
            endpoint.url.port = port;
        }
        catch (e) {
        }
    }
    (_f = (_e = options.logger) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, debug_1.debugId, `Resolved endpoint: ${(0, debug_1.toDebugString)(endpoint)}`);
    return endpoint;
};
exports.resolveEndpoint = resolveEndpoint;


/***/ }),

/***/ 82605:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointError = void 0;
class EndpointError extends Error {
    constructor(message) {
        super(message);
        this.name = "EndpointError";
    }
}
exports.EndpointError = EndpointError;


/***/ }),

/***/ 21261:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 20312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 56083:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 21767:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57433:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(82605), exports);
tslib_1.__exportStar(__nccwpck_require__(21261), exports);
tslib_1.__exportStar(__nccwpck_require__(20312), exports);
tslib_1.__exportStar(__nccwpck_require__(56083), exports);
tslib_1.__exportStar(__nccwpck_require__(21767), exports);
tslib_1.__exportStar(__nccwpck_require__(41811), exports);


/***/ }),

/***/ 41811:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 65075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.callFunction = void 0;
const tslib_1 = __nccwpck_require__(4351);
const lib = tslib_1.__importStar(__nccwpck_require__(83188));
const evaluateExpression_1 = __nccwpck_require__(82980);
const callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : (0, evaluateExpression_1.evaluateExpression)(arg, "arg", options));
    return fn.split(".").reduce((acc, key) => acc[key], lib)(...evaluatedArgs);
};
exports.callFunction = callFunction;


/***/ }),

/***/ 77851:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateCondition = void 0;
const debug_1 = __nccwpck_require__(27617);
const types_1 = __nccwpck_require__(57433);
const callFunction_1 = __nccwpck_require__(65075);
const evaluateCondition = ({ assign, ...fnArgs }, options) => {
    var _a, _b;
    if (assign && assign in options.referenceRecord) {
        throw new types_1.EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = (0, callFunction_1.callFunction)(fnArgs, options);
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `evaluateCondition: ${(0, debug_1.toDebugString)(fnArgs)} = ${(0, debug_1.toDebugString)(value)}`);
    return {
        result: value === "" ? true : !!value,
        ...(assign != null && { toAssign: { name: assign, value } }),
    };
};
exports.evaluateCondition = evaluateCondition;


/***/ }),

/***/ 59169:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateConditions = void 0;
const debug_1 = __nccwpck_require__(27617);
const evaluateCondition_1 = __nccwpck_require__(77851);
const evaluateConditions = (conditions = [], options) => {
    var _a, _b;
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
        const { result, toAssign } = (0, evaluateCondition_1.evaluateCondition)(condition, {
            ...options,
            referenceRecord: {
                ...options.referenceRecord,
                ...conditionsReferenceRecord,
            },
        });
        if (!result) {
            return { result };
        }
        if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `assign: ${toAssign.name} := ${(0, debug_1.toDebugString)(toAssign.value)}`);
        }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
};
exports.evaluateConditions = evaluateConditions;


/***/ }),

/***/ 35324:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateEndpointRule = void 0;
const debug_1 = __nccwpck_require__(27617);
const evaluateConditions_1 = __nccwpck_require__(59169);
const getEndpointHeaders_1 = __nccwpck_require__(88268);
const getEndpointProperties_1 = __nccwpck_require__(34973);
const getEndpointUrl_1 = __nccwpck_require__(23602);
const evaluateEndpointRule = (endpointRule, options) => {
    var _a, _b;
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    };
    const { url, properties, headers } = endpoint;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `Resolving endpoint from template: ${(0, debug_1.toDebugString)(endpoint)}`);
    return {
        ...(headers != undefined && {
            headers: (0, getEndpointHeaders_1.getEndpointHeaders)(headers, endpointRuleOptions),
        }),
        ...(properties != undefined && {
            properties: (0, getEndpointProperties_1.getEndpointProperties)(properties, endpointRuleOptions),
        }),
        url: (0, getEndpointUrl_1.getEndpointUrl)(url, endpointRuleOptions),
    };
};
exports.evaluateEndpointRule = evaluateEndpointRule;


/***/ }),

/***/ 12110:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateErrorRule = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateConditions_1 = __nccwpck_require__(59169);
const evaluateExpression_1 = __nccwpck_require__(82980);
const evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    throw new types_1.EndpointError((0, evaluateExpression_1.evaluateExpression)(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    }));
};
exports.evaluateErrorRule = evaluateErrorRule;


/***/ }),

/***/ 82980:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateExpression = void 0;
const types_1 = __nccwpck_require__(57433);
const callFunction_1 = __nccwpck_require__(65075);
const evaluateTemplate_1 = __nccwpck_require__(57535);
const getReferenceValue_1 = __nccwpck_require__(68810);
const evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
        return (0, evaluateTemplate_1.evaluateTemplate)(obj, options);
    }
    else if (obj["fn"]) {
        return (0, callFunction_1.callFunction)(obj, options);
    }
    else if (obj["ref"]) {
        return (0, getReferenceValue_1.getReferenceValue)(obj, options);
    }
    throw new types_1.EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
exports.evaluateExpression = evaluateExpression;


/***/ }),

/***/ 59738:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateRules = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateEndpointRule_1 = __nccwpck_require__(35324);
const evaluateErrorRule_1 = __nccwpck_require__(12110);
const evaluateTreeRule_1 = __nccwpck_require__(26587);
const evaluateRules = (rules, options) => {
    for (const rule of rules) {
        if (rule.type === "endpoint") {
            const endpointOrUndefined = (0, evaluateEndpointRule_1.evaluateEndpointRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else if (rule.type === "error") {
            (0, evaluateErrorRule_1.evaluateErrorRule)(rule, options);
        }
        else if (rule.type === "tree") {
            const endpointOrUndefined = (0, evaluateTreeRule_1.evaluateTreeRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else {
            throw new types_1.EndpointError(`Unknown endpoint rule: ${rule}`);
        }
    }
    throw new types_1.EndpointError(`Rules evaluation failed`);
};
exports.evaluateRules = evaluateRules;


/***/ }),

/***/ 57535:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateTemplate = void 0;
const lib_1 = __nccwpck_require__(83188);
const evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push((0, lib_1.getAttr)(templateContext[refName], attrName));
        }
        else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
};
exports.evaluateTemplate = evaluateTemplate;


/***/ }),

/***/ 26587:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateTreeRule = void 0;
const evaluateConditions_1 = __nccwpck_require__(59169);
const evaluateRules_1 = __nccwpck_require__(59738);
const evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    return (0, evaluateRules_1.evaluateRules)(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    });
};
exports.evaluateTreeRule = evaluateTreeRule;


/***/ }),

/***/ 88268:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointHeaders = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateExpression_1 = __nccwpck_require__(82980);
const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = (0, evaluateExpression_1.evaluateExpression)(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
            throw new types_1.EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
    }),
}), {});
exports.getEndpointHeaders = getEndpointHeaders;


/***/ }),

/***/ 34973:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointProperties = void 0;
const getEndpointProperty_1 = __nccwpck_require__(42978);
const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: (0, getEndpointProperty_1.getEndpointProperty)(propertyVal, options),
}), {});
exports.getEndpointProperties = getEndpointProperties;


/***/ }),

/***/ 42978:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointProperty = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateTemplate_1 = __nccwpck_require__(57535);
const getEndpointProperties_1 = __nccwpck_require__(34973);
const getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
        return property.map((propertyEntry) => (0, exports.getEndpointProperty)(propertyEntry, options));
    }
    switch (typeof property) {
        case "string":
            return (0, evaluateTemplate_1.evaluateTemplate)(property, options);
        case "object":
            if (property === null) {
                throw new types_1.EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return (0, getEndpointProperties_1.getEndpointProperties)(property, options);
        case "boolean":
            return property;
        default:
            throw new types_1.EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
};
exports.getEndpointProperty = getEndpointProperty;


/***/ }),

/***/ 23602:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointUrl = void 0;
const types_1 = __nccwpck_require__(57433);
const evaluateExpression_1 = __nccwpck_require__(82980);
const getEndpointUrl = (endpointUrl, options) => {
    const expression = (0, evaluateExpression_1.evaluateExpression)(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
        try {
            return new URL(expression);
        }
        catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
        }
    }
    throw new types_1.EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};
exports.getEndpointUrl = getEndpointUrl;


/***/ }),

/***/ 68810:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getReferenceValue = void 0;
const getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    return referenceRecord[ref];
};
exports.getReferenceValue = getReferenceValue;


/***/ }),

/***/ 81114:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(59738), exports);


/***/ }),

/***/ 1968:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toHex = exports.fromHex = void 0;
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
exports.fromHex = fromHex;
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}
exports.toHex = toHex;


/***/ }),

/***/ 10236:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(77776), exports);


/***/ }),

/***/ 77776:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeProvider = void 0;
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};
exports.normalizeProvider = normalizeProvider;


/***/ }),

/***/ 66968:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveRetryStrategy = void 0;
const config_1 = __nccwpck_require__(6514);
const DefaultRateLimiter_1 = __nccwpck_require__(258);
const StandardRetryStrategy_1 = __nccwpck_require__(43449);
class AdaptiveRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = config_1.RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options !== null && options !== void 0 ? options : {};
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new DefaultRateLimiter_1.DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy_1.StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultRateLimiter = void 0;
const service_error_classification_1 = __nccwpck_require__(61921);
class DefaultRateLimiter {
    constructor(options) {
        var _a, _b, _c, _d, _e;
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;
        this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;
        this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;
        this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;
        this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1000;
    }
    async getSendToken() {
        return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
        if (!this.enabled) {
            return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if ((0, service_error_classification_1.isThrottlingError)(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
        }
        else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
        this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
        const t = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
        }
    }
    getPrecise(num) {
        return parseFloat(num.toFixed(8));
    }
}
exports.DefaultRateLimiter = DefaultRateLimiter;


/***/ }),

/***/ 43449:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardRetryStrategy = void 0;
const config_1 = __nccwpck_require__(6514);
const constants_1 = __nccwpck_require__(65056);
const defaultRetryToken_1 = __nccwpck_require__(41360);
class StandardRetryStrategy {
    constructor(maxAttemptsProvider) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = config_1.RETRY_MODES.STANDARD;
        this.retryToken = (0, defaultRetryToken_1.getDefaultRetryToken)(constants_1.INITIAL_RETRY_TOKENS, constants_1.DEFAULT_RETRY_DELAY_BASE);
        this.maxAttemptsProvider = maxAttemptsProvider;
    }
    async acquireInitialRetryToken(retryTokenScope) {
        return this.retryToken;
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {
            tokenToRenew.getRetryTokenCount(errorInfo);
            return tokenToRenew;
        }
        throw new Error("No retry token available");
    }
    recordSuccess(token) {
        this.retryToken.releaseRetryTokens(token.getLastRetryCost());
    }
    async getMaxAttempts() {
        let maxAttempts;
        try {
            return await this.maxAttemptsProvider();
        }
        catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${config_1.DEFAULT_MAX_ATTEMPTS}`);
            return config_1.DEFAULT_MAX_ATTEMPTS;
        }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount();
        return (attempts < maxAttempts &&
            tokenToRenew.hasRetryTokens(errorInfo.errorType) &&
            this.isRetryableError(errorInfo.errorType));
    }
    isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;


/***/ }),

/***/ 6514:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_RETRY_MODE = exports.DEFAULT_MAX_ATTEMPTS = exports.RETRY_MODES = void 0;
var RETRY_MODES;
(function (RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
})(RETRY_MODES = exports.RETRY_MODES || (exports.RETRY_MODES = {}));
exports.DEFAULT_MAX_ATTEMPTS = 3;
exports.DEFAULT_RETRY_MODE = "STANDARD";


/***/ }),

/***/ 65056:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REQUEST_HEADER = exports.INVOCATION_ID_HEADER = exports.NO_RETRY_INCREMENT = exports.TIMEOUT_RETRY_COST = exports.RETRY_COST = exports.INITIAL_RETRY_TOKENS = exports.THROTTLING_RETRY_DELAY_BASE = exports.MAXIMUM_RETRY_DELAY = exports.DEFAULT_RETRY_DELAY_BASE = void 0;
exports.DEFAULT_RETRY_DELAY_BASE = 100;
exports.MAXIMUM_RETRY_DELAY = 20 * 1000;
exports.THROTTLING_RETRY_DELAY_BASE = 500;
exports.INITIAL_RETRY_TOKENS = 500;
exports.RETRY_COST = 5;
exports.TIMEOUT_RETRY_COST = 10;
exports.NO_RETRY_INCREMENT = 1;
exports.INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
exports.REQUEST_HEADER = "amz-sdk-request";


/***/ }),

/***/ 44763:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRetryBackoffStrategy = void 0;
const constants_1 = __nccwpck_require__(65056);
const getDefaultRetryBackoffStrategy = () => {
    let delayBase = constants_1.DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(constants_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
        delayBase = delay;
    };
    return {
        computeNextBackoffDelay,
        setDelayBase,
    };
};
exports.getDefaultRetryBackoffStrategy = getDefaultRetryBackoffStrategy;


/***/ }),

/***/ 41360:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRetryToken = void 0;
const constants_1 = __nccwpck_require__(65056);
const defaultRetryBackoffStrategy_1 = __nccwpck_require__(44763);
const getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {
    var _a, _b, _c;
    const MAX_CAPACITY = initialRetryTokens;
    const retryCost = (_a = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _a !== void 0 ? _a : constants_1.RETRY_COST;
    const timeoutRetryCost = (_b = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _b !== void 0 ? _b : constants_1.TIMEOUT_RETRY_COST;
    const retryBackoffStrategy = (_c = options === null || options === void 0 ? void 0 : options.retryBackoffStrategy) !== null && _c !== void 0 ? _c : (0, defaultRetryBackoffStrategy_1.getDefaultRetryBackoffStrategy)();
    let availableCapacity = initialRetryTokens;
    let retryDelay = Math.min(constants_1.MAXIMUM_RETRY_DELAY, initialRetryDelay);
    let lastRetryCost = undefined;
    let retryCount = initialRetryCount !== null && initialRetryCount !== void 0 ? initialRetryCount : 0;
    const getCapacityAmount = (errorType) => (errorType === "TRANSIENT" ? timeoutRetryCost : retryCost);
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => retryDelay;
    const getLastRetryCost = () => lastRetryCost;
    const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;
    const getRetryTokenCount = (errorInfo) => {
        const errorType = errorInfo.errorType;
        if (!hasRetryTokens(errorType)) {
            throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(errorType);
        const delayBase = errorType === "THROTTLING" ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE;
        retryBackoffStrategy.setDelayBase(delayBase);
        const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);
        if (errorInfo.retryAfterHint) {
            const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();
            retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);
        }
        else {
            retryDelay = delayFromErrorType;
        }
        retryCount++;
        lastRetryCost = capacityAmount;
        availableCapacity -= capacityAmount;
        return capacityAmount;
    };
    const releaseRetryTokens = (releaseAmount) => {
        availableCapacity += releaseAmount !== null && releaseAmount !== void 0 ? releaseAmount : constants_1.NO_RETRY_INCREMENT;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return {
        getRetryCount,
        getRetryDelay,
        getLastRetryCost,
        hasRetryTokens,
        getRetryTokenCount,
        releaseRetryTokens,
    };
};
exports.getDefaultRetryToken = getDefaultRetryToken;


/***/ }),

/***/ 99395:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(66968), exports);
tslib_1.__exportStar(__nccwpck_require__(258), exports);
tslib_1.__exportStar(__nccwpck_require__(43449), exports);
tslib_1.__exportStar(__nccwpck_require__(6514), exports);
tslib_1.__exportStar(__nccwpck_require__(65056), exports);
tslib_1.__exportStar(__nccwpck_require__(91318), exports);


/***/ }),

/***/ 91318:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 15774:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUriPath = void 0;
const escape_uri_1 = __nccwpck_require__(24652);
const escapeUriPath = (uri) => uri.split("/").map(escape_uri_1.escapeUri).join("/");
exports.escapeUriPath = escapeUriPath;


/***/ }),

/***/ 24652:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUri = void 0;
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
exports.escapeUri = escapeUri;
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;


/***/ }),

/***/ 57952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(24652), exports);
tslib_1.__exportStar(__nccwpck_require__(15774), exports);


/***/ }),

/***/ 98095:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultUserAgent = exports.UA_APP_ID_INI_NAME = exports.UA_APP_ID_ENV_NAME = void 0;
const node_config_provider_1 = __nccwpck_require__(87684);
const os_1 = __nccwpck_require__(22037);
const process_1 = __nccwpck_require__(77282);
const is_crt_available_1 = __nccwpck_require__(68390);
exports.UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
exports.UA_APP_ID_INI_NAME = "sdk-ua-app-id";
const defaultUserAgent = ({ serviceId, clientVersion }) => {
    const sections = [
        ["aws-sdk-js", clientVersion],
        [`os/${(0, os_1.platform)()}`, (0, os_1.release)()],
        ["lang/js"],
        ["md/nodejs", `${process_1.versions.node}`],
    ];
    const crtAvailable = (0, is_crt_available_1.isCrtAvailable)();
    if (crtAvailable) {
        sections.push(crtAvailable);
    }
    if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
    }
    if (process_1.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${process_1.env.AWS_EXECUTION_ENV}`]);
    }
    const appIdPromise = (0, node_config_provider_1.loadConfig)({
        environmentVariableSelector: (env) => env[exports.UA_APP_ID_ENV_NAME],
        configFileSelector: (profile) => profile[exports.UA_APP_ID_INI_NAME],
        default: undefined,
    })();
    let resolvedUserAgent = undefined;
    return async () => {
        if (!resolvedUserAgent) {
            const appId = await appIdPromise;
            resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        }
        return resolvedUserAgent;
    };
};
exports.defaultUserAgent = defaultUserAgent;


/***/ }),

/***/ 68390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCrtAvailable = void 0;
const isCrtAvailable = () => {
    try {
        if ( true && __nccwpck_require__(87578)) {
            return ["md/crt-avail"];
        }
        return null;
    }
    catch (e) {
        return null;
    }
};
exports.isCrtAvailable = isCrtAvailable;


/***/ }),

/***/ 66278:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = exports.fromUtf8 = void 0;
const util_buffer_from_1 = __nccwpck_require__(36010);
const fromUtf8 = (input) => {
    const buf = (0, util_buffer_from_1.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
exports.fromUtf8 = fromUtf8;
const toUtf8 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 38880:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWaiter = void 0;
const poller_1 = __nccwpck_require__(92105);
const utils_1 = __nccwpck_require__(36001);
const waiter_1 = __nccwpck_require__(4996);
const abortTimeout = async (abortSignal) => {
    return new Promise((resolve) => {
        abortSignal.onabort = () => resolve({ state: waiter_1.WaiterState.ABORTED });
    });
};
const createWaiter = async (options, input, acceptorChecks) => {
    const params = {
        ...waiter_1.waiterServiceDefaults,
        ...options,
    };
    (0, utils_1.validateWaiterOptions)(params);
    const exitConditions = [(0, poller_1.runPolling)(params, input, acceptorChecks)];
    if (options.abortController) {
        exitConditions.push(abortTimeout(options.abortController.signal));
    }
    if (options.abortSignal) {
        exitConditions.push(abortTimeout(options.abortSignal));
    }
    return Promise.race(exitConditions);
};
exports.createWaiter = createWaiter;


/***/ }),

/***/ 21627:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(38880), exports);
tslib_1.__exportStar(__nccwpck_require__(4996), exports);


/***/ }),

/***/ 92105:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runPolling = void 0;
const sleep_1 = __nccwpck_require__(17397);
const waiter_1 = __nccwpck_require__(4996);
const exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
    if (attempt > attemptCeiling)
        return maxDelay;
    const delay = minDelay * 2 ** (attempt - 1);
    return randomInRange(minDelay, delay);
};
const randomInRange = (min, max) => min + Math.random() * (max - min);
const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {
    var _a;
    const { state, reason } = await acceptorChecks(client, input);
    if (state !== waiter_1.WaiterState.RETRY) {
        return { state, reason };
    }
    let currentAttempt = 1;
    const waitUntil = Date.now() + maxWaitTime * 1000;
    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
    while (true) {
        if (((_a = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _a === void 0 ? void 0 : _a.aborted) || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
            return { state: waiter_1.WaiterState.ABORTED };
        }
        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
        if (Date.now() + delay * 1000 > waitUntil) {
            return { state: waiter_1.WaiterState.TIMEOUT };
        }
        await (0, sleep_1.sleep)(delay);
        const { state, reason } = await acceptorChecks(client, input);
        if (state !== waiter_1.WaiterState.RETRY) {
            return { state, reason };
        }
        currentAttempt += 1;
    }
};
exports.runPolling = runPolling;


/***/ }),

/***/ 36001:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(17397), exports);
tslib_1.__exportStar(__nccwpck_require__(23931), exports);


/***/ }),

/***/ 17397:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sleep = void 0;
const sleep = (seconds) => {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
};
exports.sleep = sleep;


/***/ }),

/***/ 23931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateWaiterOptions = void 0;
const validateWaiterOptions = (options) => {
    if (options.maxWaitTime < 1) {
        throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
    }
    else if (options.minDelay < 1) {
        throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
    }
    else if (options.maxDelay < 1) {
        throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
    }
    else if (options.maxWaitTime <= options.minDelay) {
        throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
    else if (options.maxDelay < options.minDelay) {
        throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
};
exports.validateWaiterOptions = validateWaiterOptions;


/***/ }),

/***/ 4996:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkExceptions = exports.WaiterState = exports.waiterServiceDefaults = void 0;
exports.waiterServiceDefaults = {
    minDelay: 2,
    maxDelay: 120,
};
var WaiterState;
(function (WaiterState) {
    WaiterState["ABORTED"] = "ABORTED";
    WaiterState["FAILURE"] = "FAILURE";
    WaiterState["SUCCESS"] = "SUCCESS";
    WaiterState["RETRY"] = "RETRY";
    WaiterState["TIMEOUT"] = "TIMEOUT";
})(WaiterState = exports.WaiterState || (exports.WaiterState = {}));
const checkExceptions = (result) => {
    if (result.state === WaiterState.ABORTED) {
        const abortError = new Error(`${JSON.stringify({
            ...result,
            reason: "Request was aborted",
        })}`);
        abortError.name = "AbortError";
        throw abortError;
    }
    else if (result.state === WaiterState.TIMEOUT) {
        const timeoutError = new Error(`${JSON.stringify({
            ...result,
            reason: "Waiter has timed out",
        })}`);
        timeoutError.name = "TimeoutError";
        throw timeoutError;
    }
    else if (result.state !== WaiterState.SUCCESS) {
        throw new Error(`${JSON.stringify({ result })}`);
    }
    return result;
};
exports.checkExceptions = checkExceptions;


/***/ }),

/***/ 12603:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const validator = __nccwpck_require__(61739);
const XMLParser = __nccwpck_require__(42380);
const XMLBuilder = __nccwpck_require__(80660);

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ 38280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ 61739:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(38280);

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ 80660:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __nccwpck_require__(72462);

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  transformTagName: false,
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }

  if (this.options.suppressEmptyNode) {
    this.buildTextNode = buildEmptyTextNode;
    this.buildObjNode = buildEmptyObjNode;
  } else {
    this.buildTextNode = buildTextValNode;
    this.buildObjNode = buildObjectNode;
  }

  this.buildTextValNode = buildTextValNode;
  this.buildObjectNode = buildObjectNode;

  this.replaceEntitiesValue = replaceEntitiesValue;
  this.buildAttrPairStr = buildAttrPairStr;
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0).val;
  }
};

Builder.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  for (let key in jObj) {
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node
    } else if (jObj[key] === null) {
      if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      }else {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          val += this.processTextOrObjNode(item, key, level)
        } else {
          val += this.buildTextNode(item, key, '', level);
        }
      }
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

function buildAttrPairStr(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjNode(result.val, key, result.attrStr, level);
  }
}

function buildObjectNode(val, key, attrStr, level) {
  let tagEndExp = '</' + key + this.tagEndChar;
  let piClosingChar = "";
  
  if(key[0] === "?") {
    piClosingChar = "?";
    tagEndExp = "";
  }

  if (attrStr && val.indexOf('<') === -1) {
    return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
  } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
    return this.indentate(level) + `<!--${val}-->` + this.newLine;
  }else {
    return (
      this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
      val +
      this.indentate(level) + tagEndExp    );
  }
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
  }
}

function buildTextValNode(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
      if(this.options.suppressUnpairedNode){
        return this.indentate(level) + '<' + key + this.tagEndChar;
      }else{
        return this.indentate(level) + '<' + key + "/" + this.tagEndChar;
      }
    } else{
      return (
        this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar  );
    }

  }
}

function replaceEntitiesValue(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function buildEmptyTextNode(val, key, attrStr, level) {
  if( val === '' && this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(this.options.suppressUnpairedNode){
      return this.indentate(level) + '<' + key + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + "/" + this.tagEndChar;
    }
  }else if (val !== '') { //empty
    return this.buildTextValNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; //PI tag
    else return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar; //normal
  }
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix)) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ 72462:
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options){
    return arrToStr( jArray, options, "", 0);
}

function arrToStr(arr, options, jPath, level){
    let xmlStr = "";

    let indentation = "";
    if(options.format && options.indentBy.length > 0){//TODO: this logic can be avoided for each call
        indentation = EOL + "" + options.indentBy.repeat(level);
    }

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        let newJPath = "";
        if(jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if(tagName === options.textNodeName){
            let tagText = tagObj[tagName];
            if(!isStopNode(newJPath, options)){
                tagText = options.tagValueProcessor( tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            xmlStr += indentation + tagText;
            continue;
        }else if( tagName === options.cdataPropName){
            xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            continue;
        }else if( tagName === options.commentPropName){
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            continue;
        }else if( tagName[0] === "?"){
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            continue;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        let tagStart =  indentation + `<${tagName}${attStr}`;
        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);
        if(options.unpairedTags.indexOf(tagName) !== -1){
            if(options.suppressUnpairedNode)  xmlStr += tagStart + ">"; 
            else xmlStr += tagStart + "/>"; 
        }else if( (!tagValue || tagValue.length === 0) && options.suppressEmptyNode){ 
            xmlStr += tagStart + "/>"; 
        }else{ 
            //TODO: node with only text value should not parse the text value in next line
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>` ;
        }
    }
    
    return xmlStr;
}

function propName(obj){
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if(key !== ":@") return key;
    }
  }

function attr_to_str(attrMap, options){
    let attrStr = "";
    if(attrMap && !options.ignoreAttributes){
        for (let attr in attrMap){
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if(attrVal === true && options.suppressBooleanAttributes){
                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}`;
            }else{
                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options){
    jPath = jPath.substr(0,jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for(let index in options.stopNodes){
        if(options.stopNodes[index] === jPath || options.stopNodes[index] === "*."+tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options){
    if(textValue && textValue.length > 0 && options.processEntities){
      for (let i=0; i< options.entities.length; i++) {
        const entity = options.entities[i];
        textValue = textValue.replace(entity.regex, entity.val);
      }
    }
    return textValue;
  }
module.exports = toXml;

/***/ }),

/***/ 6072:
/***/ ((module) => {

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, entity = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<') {
                if( hasBody && 
                     xmlData[i+1] === '!' &&
                     xmlData[i+2] === 'E' &&
                     xmlData[i+3] === 'N' &&
                     xmlData[i+4] === 'T' &&
                     xmlData[i+5] === 'I' &&
                     xmlData[i+6] === 'T' &&
                     xmlData[i+7] === 'Y'
                ){
                    i += 7;
                    entity = true;
                }else if( hasBody && 
                    xmlData[i+1] === '!' &&
                     xmlData[i+2] === 'E' &&
                     xmlData[i+3] === 'L' &&
                     xmlData[i+4] === 'E' &&
                     xmlData[i+5] === 'M' &&
                     xmlData[i+6] === 'E' &&
                     xmlData[i+7] === 'N' &&
                     xmlData[i+8] === 'T'
                ){
                    //Not supported
                    i += 8;
                }else if( hasBody && 
                    xmlData[i+1] === '!' &&
                    xmlData[i+2] === 'A' &&
                    xmlData[i+3] === 'T' &&
                    xmlData[i+4] === 'T' &&
                    xmlData[i+5] === 'L' &&
                    xmlData[i+6] === 'I' &&
                    xmlData[i+7] === 'S' &&
                    xmlData[i+8] === 'T'
                ){
                    //Not supported
                    i += 8;
                }else if( hasBody && 
                    xmlData[i+1] === '!' &&
                    xmlData[i+2] === 'N' &&
                    xmlData[i+3] === 'O' &&
                    xmlData[i+4] === 'T' &&
                    xmlData[i+5] === 'A' &&
                    xmlData[i+6] === 'T' &&
                    xmlData[i+7] === 'I' &&
                    xmlData[i+8] === 'O' &&
                    xmlData[i+9] === 'N'
                ){
                    //Not supported
                    i += 9;
                }else if( //comment
                    xmlData[i+1] === '!' &&
                    xmlData[i+2] === '-' &&
                    xmlData[i+3] === '-'
                ){
                    comment = true;
                }else{
                    throw new Error("Invalid DOCTYPE");
                }
                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') {
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                    }else{
                        throw new Error(`Invalid XML comment in DOCTYPE`);
                    }
                }else if(entity){
                    parseEntityExp(exp, entities);
                    entity = false;
                }
                angleBracketsCount--;
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

const entityRegex = RegExp("^\\s([a-zA-z0-0]+)[ \t](['\"])([^&]+)\\2");
function parseEntityExp(exp, entities){
    const match = entityRegex.exec(exp);
    if(match){
        entities[ match[1] ] = {
            regx : RegExp( `&${match[1]};`,"g"),
            val: match[3]
        };
    }
}
module.exports = readDocType;

/***/ }),

/***/ 86993:
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ 25832:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

///@ts-check

const util = __nccwpck_require__(38280);
const xmlNode = __nccwpck_require__(7462);
const readDocType = __nccwpck_require__(6072);
const toNumber = __nccwpck_require__(14526);

const regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
  .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "" },
      "pound" : { regex: /&(pound|#163);/g, val: "" },
      "yen" : { regex: /&(yen|#165);/g, val: "" },
      "euro" : { regex: /&(euro|#8364);/g, val: "" },
      "copyright" : { regex: /&(copy|#169);/g, val: "" },
      "reg" : { regex: /&(reg|#174);/g, val: "" },
      "inr" : { regex: /&(inr|#8377);/g, val: "" },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath) {
  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      const aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        jPath = jPath.substr(0, jPath.lastIndexOf("."));
        
        currentNode = this.tagsNodeStack.pop();//avoid recurssion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath);
          }
          currentNode.addChild(childNode);

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + "." + this.options.cdataPropName, true, false, true);
          // if(!val) val = "";
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
          if(val == undefined) val = "";
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this. options.removeNSPrefix);
        let tagName= result.tagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
        }

        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            i = result.closeIndex;
          }
          //boolean tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${tagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          currentNode.addChild(childNode);
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
            }
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
            currentNode.addChild(childNode);
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath);
            }
            currentNode.addChild(childNode);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-dobule quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
    tagExp = tagExp.substr(separatorIndex + 1);
  }

  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ 42380:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { buildOptions} = __nccwpck_require__(86993);
const OrderedObjParser = __nccwpck_require__(25832);
const { prettify} = __nccwpck_require__(42882);
const validator = __nccwpck_require__(61739);

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ 42882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const propCount = Object.keys(obj).length;
  if( propCount === 0 || (propCount === 1 && obj[options.textNodeName]) ) return true;
  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ 7462:
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ 14526:
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ }),

/***/ 4351:
/***/ ((module) => {

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
});


/***/ }),

/***/ 74294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(54219);


/***/ }),

/***/ 54219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(41808);
var tls = __nccwpck_require__(24404);
var http = __nccwpck_require__(13685);
var https = __nccwpck_require__(95687);
var events = __nccwpck_require__(82361);
var assert = __nccwpck_require__(39491);
var util = __nccwpck_require__(73837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 87578:
/***/ ((module) => {

module.exports = eval("require")("aws-crt");


/***/ }),

/***/ 39491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 14300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 32081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 82361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 57147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 13685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 85158:
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),

/***/ 95687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 41808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 22037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 71017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 77282:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 24404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 57310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 73837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 8109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var Scalar = __nccwpck_require__(9338);
var resolveBlockMap = __nccwpck_require__(62986);
var resolveBlockSeq = __nccwpck_require__(2289);
var resolveFlowCollection = __nccwpck_require__(20045);

function composeCollection(CN, ctx, token, tagToken, onError) {
    let coll;
    switch (token.type) {
        case 'block-map': {
            coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);
            break;
        }
        case 'block-seq': {
            coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);
            break;
        }
        case 'flow-collection': {
            coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);
            break;
        }
    }
    if (!tagToken)
        return coll;
    const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    if (!tagName)
        return coll;
    // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841
    const Coll = coll.constructor;
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    const expType = Node.isMap(coll) ? 'map' : 'seq';
    let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            coll.tag = tagName;
            return coll;
        }
    }
    const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);
    const node = Node.isNode(res)
        ? res
        : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

exports.composeCollection = composeCollection;


/***/ }),

/***/ 25050:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Document = __nccwpck_require__(10042);
var composeNode = __nccwpck_require__(38676);
var resolveEnd = __nccwpck_require__(1250);
var resolveProps = __nccwpck_require__(6985);

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

exports.composeDoc = composeDoc;


/***/ }),

/***/ 38676:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Alias = __nccwpck_require__(5639);
var composeCollection = __nccwpck_require__(8109);
var composeScalar = __nccwpck_require__(94766);
var resolveEnd = __nccwpck_require__(1250);
var utilEmptyScalarPosition = __nccwpck_require__(78781);

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar.composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;


/***/ }),

/***/ 94766:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var Scalar = __nccwpck_require__(9338);
var resolveBlockScalar = __nccwpck_require__(7521);
var resolveFlowScalar = __nccwpck_require__(97578);

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError)
        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    const tag = tagToken && tagName
        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
        : token.type === 'scalar'
            ? findScalarTagByTest(ctx, value, token, onError)
            : ctx.schema[Node.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[Node.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[Node.SCALAR];
}
function findScalarTagByTest({ directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[Node.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[Node.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

exports.composeScalar = composeScalar;


/***/ }),

/***/ 19493:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var directives = __nccwpck_require__(5400);
var Document = __nccwpck_require__(10042);
var errors = __nccwpck_require__(14236);
var Node = __nccwpck_require__(41399);
var composeDoc = __nccwpck_require__(25050);
var resolveEnd = __nccwpck_require__(1250);

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
            else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (Node.isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        if (process.env.LOG_STREAM)
            console.dir(token, { depth: null });
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document.Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

exports.Composer = Composer;


/***/ }),

/***/ 62986:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Pair = __nccwpck_require__(246);
var YAMLMap = __nccwpck_require__(16011);
var resolveProps = __nccwpck_require__(6985);
var utilContainsNewline = __nccwpck_require__(40976);
var utilFlowIndentCheck = __nccwpck_require__(83669);
var utilMapIncludes = __nccwpck_require__(66899);

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
    const map = new YAMLMap.YAMLMap(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

exports.resolveBlockMap = resolveBlockMap;


/***/ }),

/***/ 7521:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);

function resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

exports.resolveBlockScalar = resolveBlockScalar;


/***/ }),

/***/ 2289:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var YAMLSeq = __nccwpck_require__(25161);
var resolveProps = __nccwpck_require__(6985);
var utilFlowIndentCheck = __nccwpck_require__(83669);

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
    const seq = new YAMLSeq.YAMLSeq(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

exports.resolveBlockSeq = resolveBlockSeq;


/***/ }),

/***/ 1250:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

exports.resolveEnd = resolveEnd;


/***/ }),

/***/ 20045:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var Pair = __nccwpck_require__(246);
var YAMLMap = __nccwpck_require__(16011);
var YAMLSeq = __nccwpck_require__(25161);
var resolveEnd = __nccwpck_require__(1250);
var resolveProps = __nccwpck_require__(6985);
var utilContainsNewline = __nccwpck_require__(40976);
var utilMapIncludes = __nccwpck_require__(66899);

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const coll = isMap
        ? new YAMLMap.YAMLMap(ctx.schema)
        : new YAMLSeq.YAMLSeq(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (Node.isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            //  key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            // value properties
            const valueProps = resolveProps.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

exports.resolveFlowCollection = resolveFlowCollection;


/***/ }),

/***/ 97578:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);
var resolveEnd = __nccwpck_require__(1250);

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0',
    a: '\x07',
    b: '\b',
    e: '\x1b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t',
    v: '\v',
    N: '\u0085',
    _: '\u00a0',
    L: '\u2028',
    P: '\u2029',
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

exports.resolveFlowScalar = resolveFlowScalar;


/***/ }),

/***/ 6985:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    atNewline &&
                    indicator !== 'doc-start' &&
                    token.source[0] === '\t')
                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    hasNewlineAfterProp = true;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== ''))
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
    };
}

exports.resolveProps = resolveProps;


/***/ }),

/***/ 40976:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

exports.containsNewline = containsNewline;


/***/ }),

/***/ 78781:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null)
            pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

exports.emptyScalarPosition = emptyScalarPosition;


/***/ }),

/***/ 83669:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilContainsNewline = __nccwpck_require__(40976);

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            utilContainsNewline.containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

exports.flowIndentCheck = flowIndentCheck;


/***/ }),

/***/ 66899:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b ||
            (Node.isScalar(a) &&
                Node.isScalar(b) &&
                a.value === b.value &&
                !(a.value === '<<' && ctx.schema.merge));
    return items.some(pair => isEqual(pair.key, search));
}

exports.mapIncludes = mapIncludes;


/***/ }),

/***/ 10042:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Alias = __nccwpck_require__(5639);
var Collection = __nccwpck_require__(3466);
var Node = __nccwpck_require__(41399);
var Pair = __nccwpck_require__(246);
var toJS = __nccwpck_require__(72463);
var Schema = __nccwpck_require__(56831);
var stringify = __nccwpck_require__(18409);
var stringifyDocument = __nccwpck_require__(35225);
var anchors = __nccwpck_require__(28459);
var applyReviver = __nccwpck_require__(63412);
var createNode = __nccwpck_require__(9652);
var directives = __nccwpck_require__(5400);

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        if (value === undefined)
            this.contents = null;
        else {
            this.contents = this.createNode(value, _replacer, options);
        }
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [Node.NODE_TYPE]: { value: Node.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = Node.isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && Node.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return Node.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && Node.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return Node.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return Node.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return Node.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            this.contents = Collection.collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (Collection.isEmptyPath(path))
            this.contents = value;
        else if (this.contents == null) {
            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new directives.Directives({ version: '1.1' });
                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new directives.Directives({ version });
                opt = { merge: false, resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema.Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,
            stringify: stringify.stringify
        };
        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (Node.isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

exports.Document = Document;


/***/ }),

/***/ 28459:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var visit = __nccwpck_require__(16796);

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit.visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;


/***/ }),

/***/ 63412:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

exports.applyReviver = applyReviver;


/***/ }),

/***/ 9652:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Alias = __nccwpck_require__(5639);
var Node = __nccwpck_require__(41399);
var Scalar = __nccwpck_require__(9338);

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (Node.isDocument(value))
        value = value.contents;
    if (Node.isNode(value))
        return value;
    if (Node.isPair(value)) {
        const map = ctx.schema[Node.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor)
                ref.anchor = onAnchor(value);
            return new Alias.Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar.Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[Node.MAP]
                : Symbol.iterator in Object(value)
                    ? schema[Node.SEQ]
                    : schema[Node.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : new Scalar.Scalar(value);
    if (tagName)
        node.tag = tagName;
    if (ref)
        ref.node = node;
    return node;
}

exports.createNode = createNode;


/***/ }),

/***/ 5400:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var visit = __nccwpck_require__(16796);

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix)
            return prefix + decodeURIComponent(suffix);
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
            const tags = {};
            visit.visit(doc.contents, (_key, node) => {
                if (Node.isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

exports.Directives = Directives;


/***/ }),

/***/ 14236:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.min(end.col - col, 80 - ci);
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;


/***/ }),

/***/ 44083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var composer = __nccwpck_require__(19493);
var Document = __nccwpck_require__(10042);
var Schema = __nccwpck_require__(56831);
var errors = __nccwpck_require__(14236);
var Alias = __nccwpck_require__(5639);
var Node = __nccwpck_require__(41399);
var Pair = __nccwpck_require__(246);
var Scalar = __nccwpck_require__(9338);
var YAMLMap = __nccwpck_require__(16011);
var YAMLSeq = __nccwpck_require__(25161);
var cst = __nccwpck_require__(19169);
var lexer = __nccwpck_require__(45976);
var lineCounter = __nccwpck_require__(21929);
var parser = __nccwpck_require__(73328);
var publicApi = __nccwpck_require__(28649);
var visit = __nccwpck_require__(16796);



exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = Node.isAlias;
exports.isCollection = Node.isCollection;
exports.isDocument = Node.isDocument;
exports.isMap = Node.isMap;
exports.isNode = Node.isNode;
exports.isPair = Node.isPair;
exports.isScalar = Node.isScalar;
exports.isSeq = Node.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;
exports.visitAsync = visit.visitAsync;


/***/ }),

/***/ 36909:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function debug(logLevel, ...messages) {
    if (logLevel === 'debug')
        console.log(...messages);
}
function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        if (typeof process !== 'undefined' && process.emitWarning)
            process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

exports.debug = debug;
exports.warn = warn;


/***/ }),

/***/ 5639:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var anchors = __nccwpck_require__(28459);
var visit = __nccwpck_require__(16796);
var Node = __nccwpck_require__(41399);

class Alias extends Node.NodeBase {
    constructor(source) {
        super(Node.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit.visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        const data = anchors.get(source);
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (Node.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (Node.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (Node.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

exports.Alias = Alias;


/***/ }),

/***/ 3466:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var createNode = __nccwpck_require__(9652);
var Node = __nccwpck_require__(41399);

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends Node.NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => Node.isNode(it) || Node.isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (Node.isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (Node.isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && Node.isScalar(node) ? node.value : node;
        else
            return Node.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!Node.isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    Node.isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return Node.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (Node.isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
Collection.maxFlowStringSingleLineLength = 60;

exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;


/***/ }),

/***/ 41399:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
class NodeBase {
    constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
}

exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.NodeBase = NodeBase;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;


/***/ }),

/***/ 246:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var createNode = __nccwpck_require__(9652);
var stringifyPair = __nccwpck_require__(4875);
var addPairToJSMap = __nccwpck_require__(94676);
var Node = __nccwpck_require__(41399);

function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (Node.isNode(key))
            key = key.clone(schema);
        if (Node.isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

exports.Pair = Pair;
exports.createPair = createPair;


/***/ }),

/***/ 9338:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var toJS = __nccwpck_require__(72463);

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends Node.NodeBase {
    constructor(value) {
        super(Node.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;


/***/ }),

/***/ 16011:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var stringifyCollection = __nccwpck_require__(22466);
var addPairToJSMap = __nccwpck_require__(94676);
var Collection = __nccwpck_require__(3466);
var Node = __nccwpck_require__(41399);
var Pair = __nccwpck_require__(246);
var Scalar = __nccwpck_require__(9338);

function findPair(items, key) {
    const k = Node.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (Node.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (Node.isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(Node.MAP, schema);
        this.items = [];
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (Node.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair?.value);
        }
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && Node.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!Node.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;


/***/ }),

/***/ 25161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var stringifyCollection = __nccwpck_require__(22466);
var Collection = __nccwpck_require__(3466);
var Node = __nccwpck_require__(41399);
var Scalar = __nccwpck_require__(9338);
var toJS = __nccwpck_require__(72463);

class YAMLSeq extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(Node.SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && Node.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (Node.isScalar(prev) && Scalar.isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
}
function asItemIndex(key) {
    let idx = Node.isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

exports.YAMLSeq = YAMLSeq;


/***/ }),

/***/ 94676:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var log = __nccwpck_require__(36909);
var stringify = __nccwpck_require__(18409);
var Node = __nccwpck_require__(41399);
var Scalar = __nccwpck_require__(9338);
var toJS = __nccwpck_require__(72463);

const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value = Node.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (Node.isSeq(value))
            for (const it of value.items)
                mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
            for (const it of value)
                mergeToJSMap(ctx, map, it);
        else
            mergeToJSMap(ctx, map, value);
    }
    else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS.toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
const isMergeKey = (key) => key === MERGE_KEY ||
    (Node.isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.Scalar.PLAIN));
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
    const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!Node.isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (Node.isNode(key) && ctx && ctx.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

exports.addPairToJSMap = addPairToJSMap;


/***/ }),

/***/ 72463:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !Node.hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

exports.toJS = toJS;


/***/ }),

/***/ 89027:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var resolveBlockScalar = __nccwpck_require__(7521);
var resolveFlowScalar = __nccwpck_require__(97578);
var errors = __nccwpck_require__(14236);
var stringifyString = __nccwpck_require__(46226);

function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;


/***/ }),

/***/ 86307:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

exports.stringify = stringify;


/***/ }),

/***/ 98497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]`  Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null`  Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]`  Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token`  The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

exports.visit = visit;


/***/ }),

/***/ 19169:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var cstScalar = __nccwpck_require__(89027);
var cstStringify = __nccwpck_require__(86307);
var cstVisit = __nccwpck_require__(98497);

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;


/***/ }),

/***/ 45976:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var cst = __nccwpck_require__(19169);

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;


/***/ }),

/***/ 21929:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

exports.LineCounter = LineCounter;


/***/ }),

/***/ 73328:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var cst = __nccwpck_require__(19169);
var lexer = __nccwpck_require__(45976);

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;


/***/ }),

/***/ 28649:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var composer = __nccwpck_require__(19493);
var Document = __nccwpck_require__(10042);
var errors = __nccwpck_require__(14236);
var log = __nccwpck_require__(36909);
var lineCounter = __nccwpck_require__(21929);
var parser = __nccwpck_require__(73328);

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;
    return { lineCounter: lineCounter$1, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    return new Document.Document(value, _replacer, options).toString(options);
}

exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;


/***/ }),

/***/ 56831:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var map = __nccwpck_require__(60083);
var seq = __nccwpck_require__(91693);
var string = __nccwpck_require__(32201);
var tags = __nccwpck_require__(74138);

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? tags.getTags(compat, 'compat')
            : compat
                ? tags.getTags(null, compat)
                : null;
        this.merge = !!merge;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, Node.MAP, { value: map.map });
        Object.defineProperty(this, Node.SCALAR, { value: string.string });
        Object.defineProperty(this, Node.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

exports.Schema = Schema;


/***/ }),

/***/ 60083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var Pair = __nccwpck_require__(246);
var YAMLMap = __nccwpck_require__(16011);

function createMap(schema, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map = new YAMLMap.YAMLMap(schema);
    const add = (key, value) => {
        if (typeof replacer === 'function')
            value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
        if (value !== undefined || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
        for (const [key, value] of obj)
            add(key, value);
    }
    else if (obj && typeof obj === 'object') {
        for (const key of Object.keys(obj))
            add(key, obj[key]);
    }
    if (typeof schema.sortMapEntries === 'function') {
        map.items.sort(schema.sortMapEntries);
    }
    return map;
}
const map = {
    collection: 'map',
    createNode: createMap,
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!Node.isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    }
};

exports.map = map;


/***/ }),

/***/ 26703:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

exports.nullTag = nullTag;


/***/ }),

/***/ 91693:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var createNode = __nccwpck_require__(9652);
var Node = __nccwpck_require__(41399);
var YAMLSeq = __nccwpck_require__(25161);

function createSeq(schema, obj, ctx) {
    const { replacer } = ctx;
    const seq = new YAMLSeq.YAMLSeq(schema);
    if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
            if (typeof replacer === 'function') {
                const key = obj instanceof Set ? it : String(i++);
                it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, undefined, ctx));
        }
    }
    return seq;
}
const seq = {
    collection: 'seq',
    createNode: createSeq,
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!Node.isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    }
};

exports.seq = seq;


/***/ }),

/***/ 32201:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var stringifyString = __nccwpck_require__(46226);

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
};

exports.string = string;


/***/ }),

/***/ 42045:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

exports.boolTag = boolTag;


/***/ }),

/***/ 36810:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);
var stringifyNumber = __nccwpck_require__(84174);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 63019:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var stringifyNumber = __nccwpck_require__(84174);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
}
const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, '0o')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 20027:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var map = __nccwpck_require__(60083);
var _null = __nccwpck_require__(26703);
var seq = __nccwpck_require__(91693);
var string = __nccwpck_require__(32201);
var bool = __nccwpck_require__(42045);
var float = __nccwpck_require__(36810);
var int = __nccwpck_require__(63019);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
];

exports.schema = schema;


/***/ }),

/***/ 14545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);
var map = __nccwpck_require__(60083);
var seq = __nccwpck_require__(91693);

function intIdentify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true|false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

exports.schema = schema;


/***/ }),

/***/ 74138:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var map = __nccwpck_require__(60083);
var _null = __nccwpck_require__(26703);
var seq = __nccwpck_require__(91693);
var string = __nccwpck_require__(32201);
var bool = __nccwpck_require__(42045);
var float = __nccwpck_require__(36810);
var int = __nccwpck_require__(63019);
var schema = __nccwpck_require__(20027);
var schema$1 = __nccwpck_require__(14545);
var binary = __nccwpck_require__(5724);
var omap = __nccwpck_require__(28974);
var pairs = __nccwpck_require__(29841);
var schema$2 = __nccwpck_require__(15389);
var set = __nccwpck_require__(37847);
var timestamp = __nccwpck_require__(21156);

const schemas = new Map([
    ['core', schema.schema],
    ['failsafe', [map.map, seq.seq, string.string]],
    ['json', schema$1.schema],
    ['yaml11', schema$2.schema],
    ['yaml-1.1', schema$2.schema]
]);
const tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary.binary,
    'tag:yaml.org,2002:omap': omap.omap,
    'tag:yaml.org,2002:pairs': pairs.pairs,
    'tag:yaml.org,2002:set': set.set,
    'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    return tags.map(tag => {
        if (typeof tag !== 'string')
            return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
            return tagObj;
        const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}

exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;


/***/ }),

/***/ 5724:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);
var stringifyString = __nccwpck_require__(46226);

const binary = {
    identify: value => value instanceof Uint8Array,
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof Buffer === 'function') {
            return Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === 'function') {
            str =
                buf instanceof Buffer
                    ? buf.toString('base64')
                    : Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        if (!type)
            type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

exports.binary = binary;


/***/ }),

/***/ 42631:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
};

exports.falseTag = falseTag;
exports.trueTag = trueTag;


/***/ }),

/***/ 28035:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);
var stringifyNumber = __nccwpck_require__(84174);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 19503:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var stringifyNumber = __nccwpck_require__(84174);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 28974:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var YAMLSeq = __nccwpck_require__(25161);
var toJS = __nccwpck_require__(72463);
var Node = __nccwpck_require__(41399);
var YAMLMap = __nccwpck_require__(16011);
var pairs = __nccwpck_require__(29841);

class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (Node.isPair(pair)) {
                key = toJS.toJS(pair.key, '', ctx);
                value = toJS.toJS(pair.value, key, ctx);
            }
            else {
                key = toJS.toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
            if (Node.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
    },
    createNode(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new YAMLOMap();
        omap.items = pairs$1.items;
        return omap;
    }
};

exports.YAMLOMap = YAMLOMap;
exports.omap = omap;


/***/ }),

/***/ 29841:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var Pair = __nccwpck_require__(246);
var Scalar = __nccwpck_require__(9338);
var YAMLSeq = __nccwpck_require__(25161);

function resolvePairs(seq, onError) {
    if (Node.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (Node.isPair(item))
                continue;
            else if (Node.isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else
                    throw new TypeError(`Expected { key: value } tuple: ${it}`);
            }
            else {
                key = it;
            }
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;


/***/ }),

/***/ 15389:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var map = __nccwpck_require__(60083);
var _null = __nccwpck_require__(26703);
var seq = __nccwpck_require__(91693);
var string = __nccwpck_require__(32201);
var binary = __nccwpck_require__(5724);
var bool = __nccwpck_require__(42631);
var float = __nccwpck_require__(28035);
var int = __nccwpck_require__(19503);
var omap = __nccwpck_require__(28974);
var pairs = __nccwpck_require__(29841);
var set = __nccwpck_require__(37847);
var timestamp = __nccwpck_require__(21156);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
];

exports.schema = schema;


/***/ }),

/***/ 37847:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var Pair = __nccwpck_require__(246);
var YAMLMap = __nccwpck_require__(16011);

class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (Node.isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair.Pair(key.key, null);
        else
            pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && Node.isPair(pair)
            ? Node.isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair.Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    resolve(map, onError) {
        if (Node.isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new YAMLSet(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(Pair.createPair(value, null, ctx));
            }
        return set;
    }
};

exports.YAMLSet = YAMLSet;
exports.set = set;


/***/ }),

/***/ 21156:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var stringifyNumber = __nccwpck_require__(84174);

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => (n < 10 ? '0' + String(n) : String(n)))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;


/***/ }),

/***/ 62889:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i);
            end = i + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    while (ch === ' ' || ch === '\t') {
        do {
            ch = text[(i += 1)];
        } while (ch && ch !== '\n');
        ch = text[i + 1];
    }
    return i;
}

exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;


/***/ }),

/***/ 18409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var anchors = __nccwpck_require__(28459);
var Node = __nccwpck_require__(41399);
var stringifyComment = __nccwpck_require__(85182);
var stringifyString = __nccwpck_require__(46226);

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (Node.isScalar(item)) {
        obj = item.value;
        const match = tags.filter(t => t.identify?.(obj));
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (Node.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (Node.isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = Node.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : Node.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return Node.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;


/***/ }),

/***/ 22466:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Collection = __nccwpck_require__(3466);
var Node = __nccwpck_require__(41399);
var stringify = __nccwpck_require__(18409);
var stringifyComment = __nccwpck_require__(85182);

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (Node.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (Node.isPair(item)) {
            const ik = Node.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (Node.isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (Node.isPair(item)) {
            const ik = Node.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = Node.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik && ik.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    let str;
    const { start, end } = flowChars;
    if (lines.length === 0) {
        str = start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
            str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            str += `\n${indent}${end}`;
        }
        else {
            str = `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
    if (comment) {
        str += stringifyComment.lineComment(str, commentString(comment), indent);
        if (onComment)
            onComment();
    }
    return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

exports.stringifyCollection = stringifyCollection;


/***/ }),

/***/ 85182:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

exports.indentComment = indentComment;
exports.lineComment = lineComment;
exports.stringifyComment = stringifyComment;


/***/ }),

/***/ 35225:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var stringify = __nccwpck_require__(18409);
var stringifyComment = __nccwpck_require__(85182);

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (Node.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += stringifyComment.lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(stringifyComment.indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

exports.stringifyDocument = stringifyDocument;


/***/ }),

/***/ 84174:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

exports.stringifyNumber = stringifyNumber;


/***/ }),

/***/ 4875:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);
var Scalar = __nccwpck_require__(9338);
var stringify = __nccwpck_require__(18409);
var stringifyComment = __nccwpck_require__(85182);

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (Node.isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (Node.isCollection(key)) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            Node.isCollection(key) ||
            (Node.isScalar(key)
                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (Node.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && Node.isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        Node.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && Node.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

exports.stringifyPair = stringifyPair;


/***/ }),

/***/ 46226:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Scalar = __nccwpck_require__(9338);
var foldFlowLines = __nccwpck_require__(62889);

const getFoldOptions = (ctx) => ({
    indentAtStart: ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value
        .replace(/\n+/g, '\n$&')
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
    return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, inFlow } = ctx;
    if ((implicitKey && /[\n[\]{},]/.test(value)) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (!value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (indent === '' && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.Scalar.BLOCK_FOLDED:
            case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

exports.stringifyString = stringifyString;


/***/ }),

/***/ 16796:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var Node = __nccwpck_require__(41399);

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (Node.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (Node.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (Node.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (Node.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (Node.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (Node.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = await visitAsync_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (Node.isMap(node))
        return visitor.Map?.(key, node, path);
    if (Node.isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (Node.isPair(node))
        return visitor.Pair?.(key, node, path);
    if (Node.isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (Node.isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (Node.isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (Node.isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (Node.isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = Node.isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

exports.visit = visit;
exports.visitAsync = visitAsync;


/***/ }),

/***/ 62001:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-cloudwatch-logs","description":"AWS SDK for JavaScript Cloudwatch Logs Client for Node.js, Browser and React Native","version":"3.241.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","generate:client":"(cd ../../ && yarn generate-clients -g ./codegen/sdk-codegen/aws-models/cloudwatch-logs.json --keepFiles)"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"2.0.0","@aws-crypto/sha256-js":"2.0.0","@aws-sdk/client-sts":"3.241.0","@aws-sdk/config-resolver":"3.234.0","@aws-sdk/credential-provider-node":"3.241.0","@aws-sdk/fetch-http-handler":"3.226.0","@aws-sdk/hash-node":"3.226.0","@aws-sdk/invalid-dependency":"3.226.0","@aws-sdk/middleware-content-length":"3.226.0","@aws-sdk/middleware-endpoint":"3.226.0","@aws-sdk/middleware-host-header":"3.226.0","@aws-sdk/middleware-logger":"3.226.0","@aws-sdk/middleware-recursion-detection":"3.226.0","@aws-sdk/middleware-retry":"3.235.0","@aws-sdk/middleware-serde":"3.226.0","@aws-sdk/middleware-signing":"3.226.0","@aws-sdk/middleware-stack":"3.226.0","@aws-sdk/middleware-user-agent":"3.226.0","@aws-sdk/node-config-provider":"3.226.0","@aws-sdk/node-http-handler":"3.226.0","@aws-sdk/protocol-http":"3.226.0","@aws-sdk/smithy-client":"3.234.0","@aws-sdk/types":"3.226.0","@aws-sdk/url-parser":"3.226.0","@aws-sdk/util-base64":"3.208.0","@aws-sdk/util-body-length-browser":"3.188.0","@aws-sdk/util-body-length-node":"3.208.0","@aws-sdk/util-defaults-mode-browser":"3.234.0","@aws-sdk/util-defaults-mode-node":"3.234.0","@aws-sdk/util-endpoints":"3.241.0","@aws-sdk/util-retry":"3.229.0","@aws-sdk/util-user-agent-browser":"3.226.0","@aws-sdk/util-user-agent-node":"3.226.0","@aws-sdk/util-utf8-browser":"3.188.0","@aws-sdk/util-utf8-node":"3.208.0","tslib":"^2.3.1"},"devDependencies":{"@aws-sdk/service-client-documentation-generator":"3.208.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.19.2","typescript":"~4.6.2"},"overrides":{"typedoc":{"typescript":"~4.6.2"}},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cloudwatch-logs","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-cloudwatch-logs"}}');

/***/ }),

/***/ 97035:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-codedeploy","description":"AWS SDK for JavaScript Codedeploy Client for Node.js, Browser and React Native","version":"3.241.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","generate:client":"(cd ../../ && yarn generate-clients -g ./codegen/sdk-codegen/aws-models/codedeploy.json --keepFiles)"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"2.0.0","@aws-crypto/sha256-js":"2.0.0","@aws-sdk/client-sts":"3.241.0","@aws-sdk/config-resolver":"3.234.0","@aws-sdk/credential-provider-node":"3.241.0","@aws-sdk/fetch-http-handler":"3.226.0","@aws-sdk/hash-node":"3.226.0","@aws-sdk/invalid-dependency":"3.226.0","@aws-sdk/middleware-content-length":"3.226.0","@aws-sdk/middleware-endpoint":"3.226.0","@aws-sdk/middleware-host-header":"3.226.0","@aws-sdk/middleware-logger":"3.226.0","@aws-sdk/middleware-recursion-detection":"3.226.0","@aws-sdk/middleware-retry":"3.235.0","@aws-sdk/middleware-serde":"3.226.0","@aws-sdk/middleware-signing":"3.226.0","@aws-sdk/middleware-stack":"3.226.0","@aws-sdk/middleware-user-agent":"3.226.0","@aws-sdk/node-config-provider":"3.226.0","@aws-sdk/node-http-handler":"3.226.0","@aws-sdk/protocol-http":"3.226.0","@aws-sdk/smithy-client":"3.234.0","@aws-sdk/types":"3.226.0","@aws-sdk/url-parser":"3.226.0","@aws-sdk/util-base64":"3.208.0","@aws-sdk/util-body-length-browser":"3.188.0","@aws-sdk/util-body-length-node":"3.208.0","@aws-sdk/util-defaults-mode-browser":"3.234.0","@aws-sdk/util-defaults-mode-node":"3.234.0","@aws-sdk/util-endpoints":"3.241.0","@aws-sdk/util-retry":"3.229.0","@aws-sdk/util-user-agent-browser":"3.226.0","@aws-sdk/util-user-agent-node":"3.226.0","@aws-sdk/util-utf8-browser":"3.188.0","@aws-sdk/util-utf8-node":"3.208.0","@aws-sdk/util-waiter":"3.226.0","tslib":"^2.3.1"},"devDependencies":{"@aws-sdk/service-client-documentation-generator":"3.208.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.19.2","typescript":"~4.6.2"},"overrides":{"typedoc":{"typescript":"~4.6.2"}},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-codedeploy","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-codedeploy"}}');

/***/ }),

/***/ 95223:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-ecs","description":"AWS SDK for JavaScript Ecs Client for Node.js, Browser and React Native","version":"3.241.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","generate:client":"(cd ../../ && yarn generate-clients -g ./codegen/sdk-codegen/aws-models/ecs.json --keepFiles)"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"2.0.0","@aws-crypto/sha256-js":"2.0.0","@aws-sdk/client-sts":"3.241.0","@aws-sdk/config-resolver":"3.234.0","@aws-sdk/credential-provider-node":"3.241.0","@aws-sdk/fetch-http-handler":"3.226.0","@aws-sdk/hash-node":"3.226.0","@aws-sdk/invalid-dependency":"3.226.0","@aws-sdk/middleware-content-length":"3.226.0","@aws-sdk/middleware-endpoint":"3.226.0","@aws-sdk/middleware-host-header":"3.226.0","@aws-sdk/middleware-logger":"3.226.0","@aws-sdk/middleware-recursion-detection":"3.226.0","@aws-sdk/middleware-retry":"3.235.0","@aws-sdk/middleware-serde":"3.226.0","@aws-sdk/middleware-signing":"3.226.0","@aws-sdk/middleware-stack":"3.226.0","@aws-sdk/middleware-user-agent":"3.226.0","@aws-sdk/node-config-provider":"3.226.0","@aws-sdk/node-http-handler":"3.226.0","@aws-sdk/protocol-http":"3.226.0","@aws-sdk/smithy-client":"3.234.0","@aws-sdk/types":"3.226.0","@aws-sdk/url-parser":"3.226.0","@aws-sdk/util-base64":"3.208.0","@aws-sdk/util-body-length-browser":"3.188.0","@aws-sdk/util-body-length-node":"3.208.0","@aws-sdk/util-defaults-mode-browser":"3.234.0","@aws-sdk/util-defaults-mode-node":"3.234.0","@aws-sdk/util-endpoints":"3.241.0","@aws-sdk/util-retry":"3.229.0","@aws-sdk/util-user-agent-browser":"3.226.0","@aws-sdk/util-user-agent-node":"3.226.0","@aws-sdk/util-utf8-browser":"3.188.0","@aws-sdk/util-utf8-node":"3.208.0","@aws-sdk/util-waiter":"3.226.0","tslib":"^2.3.1"},"devDependencies":{"@aws-sdk/service-client-documentation-generator":"3.208.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.19.2","typescript":"~4.6.2"},"overrides":{"typedoc":{"typescript":"~4.6.2"}},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ecs","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-ecs"}}');

/***/ }),

/***/ 69722:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sso-oidc","description":"AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native","version":"3.241.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","generate:client":"(cd ../../ && yarn generate-clients -g ./codegen/sdk-codegen/aws-models/sso-oidc.json --keepFiles)"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"2.0.0","@aws-crypto/sha256-js":"2.0.0","@aws-sdk/config-resolver":"3.234.0","@aws-sdk/fetch-http-handler":"3.226.0","@aws-sdk/hash-node":"3.226.0","@aws-sdk/invalid-dependency":"3.226.0","@aws-sdk/middleware-content-length":"3.226.0","@aws-sdk/middleware-endpoint":"3.226.0","@aws-sdk/middleware-host-header":"3.226.0","@aws-sdk/middleware-logger":"3.226.0","@aws-sdk/middleware-recursion-detection":"3.226.0","@aws-sdk/middleware-retry":"3.235.0","@aws-sdk/middleware-serde":"3.226.0","@aws-sdk/middleware-stack":"3.226.0","@aws-sdk/middleware-user-agent":"3.226.0","@aws-sdk/node-config-provider":"3.226.0","@aws-sdk/node-http-handler":"3.226.0","@aws-sdk/protocol-http":"3.226.0","@aws-sdk/smithy-client":"3.234.0","@aws-sdk/types":"3.226.0","@aws-sdk/url-parser":"3.226.0","@aws-sdk/util-base64":"3.208.0","@aws-sdk/util-body-length-browser":"3.188.0","@aws-sdk/util-body-length-node":"3.208.0","@aws-sdk/util-defaults-mode-browser":"3.234.0","@aws-sdk/util-defaults-mode-node":"3.234.0","@aws-sdk/util-endpoints":"3.241.0","@aws-sdk/util-retry":"3.229.0","@aws-sdk/util-user-agent-browser":"3.226.0","@aws-sdk/util-user-agent-node":"3.226.0","@aws-sdk/util-utf8-browser":"3.188.0","@aws-sdk/util-utf8-node":"3.208.0","tslib":"^2.3.1"},"devDependencies":{"@aws-sdk/service-client-documentation-generator":"3.208.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.19.2","typescript":"~4.6.2"},"overrides":{"typedoc":{"typescript":"~4.6.2"}},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sso-oidc"}}');

/***/ }),

/***/ 91092:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sso","description":"AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native","version":"3.241.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","generate:client":"(cd ../../ && yarn generate-clients -g ./codegen/sdk-codegen/aws-models/sso.json --keepFiles)"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"2.0.0","@aws-crypto/sha256-js":"2.0.0","@aws-sdk/config-resolver":"3.234.0","@aws-sdk/fetch-http-handler":"3.226.0","@aws-sdk/hash-node":"3.226.0","@aws-sdk/invalid-dependency":"3.226.0","@aws-sdk/middleware-content-length":"3.226.0","@aws-sdk/middleware-endpoint":"3.226.0","@aws-sdk/middleware-host-header":"3.226.0","@aws-sdk/middleware-logger":"3.226.0","@aws-sdk/middleware-recursion-detection":"3.226.0","@aws-sdk/middleware-retry":"3.235.0","@aws-sdk/middleware-serde":"3.226.0","@aws-sdk/middleware-stack":"3.226.0","@aws-sdk/middleware-user-agent":"3.226.0","@aws-sdk/node-config-provider":"3.226.0","@aws-sdk/node-http-handler":"3.226.0","@aws-sdk/protocol-http":"3.226.0","@aws-sdk/smithy-client":"3.234.0","@aws-sdk/types":"3.226.0","@aws-sdk/url-parser":"3.226.0","@aws-sdk/util-base64":"3.208.0","@aws-sdk/util-body-length-browser":"3.188.0","@aws-sdk/util-body-length-node":"3.208.0","@aws-sdk/util-defaults-mode-browser":"3.234.0","@aws-sdk/util-defaults-mode-node":"3.234.0","@aws-sdk/util-endpoints":"3.241.0","@aws-sdk/util-retry":"3.229.0","@aws-sdk/util-user-agent-browser":"3.226.0","@aws-sdk/util-user-agent-node":"3.226.0","@aws-sdk/util-utf8-browser":"3.188.0","@aws-sdk/util-utf8-node":"3.208.0","tslib":"^2.3.1"},"devDependencies":{"@aws-sdk/service-client-documentation-generator":"3.208.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.19.2","typescript":"~4.6.2"},"overrides":{"typedoc":{"typescript":"~4.6.2"}},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sso"}}');

/***/ }),

/***/ 7947:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sts","description":"AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native","version":"3.241.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","test":"yarn test:unit","test:unit":"jest","generate:client":"(cd ../../ && yarn generate-clients -g ./codegen/sdk-codegen/aws-models/sts.json --keepFiles)"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"2.0.0","@aws-crypto/sha256-js":"2.0.0","@aws-sdk/config-resolver":"3.234.0","@aws-sdk/credential-provider-node":"3.241.0","@aws-sdk/fetch-http-handler":"3.226.0","@aws-sdk/hash-node":"3.226.0","@aws-sdk/invalid-dependency":"3.226.0","@aws-sdk/middleware-content-length":"3.226.0","@aws-sdk/middleware-endpoint":"3.226.0","@aws-sdk/middleware-host-header":"3.226.0","@aws-sdk/middleware-logger":"3.226.0","@aws-sdk/middleware-recursion-detection":"3.226.0","@aws-sdk/middleware-retry":"3.235.0","@aws-sdk/middleware-sdk-sts":"3.226.0","@aws-sdk/middleware-serde":"3.226.0","@aws-sdk/middleware-signing":"3.226.0","@aws-sdk/middleware-stack":"3.226.0","@aws-sdk/middleware-user-agent":"3.226.0","@aws-sdk/node-config-provider":"3.226.0","@aws-sdk/node-http-handler":"3.226.0","@aws-sdk/protocol-http":"3.226.0","@aws-sdk/smithy-client":"3.234.0","@aws-sdk/types":"3.226.0","@aws-sdk/url-parser":"3.226.0","@aws-sdk/util-base64":"3.208.0","@aws-sdk/util-body-length-browser":"3.188.0","@aws-sdk/util-body-length-node":"3.208.0","@aws-sdk/util-defaults-mode-browser":"3.234.0","@aws-sdk/util-defaults-mode-node":"3.234.0","@aws-sdk/util-endpoints":"3.241.0","@aws-sdk/util-retry":"3.229.0","@aws-sdk/util-user-agent-browser":"3.226.0","@aws-sdk/util-user-agent-node":"3.226.0","@aws-sdk/util-utf8-browser":"3.188.0","@aws-sdk/util-utf8-node":"3.208.0","fast-xml-parser":"4.0.11","tslib":"^2.3.1"},"devDependencies":{"@aws-sdk/service-client-documentation-generator":"3.208.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.19.2","typescript":"~4.6.2"},"overrides":{"typedoc":{"typescript":"~4.6.2"}},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sts"}}');

/***/ }),

/***/ 95367:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"partitions":[{"id":"aws","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^(us|eu|ap|sa|ca|me|af)\\\\-\\\\w+\\\\-\\\\d+$","regions":{"af-south-1":{"description":"Africa (Cape Town)"},"ap-east-1":{"description":"Asia Pacific (Hong Kong)"},"ap-northeast-1":{"description":"Asia Pacific (Tokyo)"},"ap-northeast-2":{"description":"Asia Pacific (Seoul)"},"ap-northeast-3":{"description":"Asia Pacific (Osaka)"},"ap-south-1":{"description":"Asia Pacific (Mumbai)"},"ap-south-2":{"description":"Asia Pacific (Hyderabad)"},"ap-southeast-1":{"description":"Asia Pacific (Singapore)"},"ap-southeast-2":{"description":"Asia Pacific (Sydney)"},"ap-southeast-3":{"description":"Asia Pacific (Jakarta)"},"aws-global":{"description":"AWS Standard global region"},"ca-central-1":{"description":"Canada (Central)"},"eu-central-1":{"description":"Europe (Frankfurt)"},"eu-central-2":{"description":"Europe (Zurich)"},"eu-north-1":{"description":"Europe (Stockholm)"},"eu-south-1":{"description":"Europe (Milan)"},"eu-south-2":{"description":"Europe (Spain)"},"eu-west-1":{"description":"Europe (Ireland)"},"eu-west-2":{"description":"Europe (London)"},"eu-west-3":{"description":"Europe (Paris)"},"me-central-1":{"description":"Middle East (UAE)"},"me-south-1":{"description":"Middle East (Bahrain)"},"sa-east-1":{"description":"South America (So Paulo)"},"us-east-1":{"description":"US East (N. Virginia)"},"us-east-2":{"description":"US East (Ohio)"},"us-west-1":{"description":"US West (N. California)"},"us-west-2":{"description":"US West (Oregon)"}}},{"id":"aws-cn","outputs":{"dnsSuffix":"amazonaws.com.cn","dualStackDnsSuffix":"api.amazonwebservices.com.cn","name":"aws-cn","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^cn\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-cn-global":{"description":"AWS China global region"},"cn-north-1":{"description":"China (Beijing)"},"cn-northwest-1":{"description":"China (Ningxia)"}}},{"id":"aws-us-gov","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws-us-gov","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-us-gov-global":{"description":"AWS GovCloud (US) global region"},"us-gov-east-1":{"description":"AWS GovCloud (US-East)"},"us-gov-west-1":{"description":"AWS GovCloud (US-West)"}}},{"id":"aws-iso","outputs":{"dnsSuffix":"c2s.ic.gov","dualStackDnsSuffix":"c2s.ic.gov","name":"aws-iso","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-global":{"description":"AWS ISO (US) global region"},"us-iso-east-1":{"description":"US ISO East"},"us-iso-west-1":{"description":"US ISO WEST"}}},{"id":"aws-iso-b","outputs":{"dnsSuffix":"sc2s.sgov.gov","dualStackDnsSuffix":"sc2s.sgov.gov","name":"aws-iso-b","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-b-global":{"description":"AWS ISOB (US) global region"},"us-isob-east-1":{"description":"US ISOB East (Ohio)"}}}],"version":"1.1"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(32932);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;